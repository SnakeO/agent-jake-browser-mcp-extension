This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  plans/
    http-transport-mcp-architecture.md
icons/
  agent-jake-logo.svg
  icon128.png
  icon128.svg
  icon16.png
  icon48.png
scripts/
  generate-icons.js
src/
  background/
    tools/
      index.ts
      schemas.ts
      utils.ts
    activity-log.ts
    api-client.ts
    auth-service.ts
    connection-state.ts
    index.ts
    reverb-client.ts
    sw-polyfill.ts
    tab-manager.ts
    tool-handlers.ts
    ws-client.ts
  constants/
    debugger.ts
    highlight.ts
    index.ts
    keys.ts
    timeouts.ts
  content/
    aria/
      index.ts
      roles.ts
    aria-tree.ts
    index.ts
    selector.ts
  popup/
    index.html
    popup.ts
  types/
    activity.ts
    config.ts
    messages.ts
  utils/
    logger.ts
test-results/
  .last-run.json
tests/
  unit/
    aria/
      roles.test.ts
    background/
      api-client.test.ts
      auth-service.test.ts
      reverb-client.test.ts
    tools/
      keyboard.test.ts
      utils.test.ts
    tool-schemas.test.ts
  extension.spec.ts
.gitignore
LICENSE
manifest.json
package.json
playwright.config.ts
README.md
tsconfig.json
vite.config.ts
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/plans/http-transport-mcp-architecture.md">
# HTTP Transport MCP Architecture

## Current Architecture (STDIO)

```mermaid
sequenceDiagram
    participant Job as PHP Queue Worker
    participant Lock as File Lock
    participant MCP as MCP Server (spawned)
    participant Ext as Chrome Extension

    Job->>Lock: flock(LOCK_EX)
    Lock-->>Job: acquired
    Job->>MCP: proc_open() spawns process
    Note over MCP: Lives only during job execution
    Job->>MCP: stdin: JSON-RPC request
    MCP->>Ext: WebSocket command
    Ext-->>MCP: response
    MCP-->>Job: stdout: JSON-RPC response
    Job->>MCP: close process
    Job->>Lock: flock(LOCK_UN)
```

**Problems:**
- Each job spawns a new MCP process
- Lock contention between workers
- Suspended processes cause deadlock
- Process spawn overhead (~500ms per job)

---

## Proposed Architecture (HTTP Transport)

```mermaid
sequenceDiagram
    participant Job1 as PHP Worker 1
    participant Job2 as PHP Worker 2
    participant MCP as MCP Server (daemon)
    participant Ext as Chrome Extension

    Note over MCP: Runs as systemd service
    Note over MCP: Listens on HTTP port 8766

    Job1->>MCP: HTTP POST /rpc
    Job2->>MCP: HTTP POST /rpc (concurrent)
    MCP->>Ext: WebSocket (queued)
    Ext-->>MCP: response
    MCP-->>Job1: HTTP 200 JSON-RPC response
    MCP-->>Job2: HTTP 200 JSON-RPC response
```

**Benefits:**
- No process spawning per job
- No file locking needed
- MCP server handles request queuing
- systemd handles crashes/restarts
- Multiple workers can connect simultaneously

---

## Implementation Requirements

### 1. MCP Server Changes (agent-jake-mcp)

Add HTTP transport alongside existing stdio:

```typescript
// Current: stdio only
const server = new McpServer({
  transport: 'stdio'
});

// New: HTTP transport option
const server = new McpServer({
  transport: process.env.MCP_TRANSPORT || 'stdio',
  httpPort: process.env.MCP_HTTP_PORT || 8766,
});
```

HTTP endpoints needed:
- `POST /rpc` - JSON-RPC 2.0 endpoint
- `GET /health` - Health check for systemd/monitoring
- `GET /status` - Connection status (WebSocket to extension)

### 2. systemd Service

```ini
# /etc/systemd/system/agent-jake-mcp.service
[Unit]
Description=Agent Jake MCP Server
After=network.target

[Service]
Type=simple
User=www-data
WorkingDirectory=/var/www/ai-email-sorter
ExecStart=/usr/bin/npx @anthropic-ai/agent-jake-mcp --transport=http --port=8766
Restart=always
RestartSec=5
Environment=NODE_ENV=production

# Health check
ExecStartPost=/bin/sleep 2
ExecStartPost=/usr/bin/curl -f http://localhost:8766/health

[Install]
WantedBy=multi-user.target
```

### 3. PHP Client Changes

Replace `proc_open` with HTTP client:

```php
// Before: McpClient spawns process
$client = new McpClient('npx @anthropic-ai/agent-jake-mcp');
$client->send($request);

// After: McpHttpClient connects to daemon
$client = new McpHttpClient('http://localhost:8766');
$response = $client->call('browser_click', ['ref' => 's1e42']);
```

### 4. Health Monitoring

Laravel scheduler or separate monitor:

```php
// Check MCP server health every minute
Schedule::call(function () {
    $response = Http::timeout(5)->get('http://localhost:8766/health');

    if (!$response->ok()) {
        // Alert or auto-restart
        exec('sudo systemctl restart agent-jake-mcp');
        Log::warning('MCP server restarted due to health check failure');
    }
})->everyMinute();
```

---

## Migration Path

### Phase 1: Add HTTP Transport to MCP Server
- Modify agent-jake-mcp to support `--transport=http`
- Keep stdio as default for backwards compatibility
- Add `/health` and `/rpc` endpoints

### Phase 2: Deploy as systemd Service
- Create systemd unit file
- Configure environment variables
- Set up log rotation

### Phase 3: Update PHP Client
- Create `McpHttpClient` class
- Update `AgentJakeMcpProcessManager` to use HTTP
- Remove file locking code

### Phase 4: Remove STDIO Support (optional)
- Once HTTP is proven stable
- Simplify codebase

---

## Comparison: STDIO vs HTTP

| Aspect | STDIO (Current) | HTTP (Proposed) |
|--------|-----------------|-----------------|
| Process lifecycle | Per-job spawn | Long-running daemon |
| Concurrency | Lock-based serialization | Server-side queuing |
| Failure recovery | Manual intervention | systemd auto-restart |
| Latency | ~500ms spawn overhead | ~10ms HTTP call |
| Complexity | Process management in PHP | systemd + HTTP client |
| Debugging | Hard (process per job) | Easy (single process, logs) |

---

## Questions to Resolve

1. **Request queuing**: Should MCP server queue browser commands or reject concurrent requests?
2. **Authentication**: Should HTTP endpoint require API key?
3. **Timeouts**: How to handle long-running browser operations over HTTP?
4. **WebSocket reconnection**: If extension disconnects, how does HTTP endpoint respond?

---

## Files to Create/Modify

| File | Action | Description |
|------|--------|-------------|
| `agent-jake-mcp/src/transports/http.ts` | CREATE | HTTP transport implementation |
| `agent-jake-mcp/src/server.ts` | MODIFY | Support transport selection |
| `agent-jake-mcp/package.json` | MODIFY | Add express/fastify dependency |
| `deploy/agent-jake-mcp.service` | CREATE | systemd unit file |
| `app/.../McpHttpClient.php` | CREATE | PHP HTTP client |
| `app/.../AgentJakeMcpProcessManager.php` | MODIFY | Use HTTP instead of stdio |
</file>

<file path="src/background/api-client.ts">
/**
 * API client for Laravel backend communication.
 * Handles authentication and extension API endpoints.
 */

import { CONFIG } from '../types/config';

export interface AuthUser {
  id: number;
  name: string;
  email: string;
}

export interface LoginResponse {
  success: boolean;
  token?: string;
  user?: AuthUser;
  error?: string;
}

export interface ConnectionStatus {
  online: boolean;
  connected_at?: string;
  last_seen?: string;
  session_id?: string;
}

export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
  /** HTTP status code for error handling */
  status?: number;
  /** Whether error is recoverable (can retry) */
  isRecoverable?: boolean;
}

/**
 * API client class for communicating with Laravel backend.
 */
export class ApiClient {
  private baseUrl: string;
  private token: string | null = null;

  constructor() {
    this.baseUrl = CONFIG.API_URL;
  }

  /**
   * Set the authentication token.
   */
  setToken(token: string | null): void {
    this.token = token;
  }

  /**
   * Get the current token.
   */
  getToken(): string | null {
    return this.token;
  }

  /**
   * Make an API request.
   */
  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<ApiResponse<T>> {
    const url = `${this.baseUrl}${endpoint}`;
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      ...(options.headers as Record<string, string> || {}),
    };

    if (this.token) {
      headers['Authorization'] = `Bearer ${this.token}`;
    }

    try {
      const response = await fetch(url, {
        ...options,
        headers,
      });

      // Try to parse JSON response
      let data: Record<string, unknown> = {};
      try {
        data = await response.json();
      } catch {
        // Response might not be JSON
      }

      if (!response.ok) {
        const errorMessage = (data.message as string) ||
                            (data.error as string) ||
                            `HTTP ${response.status}`;

        // Categorize error for offline handling
        const isRecoverable = this.isRecoverableStatus(response.status);

        return {
          success: false,
          error: errorMessage,
          status: response.status,
          isRecoverable,
        };
      }

      return {
        success: true,
        data: data as T,
        status: response.status,
      };
    } catch (error) {
      // Network errors (fetch failed)
      const isNetworkError = error instanceof TypeError ||
                            (error instanceof Error && error.message.includes('fetch'));

      return {
        success: false,
        error: error instanceof Error ? error.message : 'Network error',
        status: 0, // 0 indicates network error
        isRecoverable: isNetworkError, // Network errors are recoverable
      };
    }
  }

  /**
   * Check if HTTP status indicates a recoverable error.
   */
  private isRecoverableStatus(status: number): boolean {
    // 5xx errors: server issues, usually recoverable
    if (status >= 500) return true;
    // 429: rate limited, recoverable after waiting
    if (status === 429) return true;
    // 408: request timeout, recoverable
    if (status === 408) return true;
    // 401/403: auth issues, NOT recoverable without user action
    if (status === 401 || status === 403) return false;
    // 4xx: client errors, usually not recoverable
    return false;
  }

  /**
   * Login with email and password.
   */
  async login(email: string, password: string): Promise<LoginResponse> {
    const result = await this.request<{ token: string; user: AuthUser }>(
      '/api/v1/extension/login',
      {
        method: 'POST',
        body: JSON.stringify({ email, password }),
      }
    );

    if (result.success && result.data) {
      // Server wraps response in { data: {...} } envelope
      const responseData = (result.data as unknown as { data: { token: string; user: AuthUser } }).data;
      this.token = responseData.token;
      return {
        success: true,
        token: responseData.token,
        user: responseData.user,
      };
    }

    return {
      success: false,
      error: result.error || 'Login failed',
    };
  }

  /**
   * Get the authenticated user's info.
   */
  async getUser(): Promise<ApiResponse<AuthUser>> {
    // Server returns: { data: { user: {...}, connection: {...} } }
    const result = await this.request<{ data: { user: AuthUser } }>('/api/v1/extension/user');
    if (result.success && result.data?.data?.user) {
      return {
        ...result,
        data: result.data.data.user,  // Unwrap to get the user object
      };
    }
    return result as unknown as ApiResponse<AuthUser>;
  }

  /**
   * Mark extension as connected.
   */
  async connect(sessionId: string): Promise<ApiResponse<ConnectionStatus>> {
    return this.request<ConnectionStatus>('/api/v1/extension/connect', {
      method: 'POST',
      body: JSON.stringify({
        session_id: sessionId,
        metadata: {
          browser: 'Chrome',
          extension_version: chrome.runtime.getManifest().version,
        },
      }),
    });
  }

  /**
   * Mark extension as disconnected.
   */
  async disconnect(): Promise<ApiResponse<void>> {
    return this.request<void>('/api/v1/extension/disconnect', {
      method: 'POST',
    });
  }

  /**
   * Send heartbeat to keep connection alive.
   */
  async heartbeat(sessionId: string): Promise<ApiResponse<ConnectionStatus>> {
    return this.request<ConnectionStatus>('/api/v1/extension/heartbeat', {
      method: 'POST',
      body: JSON.stringify({ session_id: sessionId }),
    });
  }

  /**
   * Get current connection status.
   */
  async getStatus(): Promise<ApiResponse<ConnectionStatus>> {
    return this.request<ConnectionStatus>('/api/v1/extension/status');
  }

  /**
   * Send command response back to server.
   */
  async sendCommandResponse(
    commandId: string,
    success: boolean,
    result: unknown = {},
    error?: string
  ): Promise<ApiResponse<void>> {
    return this.request<void>('/api/v1/extension/response', {
      method: 'POST',
      body: JSON.stringify({
        command_id: commandId,
        success,
        result,
        error,
      }),
    });
  }
}

// Singleton instance
export const apiClient = new ApiClient();
</file>

<file path="src/background/auth-service.ts">
/**
 * Authentication service for managing user session.
 * Handles login/logout, token persistence, and session management.
 * Implements graceful offline handling with exponential backoff.
 */

import { apiClient, AuthUser, LoginResponse } from './api-client';
import { logActivity } from './activity-log';
import { reverbClient } from './reverb-client';
import {
  ConnectionStateManager,
  ConnectionState,
  ConnectionInfo,
  ErrorCodes,
  parseHttpError,
  getStateMessage,
} from './connection-state';

const STORAGE_KEYS = {
  TOKEN: 'auth_token',
  USER: 'auth_user',
  SESSION_ID: 'session_id',
} as const;

const HEARTBEAT_INTERVAL_MS = 25000; // 25 seconds (server expects 30s)
const HEARTBEAT_FAILURE_THRESHOLD = 2; // Mark offline after 2 consecutive failures

export interface AuthState {
  isAuthenticated: boolean;
  user: AuthUser | null;
  isConnected: boolean;
  /** Detailed connection state for UI */
  connectionState: ConnectionState;
  /** User-friendly status message */
  statusMessage: string;
  /** Number of reconnect attempts */
  reconnectAttempt: number;
  /** Last error if any */
  lastError: string | null;
}

/**
 * Authentication service class.
 * Implements graceful offline handling with automatic reconnection.
 */
class AuthService {
  private user: AuthUser | null = null;
  private sessionId: string | null = null;
  private heartbeatInterval: ReturnType<typeof setInterval> | null = null;
  private heartbeatFailures = 0;
  private connectionState: ConnectionStateManager;
  private listeners: Set<(state: AuthState) => void> = new Set();

  constructor() {
    // Initialize connection state manager with backoff config
    this.connectionState = new ConnectionStateManager({
      initialDelay: 2000,    // Start with 2 seconds
      maxDelay: 60000,       // Max 1 minute
      multiplier: 1.5,       // Gentler exponential growth
      maxAttempts: 0,        // Unlimited retries
      jitter: true,          // Add randomness
    });

    // Subscribe to connection state changes
    this.connectionState.subscribe(() => this.notifyListeners());
  }

  /**
   * Initialize the auth service - restore session from storage.
   */
  async initialize(): Promise<void> {
    try {
      const stored = await chrome.storage.local.get([
        STORAGE_KEYS.TOKEN,
        STORAGE_KEYS.USER,
        STORAGE_KEYS.SESSION_ID,
      ]);

      if (stored[STORAGE_KEYS.TOKEN] && stored[STORAGE_KEYS.USER]) {
        apiClient.setToken(stored[STORAGE_KEYS.TOKEN] as string);
        this.user = stored[STORAGE_KEYS.USER] as AuthUser;
        this.sessionId = (stored[STORAGE_KEYS.SESSION_ID] as string | undefined) || this.generateSessionId();

        // Verify token is still valid
        const result = await apiClient.getUser();
        if (result.success && result.data) {
          this.user = result.data;
          await this.connectToServer();
          logActivity({
            type: 'auth',
            action: 'session_restored',
            description: `Session restored for ${this.user.email}`,
            success: true,
          });
        } else {
          // Token invalid, clear session
          await this.clearSession();
          logActivity({
            type: 'auth',
            action: 'session_expired',
            description: 'Previous session expired',
            success: false,
          });
        }
      }
    } catch (error) {
      console.error('[AuthService] Failed to initialize:', error);
      await this.clearSession();
    }

    this.notifyListeners();
  }

  /**
   * Login with email and password.
   */
  async login(email: string, password: string): Promise<LoginResponse> {
    const startTime = Date.now();

    try {
      const result = await apiClient.login(email, password);

      if (result.success && result.token && result.user) {
        this.user = result.user;
        this.sessionId = this.generateSessionId();

        // Persist to storage
        await chrome.storage.local.set({
          [STORAGE_KEYS.TOKEN]: result.token,
          [STORAGE_KEYS.USER]: result.user,
          [STORAGE_KEYS.SESSION_ID]: this.sessionId,
        });

        // Connect to server
        await this.connectToServer();

        logActivity({
          type: 'auth',
          action: 'login',
          description: `Signed in as ${result.user.email}`,
          success: true,
          durationMs: Date.now() - startTime,
        });

        this.notifyListeners();
        return result;
      }

      logActivity({
        type: 'auth',
        action: 'login_failed',
        description: result.error || 'Login failed',
        success: false,
        durationMs: Date.now() - startTime,
      });

      return result;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      logActivity({
        type: 'auth',
        action: 'login_error',
        description: errorMsg,
        success: false,
        durationMs: Date.now() - startTime,
      });

      return {
        success: false,
        error: errorMsg,
      };
    }
  }

  /**
   * Logout and clear session.
   */
  async logout(): Promise<void> {
    const userEmail = this.user?.email;

    try {
      // Notify server of disconnect
      if (this.connectionState.isConnected()) {
        await apiClient.disconnect();
      }
    } catch (error) {
      console.error('[AuthService] Error during disconnect:', error);
    }

    await this.clearSession();

    logActivity({
      type: 'auth',
      action: 'logout',
      description: userEmail ? `Signed out from ${userEmail}` : 'Signed out',
      success: true,
    });

    this.notifyListeners();
  }

  /**
   * Connect to the Laravel server (mark online) and Reverb WebSocket.
   * Implements graceful error handling with automatic reconnection.
   */
  private async connectToServer(): Promise<void> {
    if (!this.sessionId || !this.user) return;

    this.connectionState.setConnecting();

    try {
      const result = await apiClient.connect(this.sessionId);

      if (result.success) {
        this.connectionState.setConnected();
        this.heartbeatFailures = 0;
        this.startHeartbeat();

        // Connect to Reverb WebSocket for receiving commands
        await reverbClient.connect(this.user.id);

        logActivity({
          type: 'connection',
          action: 'server_connected',
          description: 'Connected to Sortie server',
          success: true,
        });
      } else {
        // Handle connection failure
        this.handleConnectionError(result.status || 0, result.error || 'Connection failed');
      }
    } catch (error) {
      console.error('[AuthService] Failed to connect to server:', error);
      this.handleConnectionError(0, (error as Error).message);
    }
  }

  /**
   * Handle connection error with automatic reconnection.
   */
  private handleConnectionError(status: number, message: string): void {
    const { code, message: errorMessage } = parseHttpError(status, message);

    // Log the error
    logActivity({
      type: 'error',
      action: 'connection_error',
      description: errorMessage,
      success: false,
      details: { code, status },
    });

    // Handle error and get retry info
    const { shouldRetry, delay } = this.connectionState.handleError(code, errorMessage);

    if (shouldRetry && delay) {
      // Schedule reconnection
      this.connectionState.scheduleReconnect(async () => {
        await this.connectToServer();
      }, delay);

      logActivity({
        type: 'connection',
        action: 'reconnect_scheduled',
        description: `Reconnecting in ${Math.round(delay / 1000)}s (attempt ${this.connectionState.getInfo().reconnectAttempt})`,
        success: true,
      });
    } else if (code === ErrorCodes.AUTH_EXPIRED) {
      // Auth expired - need user to re-login
      logActivity({
        type: 'auth',
        action: 'session_expired',
        description: 'Session expired. Please sign in again.',
        success: false,
      });
    }
  }

  /**
   * Start heartbeat to keep connection alive.
   * Implements failure tracking and automatic reconnection.
   */
  private startHeartbeat(): void {
    this.stopHeartbeat();
    this.heartbeatFailures = 0;

    this.heartbeatInterval = setInterval(async () => {
      if (!this.sessionId) return;

      try {
        const result = await apiClient.heartbeat(this.sessionId);

        if (result.success) {
          // Reset failure counter on success
          this.heartbeatFailures = 0;

          // If we were reconnecting, mark as connected
          if (!this.connectionState.isConnected()) {
            this.connectionState.setConnected();
            logActivity({
              type: 'connection',
              action: 'reconnected',
              description: 'Connection restored',
              success: true,
            });
          }
        } else {
          this.heartbeatFailures++;
          console.warn(`[AuthService] Heartbeat failed (${this.heartbeatFailures}/${HEARTBEAT_FAILURE_THRESHOLD}):`, result.error);

          // Only mark as offline after threshold failures
          if (this.heartbeatFailures >= HEARTBEAT_FAILURE_THRESHOLD) {
            this.handleHeartbeatFailure(result.status || 0, result.error || 'Heartbeat failed');
          }
        }
      } catch (error) {
        this.heartbeatFailures++;
        console.error(`[AuthService] Heartbeat error (${this.heartbeatFailures}/${HEARTBEAT_FAILURE_THRESHOLD}):`, error);

        if (this.heartbeatFailures >= HEARTBEAT_FAILURE_THRESHOLD) {
          this.handleHeartbeatFailure(0, (error as Error).message);
        }
      }
    }, HEARTBEAT_INTERVAL_MS);
  }

  /**
   * Handle heartbeat failure - attempt reconnection.
   */
  private handleHeartbeatFailure(status: number, message: string): void {
    // Stop the heartbeat interval while we reconnect
    this.stopHeartbeat();

    // Handle like a connection error
    this.handleConnectionError(status, message);
  }

  /**
   * Stop heartbeat.
   */
  private stopHeartbeat(): void {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
  }

  /**
   * Clear session data.
   */
  private async clearSession(): Promise<void> {
    this.stopHeartbeat();

    // Reset connection state
    this.connectionState.setDisconnected();
    this.heartbeatFailures = 0;

    // Clear token FIRST to prevent any pending reconnects from succeeding
    apiClient.setToken(null);

    // Then disconnect from Reverb WebSocket
    await reverbClient.disconnect();

    this.user = null;
    this.sessionId = null;

    await chrome.storage.local.remove([
      STORAGE_KEYS.TOKEN,
      STORAGE_KEYS.USER,
      STORAGE_KEYS.SESSION_ID,
    ]);
  }

  /**
   * Generate a unique session ID.
   */
  private generateSessionId(): string {
    return `ext_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
  }

  /**
   * Get current auth state with detailed connection info.
   */
  getState(): AuthState {
    const connInfo = this.connectionState.getInfo();
    return {
      isAuthenticated: this.user !== null,
      user: this.user,
      isConnected: this.connectionState.isConnected(),
      connectionState: connInfo.state,
      statusMessage: getStateMessage(connInfo),
      reconnectAttempt: connInfo.reconnectAttempt,
      lastError: connInfo.lastError?.message || null,
    };
  }

  /**
   * Check if user is authenticated.
   */
  isAuthenticated(): boolean {
    return this.user !== null;
  }

  /**
   * Get current user.
   */
  getUser(): AuthUser | null {
    return this.user;
  }

  /**
   * Get current session ID.
   */
  getSessionId(): string | null {
    return this.sessionId;
  }

  /**
   * Check if connected to server.
   */
  isConnectedToServer(): boolean {
    return this.connectionState.isConnected();
  }

  /**
   * Manually trigger reconnection attempt.
   */
  async reconnect(): Promise<void> {
    if (this.user && this.sessionId) {
      this.connectionState.reset();
      await this.connectToServer();
    }
  }

  /**
   * Subscribe to auth state changes.
   */
  subscribe(listener: (state: AuthState) => void): () => void {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  /**
   * Notify all listeners of state change.
   */
  private notifyListeners(): void {
    const state = this.getState();
    this.listeners.forEach(listener => listener(state));
  }
}

// Singleton instance
export const authService = new AuthService();
</file>

<file path="src/background/connection-state.ts">
/**
 * Connection state management for graceful offline handling.
 * Provides detailed connection states, exponential backoff, and error tracking.
 */

export enum ConnectionState {
  /** Initial state - not yet connected */
  DISCONNECTED = 'disconnected',
  /** Actively trying to connect */
  CONNECTING = 'connecting',
  /** Successfully connected */
  CONNECTED = 'connected',
  /** Connection lost, waiting to retry */
  RECONNECTING = 'reconnecting',
  /** Too many failures, stopped retrying */
  FAILED = 'failed',
  /** Network appears to be offline */
  OFFLINE = 'offline',
}

export interface ConnectionError {
  code: string;
  message: string;
  timestamp: number;
  isRecoverable: boolean;
}

export interface ConnectionInfo {
  state: ConnectionState;
  lastError: ConnectionError | null;
  reconnectAttempt: number;
  nextReconnectAt: number | null;
  connectedSince: number | null;
}

export interface BackoffConfig {
  /** Initial delay in ms */
  initialDelay: number;
  /** Maximum delay in ms */
  maxDelay: number;
  /** Multiplier for each attempt */
  multiplier: number;
  /** Max attempts before giving up (0 = unlimited) */
  maxAttempts: number;
  /** Add random jitter to delay */
  jitter: boolean;
}

const DEFAULT_BACKOFF: BackoffConfig = {
  initialDelay: 1000,    // 1 second
  maxDelay: 60000,       // 1 minute max
  multiplier: 2,
  maxAttempts: 0,        // Unlimited
  jitter: true,
};

/**
 * Error codes for categorizing connection failures.
 */
export const ErrorCodes = {
  NETWORK_ERROR: 'NETWORK_ERROR',
  SERVER_ERROR: 'SERVER_ERROR',
  AUTH_EXPIRED: 'AUTH_EXPIRED',
  RATE_LIMITED: 'RATE_LIMITED',
  WEBSOCKET_ERROR: 'WEBSOCKET_ERROR',
  TIMEOUT: 'TIMEOUT',
  UNKNOWN: 'UNKNOWN',
} as const;

export type ErrorCode = typeof ErrorCodes[keyof typeof ErrorCodes];

/**
 * Connection state manager with exponential backoff.
 */
export class ConnectionStateManager {
  private state: ConnectionState = ConnectionState.DISCONNECTED;
  private lastError: ConnectionError | null = null;
  private reconnectAttempt = 0;
  private reconnectTimer: ReturnType<typeof setTimeout> | null = null;
  private connectedSince: number | null = null;
  private backoffConfig: BackoffConfig;
  private listeners: Set<(info: ConnectionInfo) => void> = new Set();
  private networkListener: (() => void) | null = null;

  constructor(config: Partial<BackoffConfig> = {}) {
    this.backoffConfig = { ...DEFAULT_BACKOFF, ...config };
    this.setupNetworkListener();
  }

  /**
   * Set up network online/offline listener.
   */
  private setupNetworkListener(): void {
    // In Chrome extension service worker, navigator.onLine and online/offline events work
    if (typeof navigator !== 'undefined') {
      this.networkListener = () => {
        if (navigator.onLine && this.state === ConnectionState.OFFLINE) {
          // Network came back online, attempt reconnect
          this.setState(ConnectionState.RECONNECTING);
          this.notifyListeners();
        } else if (!navigator.onLine) {
          this.setState(ConnectionState.OFFLINE);
          this.clearReconnectTimer();
          this.notifyListeners();
        }
      };

      // Check if addEventListener is available (it is in service workers)
      if (typeof globalThis.addEventListener === 'function') {
        globalThis.addEventListener('online', this.networkListener);
        globalThis.addEventListener('offline', this.networkListener);
      }
    }
  }

  /**
   * Clean up listeners.
   */
  destroy(): void {
    this.clearReconnectTimer();
    if (this.networkListener && typeof globalThis.removeEventListener === 'function') {
      globalThis.removeEventListener('online', this.networkListener);
      globalThis.removeEventListener('offline', this.networkListener);
    }
  }

  /**
   * Mark connection as attempting to connect.
   */
  setConnecting(): void {
    this.setState(ConnectionState.CONNECTING);
    this.notifyListeners();
  }

  /**
   * Mark connection as established.
   */
  setConnected(): void {
    this.setState(ConnectionState.CONNECTED);
    this.reconnectAttempt = 0;
    this.lastError = null;
    this.connectedSince = Date.now();
    this.clearReconnectTimer();
    this.notifyListeners();
  }

  /**
   * Mark connection as disconnected (intentional).
   */
  setDisconnected(): void {
    this.setState(ConnectionState.DISCONNECTED);
    this.reconnectAttempt = 0;
    this.lastError = null;
    this.connectedSince = null;
    this.clearReconnectTimer();
    this.notifyListeners();
  }

  /**
   * Handle a connection error and optionally schedule reconnect.
   */
  handleError(
    code: ErrorCode,
    message: string,
    scheduleReconnect = true
  ): { shouldRetry: boolean; delay: number | null } {
    const isRecoverable = this.isRecoverableError(code);

    this.lastError = {
      code,
      message,
      timestamp: Date.now(),
      isRecoverable,
    };

    // Check if network is offline
    if (typeof navigator !== 'undefined' && !navigator.onLine) {
      this.setState(ConnectionState.OFFLINE);
      this.notifyListeners();
      return { shouldRetry: false, delay: null };
    }

    // Non-recoverable errors (like auth expired) - don't retry
    if (!isRecoverable) {
      this.setState(ConnectionState.FAILED);
      this.clearReconnectTimer();
      this.notifyListeners();
      return { shouldRetry: false, delay: null };
    }

    this.reconnectAttempt++;

    // Check max attempts
    if (this.backoffConfig.maxAttempts > 0 &&
        this.reconnectAttempt >= this.backoffConfig.maxAttempts) {
      this.setState(ConnectionState.FAILED);
      this.notifyListeners();
      return { shouldRetry: false, delay: null };
    }

    // Calculate backoff delay
    const delay = this.calculateBackoff();

    this.setState(ConnectionState.RECONNECTING);

    if (scheduleReconnect) {
      // Return delay but don't schedule here - let caller handle it
    }

    this.notifyListeners();
    return { shouldRetry: true, delay };
  }

  /**
   * Schedule a reconnection attempt.
   */
  scheduleReconnect(callback: () => Promise<void>, delay: number): void {
    this.clearReconnectTimer();

    console.log(`[ConnectionState] Scheduling reconnect in ${delay}ms (attempt ${this.reconnectAttempt})`);

    this.reconnectTimer = setTimeout(async () => {
      this.reconnectTimer = null;
      try {
        await callback();
      } catch (error) {
        // Error will be handled by the callback
        console.error('[ConnectionState] Reconnect callback error:', error);
      }
    }, delay);

    this.notifyListeners();
  }

  /**
   * Get the time until next reconnect attempt.
   */
  getNextReconnectAt(): number | null {
    if (this.reconnectTimer && this.state === ConnectionState.RECONNECTING) {
      const delay = this.calculateBackoff();
      // This is approximate since we don't track the exact scheduled time
      return Date.now() + delay;
    }
    return null;
  }

  /**
   * Calculate exponential backoff delay.
   */
  private calculateBackoff(): number {
    const { initialDelay, maxDelay, multiplier, jitter } = this.backoffConfig;

    // Exponential backoff: delay = initialDelay * multiplier^(attempt-1)
    let delay = initialDelay * Math.pow(multiplier, this.reconnectAttempt - 1);

    // Cap at max delay
    delay = Math.min(delay, maxDelay);

    // Add jitter (Â±25%)
    if (jitter) {
      const jitterRange = delay * 0.25;
      delay += (Math.random() * jitterRange * 2) - jitterRange;
    }

    return Math.round(delay);
  }

  /**
   * Check if an error is recoverable.
   */
  private isRecoverableError(code: ErrorCode): boolean {
    switch (code) {
      case ErrorCodes.AUTH_EXPIRED:
        // Auth issues require user action
        return false;
      case ErrorCodes.NETWORK_ERROR:
      case ErrorCodes.SERVER_ERROR:
      case ErrorCodes.WEBSOCKET_ERROR:
      case ErrorCodes.TIMEOUT:
      case ErrorCodes.RATE_LIMITED:
        // These can potentially recover
        return true;
      default:
        return true;
    }
  }

  /**
   * Clear reconnect timer.
   */
  clearReconnectTimer(): void {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
  }

  /**
   * Reset for a new connection attempt.
   */
  reset(): void {
    this.reconnectAttempt = 0;
    this.lastError = null;
    this.clearReconnectTimer();
    this.setState(ConnectionState.DISCONNECTED);
    this.notifyListeners();
  }

  /**
   * Get current connection info.
   */
  getInfo(): ConnectionInfo {
    return {
      state: this.state,
      lastError: this.lastError,
      reconnectAttempt: this.reconnectAttempt,
      nextReconnectAt: this.state === ConnectionState.RECONNECTING ? this.getNextReconnectAt() : null,
      connectedSince: this.connectedSince,
    };
  }

  /**
   * Get current state.
   */
  getState(): ConnectionState {
    return this.state;
  }

  /**
   * Check if currently connected.
   */
  isConnected(): boolean {
    return this.state === ConnectionState.CONNECTED;
  }

  /**
   * Check if connection is being attempted.
   */
  isConnecting(): boolean {
    return this.state === ConnectionState.CONNECTING ||
           this.state === ConnectionState.RECONNECTING;
  }

  /**
   * Set state.
   */
  private setState(state: ConnectionState): void {
    if (this.state !== state) {
      console.log(`[ConnectionState] ${this.state} -> ${state}`);
      this.state = state;
    }
  }

  /**
   * Subscribe to connection info changes.
   */
  subscribe(listener: (info: ConnectionInfo) => void): () => void {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  /**
   * Notify all listeners.
   */
  private notifyListeners(): void {
    const info = this.getInfo();
    this.listeners.forEach(listener => listener(info));
  }
}

/**
 * Parse HTTP response into connection error.
 */
export function parseHttpError(status: number, message: string): { code: ErrorCode; message: string } {
  if (status === 401 || status === 403) {
    return { code: ErrorCodes.AUTH_EXPIRED, message: 'Authentication expired. Please sign in again.' };
  }
  if (status === 429) {
    return { code: ErrorCodes.RATE_LIMITED, message: 'Too many requests. Please wait a moment.' };
  }
  if (status >= 500) {
    return { code: ErrorCodes.SERVER_ERROR, message: message || 'Server error. Retrying...' };
  }
  if (status === 0 || !status) {
    return { code: ErrorCodes.NETWORK_ERROR, message: 'Network error. Check your connection.' };
  }
  return { code: ErrorCodes.UNKNOWN, message: message || 'Unknown error' };
}

/**
 * Get user-friendly message for connection state.
 */
export function getStateMessage(info: ConnectionInfo): string {
  switch (info.state) {
    case ConnectionState.CONNECTED:
      return 'Connected to server';
    case ConnectionState.CONNECTING:
      return 'Connecting...';
    case ConnectionState.RECONNECTING:
      return info.reconnectAttempt > 1
        ? `Reconnecting (attempt ${info.reconnectAttempt})...`
        : 'Reconnecting...';
    case ConnectionState.OFFLINE:
      return 'Network offline';
    case ConnectionState.FAILED:
      if (info.lastError?.code === ErrorCodes.AUTH_EXPIRED) {
        return 'Session expired';
      }
      return 'Connection failed';
    case ConnectionState.DISCONNECTED:
    default:
      return 'Disconnected';
  }
}
</file>

<file path="src/background/reverb-client.ts">
/**
 * Laravel Reverb WebSocket client for receiving browser commands.
 * Uses Laravel Echo with Pusher protocol to connect to Reverb server.
 * Implements graceful offline handling with exponential backoff.
 */

import Echo from 'laravel-echo';
import Pusher from 'pusher-js';
import { CONFIG } from '../types/config';
import { apiClient } from './api-client';
import { logActivity } from './activity-log';
import { ConnectionStateManager, ConnectionState, ErrorCodes } from './connection-state';

// Make Pusher available globally for Laravel Echo
(globalThis as Record<string, unknown>).Pusher = Pusher;

export interface BrowserCommand {
  commandId: string;
  userId: number;
  type: string;
  payload: Record<string, unknown>;
}

export type CommandHandler = (command: BrowserCommand) => Promise<{ success: boolean; result?: unknown; error?: string }>;

/**
 * Reverb client for receiving commands from Laravel server.
 * Implements graceful offline handling with exponential backoff.
 */
class ReverbClient {
  private echo: Echo<'pusher'> | null = null;
  private userId: number | null = null;
  private commandHandler: CommandHandler | null = null;
  private connectionState: ConnectionStateManager;
  private listeners: Set<(connected: boolean) => void> = new Set();

  constructor() {
    this.connectionState = new ConnectionStateManager({
      initialDelay: 1000,    // Start with 1 second
      maxDelay: 30000,       // Max 30 seconds for WebSocket
      multiplier: 2,
      maxAttempts: 0,        // Unlimited
      jitter: true,
    });
  }

  /**
   * Set the command handler that processes incoming browser commands.
   */
  setCommandHandler(handler: CommandHandler): void {
    this.commandHandler = handler;
  }

  /**
   * Connect to Reverb server for a specific user.
   * Implements graceful error handling with automatic reconnection.
   */
  async connect(userId: number): Promise<void> {
    // Upfront auth check - prevent connecting without valid token
    const token = apiClient.getToken();
    if (!token) {
      console.log('[ReverbClient] Cannot connect without auth token');
      this.connectionState.setDisconnected();
      return;
    }

    if (this.echo && this.userId === userId && this.connectionState.isConnected()) {
      console.log('[ReverbClient] Already connected for user', userId);
      return;
    }

    // Disconnect any existing connection
    await this.disconnect();

    this.userId = userId;

    this.connectionState.setConnecting();

    try {
      console.log('[ReverbClient] Connecting to Reverb server...');

      this.echo = new Echo({
        broadcaster: 'pusher',
        key: CONFIG.REVERB_APP_KEY,
        wsHost: CONFIG.REVERB_HOST,
        wsPort: CONFIG.REVERB_PORT,
        wssPort: CONFIG.REVERB_PORT,
        forceTLS: false,
        encrypted: false,
        disableStats: true,
        enabledTransports: ['ws', 'wss'],
        cluster: 'mt1',
        authEndpoint: `${CONFIG.API_URL}/broadcasting/auth`,
        auth: {
          headers: {
            Authorization: `Bearer ${token}`,
            Accept: 'application/json',
          },
        },
      });

      // Subscribe to private channel
      const channelName = `extension.${userId}`;
      console.log('[ReverbClient] Subscribing to channel:', channelName);

      const channel = this.echo.private(channelName);

      // Handle subscription success
      channel.subscribed(() => {
        console.log('[ReverbClient] Subscribed to channel:', channelName);
        this.connectionState.setConnected();
        this.notifyListeners();
        logActivity({
          type: 'connection',
          action: 'reverb_connected',
          description: 'Connected to Reverb WebSocket server',
          success: true,
        });
      });

      // Handle incoming browser commands
      channel.listen('.browser.command', async (event: {
        commandId: string;
        userId: number;
        type: string;
        payload: Record<string, unknown>;
      }) => {
        console.log('[ReverbClient] Received command:', event);

        logActivity({
          type: 'tool',
          action: event.type,
          description: `Received command: ${event.type}`,
          success: true,
          details: { commandId: event.commandId },
        });

        await this.handleCommand({
          commandId: event.commandId,
          userId: event.userId,
          type: event.type,
          payload: event.payload,
        });
      });

      // Handle subscription error
      channel.error((error: Error) => {
        console.error('[ReverbClient] Channel error:', error);
        this.notifyListeners();
        this.scheduleReconnect(error.message);
      });

      // Handle connection state changes via Pusher instance
      const pusher = (this.echo.connector as { pusher: Pusher }).pusher;

      pusher.connection.bind('connected', () => {
        console.log('[ReverbClient] Pusher connected');
      });

      pusher.connection.bind('disconnected', () => {
        console.log('[ReverbClient] Pusher disconnected');
        this.notifyListeners();
        this.scheduleReconnect('Pusher disconnected');
      });

      pusher.connection.bind('error', (error: Error) => {
        console.error('[ReverbClient] Pusher error:', error);
        logActivity({
          type: 'error',
          action: 'reverb_error',
          description: `WebSocket error: ${error.message || 'Unknown error'}`,
          success: false,
        });
      });

    } catch (error) {
      console.error('[ReverbClient] Failed to connect:', error);
      logActivity({
        type: 'error',
        action: 'reverb_connect_failed',
        description: `Failed to connect to Reverb: ${(error as Error).message}`,
        success: false,
      });
      this.scheduleReconnect((error as Error).message);
    }
  }

  /**
   * Disconnect from Reverb server.
   */
  async disconnect(): Promise<void> {
    // Cancel any pending reconnection
    this.connectionState.clearReconnectTimer();

    // Store userId for channel cleanup, then clear immediately to prevent stale reconnects
    const userIdForCleanup = this.userId;
    this.userId = null;

    if (this.echo) {
      try {
        if (userIdForCleanup) {
          this.echo.leave(`extension.${userIdForCleanup}`);
        }
        this.echo.disconnect();
      } catch (error) {
        console.error('[ReverbClient] Error during disconnect:', error);
      }
      this.echo = null;
    }

    this.connectionState.setDisconnected();
    this.notifyListeners();
  }

  /**
   * Handle an incoming command.
   */
  private async handleCommand(command: BrowserCommand): Promise<void> {
    const startTime = Date.now();

    try {
      let result: { success: boolean; result?: unknown; error?: string };

      if (this.commandHandler) {
        result = await this.commandHandler(command);
      } else {
        result = {
          success: false,
          error: 'No command handler registered',
        };
      }

      // Send response back to server
      await apiClient.sendCommandResponse(
        command.commandId,
        result.success,
        result.result || {},
        result.error
      );

      const durationMs = Date.now() - startTime;

      logActivity({
        type: 'tool',
        action: command.type,
        description: result.success
          ? `Command ${command.type} completed`
          : `Command ${command.type} failed: ${result.error}`,
        success: result.success,
        durationMs,
        details: { commandId: command.commandId },
      });

    } catch (error) {
      const errorMsg = (error as Error).message;
      console.error('[ReverbClient] Command execution error:', error);

      // Report error back to server
      await apiClient.sendCommandResponse(
        command.commandId,
        false,
        {},
        errorMsg
      );

      logActivity({
        type: 'error',
        action: command.type,
        description: `Command error: ${errorMsg}`,
        success: false,
        durationMs: Date.now() - startTime,
        details: { commandId: command.commandId },
      });
    }
  }

  /**
   * Schedule a reconnection attempt with exponential backoff.
   */
  private scheduleReconnect(errorMessage?: string): void {
    if (!this.userId) return;

    // Verify token is still available before scheduling retry
    const token = apiClient.getToken();
    if (!token) {
      console.log('[ReverbClient] No token available, skipping reconnect');
      this.connectionState.setDisconnected();
      return;
    }

    // Handle error and get retry info
    const { shouldRetry, delay } = this.connectionState.handleError(
      ErrorCodes.WEBSOCKET_ERROR,
      errorMessage || 'WebSocket disconnected'
    );

    if (shouldRetry && delay) {
      const attempt = this.connectionState.getInfo().reconnectAttempt;
      console.log(`[ReverbClient] Scheduling reconnect in ${delay}ms (attempt ${attempt})`);

      this.connectionState.scheduleReconnect(async () => {
        if (this.userId) {
          await this.connect(this.userId);
        }
      }, delay);

      logActivity({
        type: 'connection',
        action: 'reverb_reconnect_scheduled',
        description: `Reconnecting in ${Math.round(delay / 1000)}s (attempt ${attempt})`,
        success: true,
      });
    }
  }

  /**
   * Check if connected to Reverb.
   */
  isConnectedToReverb(): boolean {
    return this.connectionState.isConnected();
  }

  /**
   * Get detailed connection state.
   */
  getConnectionState(): ConnectionState {
    return this.connectionState.getState();
  }

  /**
   * Subscribe to connection state changes.
   */
  subscribe(listener: (connected: boolean) => void): () => void {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  /**
   * Notify all listeners of connection state change.
   */
  private notifyListeners(): void {
    const connected = this.connectionState.isConnected();
    this.listeners.forEach(listener => listener(connected));
  }
}

// Singleton instance
export const reverbClient = new ReverbClient();
</file>

<file path="src/background/sw-polyfill.ts">
/**
 * Service Worker Polyfill
 *
 * Provides a `window` shim for libraries (like pusher-js) that expect
 * to run in a browser context. Service workers use `self` instead of `window`.
 *
 * This IIFE runs immediately when the module loads, before any imports.
 */

/* eslint-disable @typescript-eslint/no-explicit-any */

// IIFE to ensure this runs immediately
(function() {
  // Polyfill window for service worker context
  if (typeof window === 'undefined') {
    (globalThis as any).window = self;
  }

  // Polyfill document if needed (some libs check for it)
  if (typeof document === 'undefined') {
    (globalThis as any).document = {
      createElement: () => ({}),
      createEvent: () => ({
        initEvent: () => {},
      }),
      addEventListener: () => {},
      removeEventListener: () => {},
      dispatchEvent: () => true,
      documentElement: { style: {} },
      body: { style: {} },
    };
  }

  // Polyfill localStorage (some libs check for it)
  if (typeof localStorage === 'undefined') {
    const storage: Record<string, string> = {};
    (globalThis as any).localStorage = {
      getItem: (key: string) => storage[key] || null,
      setItem: (key: string, value: string) => { storage[key] = value; },
      removeItem: (key: string) => { delete storage[key]; },
      clear: () => { Object.keys(storage).forEach(k => delete storage[k]); },
    };
  }

  // Polyfill XMLHttpRequest if needed (pusher uses it for auth)
  if (typeof XMLHttpRequest === 'undefined') {
    // Use fetch-based polyfill
    (globalThis as any).XMLHttpRequest = class {
      private _method = 'GET';
      private _url = '';
      private _headers: Record<string, string> = {};
      private _response: any = null;
      public status = 0;
      public responseText = '';
      public readyState = 0;
      public onreadystatechange: (() => void) | null = null;

      open(method: string, url: string) {
        this._method = method;
        this._url = url;
        this.readyState = 1;
      }

      setRequestHeader(name: string, value: string) {
        this._headers[name] = value;
      }

      send(body?: string) {
        fetch(this._url, {
          method: this._method,
          headers: this._headers,
          body: body,
        })
          .then(async (response) => {
            this.status = response.status;
            this.responseText = await response.text();
            this._response = this.responseText;
            this.readyState = 4;
            if (this.onreadystatechange) this.onreadystatechange();
          })
          .catch(() => {
            this.status = 0;
            this.readyState = 4;
            if (this.onreadystatechange) this.onreadystatechange();
          });
      }

      get response() {
        return this._response;
      }
    };
  }
})();

/* eslint-enable @typescript-eslint/no-explicit-any */

export {};
</file>

<file path="tests/unit/background/api-client.test.ts">
/**
 * Unit tests for ApiClient.
 * Tests API communication with Laravel backend.
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

// Mock CONFIG before importing api-client
vi.mock('@/types/config', () => ({
  CONFIG: {
    API_URL: 'https://test.example.com',
    REVERB_HOST: 'localhost',
    REVERB_PORT: 8085,
    REVERB_APP_KEY: 'test-key',
  },
}));

// Mock chrome.runtime for extension version
vi.stubGlobal('chrome', {
  runtime: {
    getManifest: () => ({ version: '1.0.0' }),
  },
});

// Import after mocks are set up
import { ApiClient } from '@/background/api-client';

describe('ApiClient', () => {
  let apiClient: ApiClient;
  let fetchMock: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    apiClient = new ApiClient();
    fetchMock = vi.fn();
    vi.stubGlobal('fetch', fetchMock);
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('setToken / getToken', () => {
    it('stores and retrieves token', () => {
      expect(apiClient.getToken()).toBeNull();

      apiClient.setToken('test-token-123');

      expect(apiClient.getToken()).toBe('test-token-123');
    });

    it('clears token when set to null', () => {
      apiClient.setToken('test-token');
      apiClient.setToken(null);

      expect(apiClient.getToken()).toBeNull();
    });
  });

  describe('login', () => {
    it('returns success with token and user on successful login', async () => {
      const mockUser = { id: 1, name: 'Test User', email: 'test@example.com' };
      const mockToken = 'sanctum-token-xyz';

      fetchMock.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ token: mockToken, user: mockUser }),
      });

      const result = await apiClient.login('test@example.com', 'password123');

      expect(result.success).toBe(true);
      expect(result.token).toBe(mockToken);
      expect(result.user).toEqual(mockUser);
      expect(apiClient.getToken()).toBe(mockToken);

      // Verify request
      expect(fetchMock).toHaveBeenCalledWith(
        'https://test.example.com/api/v1/extension/login',
        expect.objectContaining({
          method: 'POST',
          body: JSON.stringify({ email: 'test@example.com', password: 'password123' }),
        })
      );
    });

    it('returns error on failed login', async () => {
      fetchMock.mockResolvedValueOnce({
        ok: false,
        json: async () => ({ message: 'Invalid credentials' }),
      });

      const result = await apiClient.login('test@example.com', 'wrongpassword');

      expect(result.success).toBe(false);
      expect(result.error).toBe('Invalid credentials');
      expect(apiClient.getToken()).toBeNull();
    });

    it('returns error on network failure', async () => {
      fetchMock.mockRejectedValueOnce(new Error('Network error'));

      const result = await apiClient.login('test@example.com', 'password');

      expect(result.success).toBe(false);
      expect(result.error).toBe('Network error');
    });
  });

  describe('getUser', () => {
    it('returns user data when authenticated', async () => {
      const mockUser = { id: 1, name: 'Test User', email: 'test@example.com' };
      apiClient.setToken('valid-token');

      fetchMock.mockResolvedValueOnce({
        ok: true,
        json: async () => mockUser,
      });

      const result = await apiClient.getUser();

      expect(result.success).toBe(true);
      expect(result.data).toEqual(mockUser);

      // Verify Authorization header
      expect(fetchMock).toHaveBeenCalledWith(
        'https://test.example.com/api/v1/extension/user',
        expect.objectContaining({
          headers: expect.objectContaining({
            Authorization: 'Bearer valid-token',
          }),
        })
      );
    });

    it('returns error when not authenticated', async () => {
      fetchMock.mockResolvedValueOnce({
        ok: false,
        json: async () => ({ message: 'Unauthenticated' }),
      });

      const result = await apiClient.getUser();

      expect(result.success).toBe(false);
      expect(result.error).toBe('Unauthenticated');
    });
  });

  describe('connect', () => {
    it('sends connect request with session ID and metadata', async () => {
      apiClient.setToken('valid-token');

      fetchMock.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ online: true, connected_at: '2024-01-01T00:00:00Z' }),
      });

      const result = await apiClient.connect('session-123');

      expect(result.success).toBe(true);
      expect(fetchMock).toHaveBeenCalledWith(
        'https://test.example.com/api/v1/extension/connect',
        expect.objectContaining({
          method: 'POST',
          body: expect.stringContaining('session-123'),
        })
      );

      // Verify metadata includes browser and version
      const callBody = JSON.parse(fetchMock.mock.calls[0][1].body);
      expect(callBody.metadata.browser).toBe('Chrome');
      expect(callBody.metadata.extension_version).toBe('1.0.0');
    });
  });

  describe('disconnect', () => {
    it('sends disconnect request', async () => {
      apiClient.setToken('valid-token');

      fetchMock.mockResolvedValueOnce({
        ok: true,
        json: async () => ({}),
      });

      const result = await apiClient.disconnect();

      expect(result.success).toBe(true);
      expect(fetchMock).toHaveBeenCalledWith(
        'https://test.example.com/api/v1/extension/disconnect',
        expect.objectContaining({ method: 'POST' })
      );
    });
  });

  describe('heartbeat', () => {
    it('sends heartbeat with session ID', async () => {
      apiClient.setToken('valid-token');

      fetchMock.mockResolvedValueOnce({
        ok: true,
        json: async () => ({ online: true, last_seen: '2024-01-01T00:00:00Z' }),
      });

      const result = await apiClient.heartbeat('session-456');

      expect(result.success).toBe(true);
      expect(fetchMock).toHaveBeenCalledWith(
        'https://test.example.com/api/v1/extension/heartbeat',
        expect.objectContaining({
          method: 'POST',
          body: JSON.stringify({ session_id: 'session-456' }),
        })
      );
    });
  });

  describe('getStatus', () => {
    it('returns connection status', async () => {
      apiClient.setToken('valid-token');

      fetchMock.mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          online: true,
          connected_at: '2024-01-01T00:00:00Z',
          session_id: 'session-789',
        }),
      });

      const result = await apiClient.getStatus();

      expect(result.success).toBe(true);
      expect(result.data?.online).toBe(true);
    });
  });

  describe('sendCommandResponse', () => {
    it('sends successful command response', async () => {
      apiClient.setToken('valid-token');

      fetchMock.mockResolvedValueOnce({
        ok: true,
        json: async () => ({}),
      });

      const result = await apiClient.sendCommandResponse(
        'cmd-123',
        true,
        { clicked: true },
        undefined
      );

      expect(result.success).toBe(true);
      expect(fetchMock).toHaveBeenCalledWith(
        'https://test.example.com/api/v1/extension/response',
        expect.objectContaining({
          method: 'POST',
          body: JSON.stringify({
            command_id: 'cmd-123',
            success: true,
            result: { clicked: true },
            error: undefined,
          }),
        })
      );
    });

    it('sends failed command response with error', async () => {
      apiClient.setToken('valid-token');

      fetchMock.mockResolvedValueOnce({
        ok: true,
        json: async () => ({}),
      });

      const result = await apiClient.sendCommandResponse(
        'cmd-456',
        false,
        {},
        'Element not found'
      );

      expect(result.success).toBe(true);

      const callBody = JSON.parse(fetchMock.mock.calls[0][1].body);
      expect(callBody.success).toBe(false);
      expect(callBody.error).toBe('Element not found');
    });
  });

  describe('request headers', () => {
    it('includes Content-Type and Accept headers', async () => {
      fetchMock.mockResolvedValueOnce({
        ok: true,
        json: async () => ({}),
      });

      await apiClient.getStatus();

      expect(fetchMock).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          headers: expect.objectContaining({
            'Content-Type': 'application/json',
            Accept: 'application/json',
          }),
        })
      );
    });

    it('includes Authorization header when token is set', async () => {
      apiClient.setToken('my-token');

      fetchMock.mockResolvedValueOnce({
        ok: true,
        json: async () => ({}),
      });

      await apiClient.getStatus();

      expect(fetchMock).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          headers: expect.objectContaining({
            Authorization: 'Bearer my-token',
          }),
        })
      );
    });

    it('does not include Authorization header when no token', async () => {
      fetchMock.mockResolvedValueOnce({
        ok: true,
        json: async () => ({}),
      });

      await apiClient.getStatus();

      const headers = fetchMock.mock.calls[0][1].headers;
      expect(headers.Authorization).toBeUndefined();
    });
  });
});
</file>

<file path="tests/unit/background/auth-service.test.ts">
/**
 * Unit tests for AuthService.
 * Tests authentication state management, session persistence, and heartbeat.
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

// Mock dependencies before importing auth-service
vi.mock('@/types/config', () => ({
  CONFIG: {
    API_URL: 'https://test.example.com',
    REVERB_HOST: 'localhost',
    REVERB_PORT: 8085,
    REVERB_APP_KEY: 'test-key',
  },
}));

// Mock apiClient
const mockApiClient = {
  setToken: vi.fn(),
  getToken: vi.fn(),
  login: vi.fn(),
  getUser: vi.fn(),
  connect: vi.fn(),
  disconnect: vi.fn(),
  heartbeat: vi.fn(),
};

vi.mock('@/background/api-client', () => ({
  apiClient: mockApiClient,
}));

// Mock reverbClient
const mockReverbClient = {
  connect: vi.fn(),
  disconnect: vi.fn(),
};

vi.mock('@/background/reverb-client', () => ({
  reverbClient: mockReverbClient,
}));

// Mock activity-log
vi.mock('@/background/activity-log', () => ({
  logActivity: vi.fn(),
}));

// Mock chrome.storage.local
const mockStorage: Record<string, unknown> = {};
vi.stubGlobal('chrome', {
  storage: {
    local: {
      get: vi.fn(async (keys: string[]) => {
        const result: Record<string, unknown> = {};
        keys.forEach(key => {
          if (mockStorage[key] !== undefined) {
            result[key] = mockStorage[key];
          }
        });
        return result;
      }),
      set: vi.fn(async (items: Record<string, unknown>) => {
        Object.assign(mockStorage, items);
      }),
      remove: vi.fn(async (keys: string[]) => {
        keys.forEach(key => delete mockStorage[key]);
      }),
    },
  },
  runtime: {
    getManifest: () => ({ version: '1.0.0' }),
  },
});

// Import after mocks
// Note: We need to create a fresh instance for each test since authService is a singleton
// We'll test the class behavior through the exported singleton

describe('AuthService', () => {
  beforeEach(() => {
    // Clear mocks and storage
    vi.clearAllMocks();
    Object.keys(mockStorage).forEach(key => delete mockStorage[key]);

    // Reset default mock implementations
    mockApiClient.login.mockReset();
    mockApiClient.getUser.mockReset();
    mockApiClient.connect.mockReset();
    mockApiClient.disconnect.mockReset();
    mockApiClient.heartbeat.mockReset();
    mockReverbClient.connect.mockReset();
    mockReverbClient.disconnect.mockReset();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('initialize', () => {
    it('restores session from storage when token exists and is valid', async () => {
      // Pre-populate storage
      mockStorage['auth_token'] = 'stored-token';
      mockStorage['auth_user'] = { id: 1, name: 'Test', email: 'test@example.com' };
      mockStorage['session_id'] = 'stored-session';

      // Mock successful user verification
      mockApiClient.getUser.mockResolvedValueOnce({
        success: true,
        data: { id: 1, name: 'Test', email: 'test@example.com' },
      });

      mockApiClient.connect.mockResolvedValueOnce({ success: true });

      // Import fresh module to test initialization
      vi.resetModules();
      const { authService } = await import('@/background/auth-service');

      await authService.initialize();

      expect(mockApiClient.setToken).toHaveBeenCalledWith('stored-token');
      expect(mockApiClient.getUser).toHaveBeenCalled();
      expect(mockApiClient.connect).toHaveBeenCalled();
    });

    it('clears session when stored token is invalid', async () => {
      mockStorage['auth_token'] = 'invalid-token';
      mockStorage['auth_user'] = { id: 1, name: 'Test', email: 'test@example.com' };

      mockApiClient.getUser.mockResolvedValueOnce({
        success: false,
        error: 'Unauthenticated',
      });

      vi.resetModules();
      const { authService } = await import('@/background/auth-service');

      await authService.initialize();

      // Should clear storage
      expect(chrome.storage.local.remove).toHaveBeenCalled();
      expect(mockApiClient.setToken).toHaveBeenCalledWith(null);
    });

    it('does nothing when no token in storage', async () => {
      vi.resetModules();
      const { authService } = await import('@/background/auth-service');

      await authService.initialize();

      expect(mockApiClient.getUser).not.toHaveBeenCalled();
    });
  });

  describe('login', () => {
    it('stores token and user on successful login', async () => {
      const mockUser = { id: 1, name: 'Test User', email: 'test@example.com' };
      const mockToken = 'new-token';

      mockApiClient.login.mockResolvedValueOnce({
        success: true,
        token: mockToken,
        user: mockUser,
      });

      mockApiClient.connect.mockResolvedValueOnce({ success: true });

      vi.resetModules();
      const { authService } = await import('@/background/auth-service');

      const result = await authService.login('test@example.com', 'password');

      expect(result.success).toBe(true);
      expect(chrome.storage.local.set).toHaveBeenCalledWith(
        expect.objectContaining({
          auth_token: mockToken,
          auth_user: mockUser,
        })
      );
    });

    it('connects to server after successful login', async () => {
      mockApiClient.login.mockResolvedValueOnce({
        success: true,
        token: 'token',
        user: { id: 1, name: 'Test', email: 'test@example.com' },
      });

      mockApiClient.connect.mockResolvedValueOnce({ success: true });

      vi.resetModules();
      const { authService } = await import('@/background/auth-service');

      await authService.login('test@example.com', 'password');

      expect(mockApiClient.connect).toHaveBeenCalled();
      expect(mockReverbClient.connect).toHaveBeenCalledWith(1); // user.id
    });

    it('returns error on failed login', async () => {
      mockApiClient.login.mockResolvedValueOnce({
        success: false,
        error: 'Invalid credentials',
      });

      vi.resetModules();
      const { authService } = await import('@/background/auth-service');

      const result = await authService.login('test@example.com', 'wrong');

      expect(result.success).toBe(false);
      expect(result.error).toBe('Invalid credentials');
      expect(chrome.storage.local.set).not.toHaveBeenCalled();
    });
  });

  describe('logout', () => {
    it('disconnects and clears session', async () => {
      mockApiClient.disconnect.mockResolvedValueOnce({ success: true });

      vi.resetModules();
      const { authService } = await import('@/background/auth-service');

      // Set up authenticated state first
      mockApiClient.login.mockResolvedValueOnce({
        success: true,
        token: 'token',
        user: { id: 1, name: 'Test', email: 'test@example.com' },
      });
      mockApiClient.connect.mockResolvedValueOnce({ success: true });
      await authService.login('test@example.com', 'password');

      vi.clearAllMocks();

      await authService.logout();

      expect(mockReverbClient.disconnect).toHaveBeenCalled();
      expect(mockApiClient.setToken).toHaveBeenCalledWith(null);
      expect(chrome.storage.local.remove).toHaveBeenCalledWith([
        'auth_token',
        'auth_user',
        'session_id',
      ]);
    });
  });

  describe('getState', () => {
    it('returns unauthenticated state when not logged in', async () => {
      vi.resetModules();
      const { authService } = await import('@/background/auth-service');

      const state = authService.getState();

      expect(state.isAuthenticated).toBe(false);
      expect(state.user).toBeNull();
      expect(state.isConnected).toBe(false);
    });

    it('returns authenticated state after login', async () => {
      const mockUser = { id: 1, name: 'Test', email: 'test@example.com' };

      mockApiClient.login.mockResolvedValueOnce({
        success: true,
        token: 'token',
        user: mockUser,
      });
      mockApiClient.connect.mockResolvedValueOnce({ success: true });

      vi.resetModules();
      const { authService } = await import('@/background/auth-service');

      await authService.login('test@example.com', 'password');

      const state = authService.getState();

      expect(state.isAuthenticated).toBe(true);
      expect(state.user).toEqual(mockUser);
      expect(state.isConnected).toBe(true);
    });
  });

  describe('subscribe', () => {
    it('notifies listeners on state change', async () => {
      vi.resetModules();
      const { authService } = await import('@/background/auth-service');

      const listener = vi.fn();
      authService.subscribe(listener);

      mockApiClient.login.mockResolvedValueOnce({
        success: true,
        token: 'token',
        user: { id: 1, name: 'Test', email: 'test@example.com' },
      });
      mockApiClient.connect.mockResolvedValueOnce({ success: true });

      await authService.login('test@example.com', 'password');

      expect(listener).toHaveBeenCalled();
      const lastCall = listener.mock.calls[listener.mock.calls.length - 1][0];
      expect(lastCall.isAuthenticated).toBe(true);
    });

    it('returns unsubscribe function', async () => {
      vi.resetModules();
      const { authService } = await import('@/background/auth-service');

      const listener = vi.fn();
      const unsubscribe = authService.subscribe(listener);

      unsubscribe();

      mockApiClient.login.mockResolvedValueOnce({
        success: true,
        token: 'token',
        user: { id: 1, name: 'Test', email: 'test@example.com' },
      });
      mockApiClient.connect.mockResolvedValueOnce({ success: true });

      await authService.login('test@example.com', 'password');

      // Listener should not be called after unsubscribe
      // Note: It may have been called during login, but we check it wasn't called
      // after the login state change
      const callCount = listener.mock.calls.length;

      // Trigger another state change
      await authService.logout();

      // Should not have additional calls after unsubscribe
      expect(listener.mock.calls.length).toBe(callCount);
    });
  });

  describe('isAuthenticated', () => {
    it('returns false when not logged in', async () => {
      vi.resetModules();
      const { authService } = await import('@/background/auth-service');

      expect(authService.isAuthenticated()).toBe(false);
    });

    it('returns true when logged in', async () => {
      mockApiClient.login.mockResolvedValueOnce({
        success: true,
        token: 'token',
        user: { id: 1, name: 'Test', email: 'test@example.com' },
      });
      mockApiClient.connect.mockResolvedValueOnce({ success: true });

      vi.resetModules();
      const { authService } = await import('@/background/auth-service');

      await authService.login('test@example.com', 'password');

      expect(authService.isAuthenticated()).toBe(true);
    });
  });

  describe('getUser', () => {
    it('returns null when not logged in', async () => {
      vi.resetModules();
      const { authService } = await import('@/background/auth-service');

      expect(authService.getUser()).toBeNull();
    });

    it('returns user when logged in', async () => {
      const mockUser = { id: 1, name: 'Test', email: 'test@example.com' };

      mockApiClient.login.mockResolvedValueOnce({
        success: true,
        token: 'token',
        user: mockUser,
      });
      mockApiClient.connect.mockResolvedValueOnce({ success: true });

      vi.resetModules();
      const { authService } = await import('@/background/auth-service');

      await authService.login('test@example.com', 'password');

      expect(authService.getUser()).toEqual(mockUser);
    });
  });

  describe('session ID generation', () => {
    it('generates unique session IDs', async () => {
      mockApiClient.login.mockResolvedValue({
        success: true,
        token: 'token',
        user: { id: 1, name: 'Test', email: 'test@example.com' },
      });
      mockApiClient.connect.mockResolvedValue({ success: true });

      vi.resetModules();
      const { authService } = await import('@/background/auth-service');

      await authService.login('test@example.com', 'password');

      const sessionId1 = authService.getSessionId();

      // Logout and login again
      await authService.logout();
      await authService.login('test@example.com', 'password');

      const sessionId2 = authService.getSessionId();

      expect(sessionId1).not.toBe(sessionId2);
      expect(sessionId1).toMatch(/^ext_\d+_[a-z0-9]+$/);
      expect(sessionId2).toMatch(/^ext_\d+_[a-z0-9]+$/);
    });
  });
});
</file>

<file path="tests/unit/background/reverb-client.test.ts">
/**
 * Unit tests for ReverbClient.
 * Tests Laravel Echo WebSocket connection and command handling.
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

// Mock CONFIG
vi.mock('@/types/config', () => ({
  CONFIG: {
    API_URL: 'https://test.example.com',
    REVERB_HOST: 'localhost',
    REVERB_PORT: 8085,
    REVERB_APP_KEY: 'test-key',
  },
}));

// Mock apiClient
const mockApiClient = {
  getToken: vi.fn(() => 'mock-token'),
  sendCommandResponse: vi.fn(),
};

vi.mock('@/background/api-client', () => ({
  apiClient: mockApiClient,
}));

// Mock activity-log
vi.mock('@/background/activity-log', () => ({
  logActivity: vi.fn(),
}));

// Mock Echo channel
const mockChannel = {
  subscribed: vi.fn(),
  listen: vi.fn(),
  error: vi.fn(),
};

// Mock Echo instance
const mockEcho = {
  private: vi.fn(() => mockChannel),
  leave: vi.fn(),
  disconnect: vi.fn(),
  connector: {
    pusher: {
      connection: {
        bind: vi.fn(),
      },
    },
  },
};

// Mock Echo constructor
vi.mock('laravel-echo', () => ({
  default: vi.fn(() => mockEcho),
}));

// Mock Pusher
vi.mock('pusher-js', () => ({
  default: vi.fn(),
}));

describe('ReverbClient', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockApiClient.getToken.mockReturnValue('mock-token');
    mockApiClient.sendCommandResponse.mockResolvedValue({ success: true });
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('setCommandHandler', () => {
    it('stores the command handler', async () => {
      vi.resetModules();
      const { reverbClient } = await import('@/background/reverb-client');

      const handler = vi.fn();
      reverbClient.setCommandHandler(handler);

      // Handler is stored internally - we'll test it's called in handleCommand tests
      expect(handler).not.toHaveBeenCalled();
    });
  });

  describe('connect', () => {
    it('creates Echo instance with correct configuration', async () => {
      vi.resetModules();
      const Echo = (await import('laravel-echo')).default;
      const { reverbClient } = await import('@/background/reverb-client');

      await reverbClient.connect(123);

      expect(Echo).toHaveBeenCalledWith(
        expect.objectContaining({
          broadcaster: 'pusher',
          key: 'test-key',
          wsHost: 'localhost',
          wsPort: 8085,
          authEndpoint: 'https://test.example.com/broadcasting/auth',
          auth: expect.objectContaining({
            headers: expect.objectContaining({
              Authorization: 'Bearer mock-token',
            }),
          }),
        })
      );
    });

    it('subscribes to private channel for user', async () => {
      vi.resetModules();
      const { reverbClient } = await import('@/background/reverb-client');

      await reverbClient.connect(456);

      expect(mockEcho.private).toHaveBeenCalledWith('extension.456');
    });

    it('sets up event listeners on channel', async () => {
      vi.resetModules();
      const { reverbClient } = await import('@/background/reverb-client');

      await reverbClient.connect(789);

      expect(mockChannel.subscribed).toHaveBeenCalled();
      expect(mockChannel.listen).toHaveBeenCalledWith('.browser.command', expect.any(Function));
      expect(mockChannel.error).toHaveBeenCalled();
    });

    it('does not connect without token', async () => {
      mockApiClient.getToken.mockReturnValue(null);

      vi.resetModules();
      const Echo = (await import('laravel-echo')).default;
      const { reverbClient } = await import('@/background/reverb-client');

      await reverbClient.connect(123);

      expect(Echo).not.toHaveBeenCalled();
    });

    it('disconnects existing connection before reconnecting', async () => {
      vi.resetModules();
      const { reverbClient } = await import('@/background/reverb-client');

      await reverbClient.connect(123);
      vi.clearAllMocks();

      await reverbClient.connect(456);

      expect(mockEcho.leave).toHaveBeenCalledWith('extension.123');
      expect(mockEcho.disconnect).toHaveBeenCalled();
    });

    it('reuses existing connection for same user', async () => {
      vi.resetModules();
      const Echo = (await import('laravel-echo')).default;
      const { reverbClient } = await import('@/background/reverb-client');

      await reverbClient.connect(123);
      const firstCallCount = (Echo as ReturnType<typeof vi.fn>).mock.calls.length;

      await reverbClient.connect(123);

      // Should not create new Echo instance
      expect((Echo as ReturnType<typeof vi.fn>).mock.calls.length).toBe(firstCallCount);
    });
  });

  describe('disconnect', () => {
    it('leaves channel and disconnects Echo', async () => {
      vi.resetModules();
      const { reverbClient } = await import('@/background/reverb-client');

      await reverbClient.connect(123);
      await reverbClient.disconnect();

      expect(mockEcho.leave).toHaveBeenCalledWith('extension.123');
      expect(mockEcho.disconnect).toHaveBeenCalled();
    });

    it('does nothing if not connected', async () => {
      vi.resetModules();
      const { reverbClient } = await import('@/background/reverb-client');

      await reverbClient.disconnect();

      expect(mockEcho.leave).not.toHaveBeenCalled();
      expect(mockEcho.disconnect).not.toHaveBeenCalled();
    });
  });

  describe('command handling', () => {
    it('executes command handler when command received', async () => {
      vi.resetModules();
      const { reverbClient } = await import('@/background/reverb-client');

      const handler = vi.fn().mockResolvedValue({
        success: true,
        result: { clicked: true },
      });
      reverbClient.setCommandHandler(handler);

      await reverbClient.connect(123);

      // Get the listener callback
      const listenCallback = mockChannel.listen.mock.calls[0][1];

      // Simulate receiving a command
      await listenCallback({
        commandId: 'cmd-123',
        userId: 123,
        type: 'browser_click',
        payload: { ref: 's1e42' },
      });

      expect(handler).toHaveBeenCalledWith({
        commandId: 'cmd-123',
        userId: 123,
        type: 'browser_click',
        payload: { ref: 's1e42' },
      });
    });

    it('sends response back to server after command execution', async () => {
      vi.resetModules();
      const { reverbClient } = await import('@/background/reverb-client');

      const handler = vi.fn().mockResolvedValue({
        success: true,
        result: { navigated: 'https://example.com' },
      });
      reverbClient.setCommandHandler(handler);

      await reverbClient.connect(123);

      const listenCallback = mockChannel.listen.mock.calls[0][1];
      await listenCallback({
        commandId: 'cmd-456',
        userId: 123,
        type: 'browser_navigate',
        payload: { url: 'https://example.com' },
      });

      expect(mockApiClient.sendCommandResponse).toHaveBeenCalledWith(
        'cmd-456',
        true,
        { navigated: 'https://example.com' },
        undefined
      );
    });

    it('sends error response when command fails', async () => {
      vi.resetModules();
      const { reverbClient } = await import('@/background/reverb-client');

      const handler = vi.fn().mockResolvedValue({
        success: false,
        error: 'Element not found',
      });
      reverbClient.setCommandHandler(handler);

      await reverbClient.connect(123);

      const listenCallback = mockChannel.listen.mock.calls[0][1];
      await listenCallback({
        commandId: 'cmd-789',
        userId: 123,
        type: 'browser_click',
        payload: { ref: 's1e99' },
      });

      expect(mockApiClient.sendCommandResponse).toHaveBeenCalledWith(
        'cmd-789',
        false,
        {},
        'Element not found'
      );
    });

    it('handles exception in command handler', async () => {
      vi.resetModules();
      const { reverbClient } = await import('@/background/reverb-client');

      const handler = vi.fn().mockRejectedValue(new Error('Unexpected error'));
      reverbClient.setCommandHandler(handler);

      await reverbClient.connect(123);

      const listenCallback = mockChannel.listen.mock.calls[0][1];
      await listenCallback({
        commandId: 'cmd-error',
        userId: 123,
        type: 'browser_click',
        payload: {},
      });

      expect(mockApiClient.sendCommandResponse).toHaveBeenCalledWith(
        'cmd-error',
        false,
        {},
        'Unexpected error'
      );
    });

    it('handles missing command handler', async () => {
      vi.resetModules();
      const { reverbClient } = await import('@/background/reverb-client');

      // Don't set command handler

      await reverbClient.connect(123);

      const listenCallback = mockChannel.listen.mock.calls[0][1];
      await listenCallback({
        commandId: 'cmd-no-handler',
        userId: 123,
        type: 'browser_click',
        payload: {},
      });

      expect(mockApiClient.sendCommandResponse).toHaveBeenCalledWith(
        'cmd-no-handler',
        false,
        {},
        'No command handler registered'
      );
    });
  });

  describe('isConnectedToReverb', () => {
    it('returns false initially', async () => {
      vi.resetModules();
      const { reverbClient } = await import('@/background/reverb-client');

      expect(reverbClient.isConnectedToReverb()).toBe(false);
    });

    it('returns true after successful subscription', async () => {
      vi.resetModules();
      const { reverbClient } = await import('@/background/reverb-client');

      await reverbClient.connect(123);

      // Simulate subscription success
      const subscribedCallback = mockChannel.subscribed.mock.calls[0][0];
      subscribedCallback();

      expect(reverbClient.isConnectedToReverb()).toBe(true);
    });

    it('returns false after disconnect', async () => {
      vi.resetModules();
      const { reverbClient } = await import('@/background/reverb-client');

      await reverbClient.connect(123);

      const subscribedCallback = mockChannel.subscribed.mock.calls[0][0];
      subscribedCallback();

      await reverbClient.disconnect();

      expect(reverbClient.isConnectedToReverb()).toBe(false);
    });
  });

  describe('subscribe', () => {
    it('notifies listeners on connection state change', async () => {
      vi.resetModules();
      const { reverbClient } = await import('@/background/reverb-client');

      const listener = vi.fn();
      reverbClient.subscribe(listener);

      await reverbClient.connect(123);

      // Simulate subscription success
      const subscribedCallback = mockChannel.subscribed.mock.calls[0][0];
      subscribedCallback();

      expect(listener).toHaveBeenCalledWith(true);
    });

    it('returns unsubscribe function', async () => {
      vi.resetModules();
      const { reverbClient } = await import('@/background/reverb-client');

      const listener = vi.fn();
      const unsubscribe = reverbClient.subscribe(listener);

      unsubscribe();

      await reverbClient.connect(123);

      const subscribedCallback = mockChannel.subscribed.mock.calls[0][0];
      subscribedCallback();

      // Listener should not be called after unsubscribe
      expect(listener).not.toHaveBeenCalled();
    });
  });
});
</file>

<file path="icons/agent-jake-logo.svg">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" style="display: block;" viewBox="0 0 2048 2048" width="1024" height="1024" preserveAspectRatio="none">
<defs>
	<linearGradient id="Gradient1" gradientUnits="userSpaceOnUse" x1="1071.2" y1="561.899" x2="1073.24" y2="573.579">
		<stop class="stop0" offset="0" stop-opacity="1" stop-color="rgb(228,158,111)"/>
		<stop class="stop1" offset="1" stop-opacity="1" stop-color="rgb(204,131,89)"/>
	</linearGradient>
	<linearGradient id="Gradient2" gradientUnits="userSpaceOnUse" x1="405.29" y1="1062.97" x2="979.866" y2="948.675">
		<stop class="stop0" offset="0" stop-opacity="1" stop-color="rgb(21,32,41)"/>
		<stop class="stop1" offset="1" stop-opacity="1" stop-color="rgb(45,59,74)"/>
	</linearGradient>
	<linearGradient id="Gradient3" gradientUnits="userSpaceOnUse" x1="1488.27" y1="447.839" x2="1496.11" y2="426.563">
		<stop class="stop0" offset="0" stop-opacity="1" stop-color="rgb(36,43,45)"/>
		<stop class="stop1" offset="1" stop-opacity="1" stop-color="rgb(75,74,72)"/>
	</linearGradient>
	<linearGradient id="Gradient4" gradientUnits="userSpaceOnUse" x1="1656.13" y1="608.447" x2="1409.49" y2="460.528">
		<stop class="stop0" offset="0" stop-opacity="1" stop-color="rgb(47,58,67)"/>
		<stop class="stop1" offset="1" stop-opacity="1" stop-color="rgb(64,82,96)"/>
	</linearGradient>
</defs>
<path transform="translate(0,0)" fill="rgb(14,22,29)" d="M 748.612 178.428 C 776.353 100.11 857.57 61.1936 937.124 59.8714 C 978.28 59.2786 1021.24 70.5014 1059.46 85.1377 C 1086.43 96.6388 1105.98 85.9866 1126.69 67.7416 C 1163.26 35.5191 1189.21 84.7029 1192.1 117.204 C 1194.79 147.519 1185.75 166.968 1166.53 190.334 C 1176.28 215.106 1185.7 260.264 1191.59 286.969 C 1224.14 268.187 1239.26 294.904 1236.29 324.965 C 1232.58 362.354 1225.81 396.289 1196.71 422.203 C 1213.04 480.964 1206.95 523.187 1189.77 580.325 C 1224.63 592.1 1252 635.148 1272.75 664.488 L 1330.52 746.994 C 1342.12 763.611 1354.65 782.437 1367.19 798.088 C 1371.83 793.318 1377.66 788.588 1382.7 783.629 C 1375.83 751.593 1363.96 722.144 1359.4 688.889 C 1354.75 655.002 1369.85 620.246 1406.43 615.3 C 1399.2 580.292 1396.03 540.071 1393.88 504.51 C 1392.72 485.294 1384.61 433.128 1411.58 428.503 C 1422.6 426.613 1436.39 423.652 1447.63 422.045 C 1459.24 420.383 1483.65 411.651 1494.39 412.323 C 1502.75 408.197 1533.69 403.381 1537.03 398.304 C 1531.62 396.754 1517.09 394.341 1513.66 392.415 C 1520.46 385.223 1537.53 396.628 1551.42 384.926 C 1568.52 370.51 1576.17 333.084 1579.29 312.252 C 1582.52 321.379 1585.8 334.091 1588.73 343.784 C 1593.56 356.646 1598.4 375.618 1611.46 382.02 C 1621.2 386.797 1634.32 388.07 1645.05 386.685 C 1643.53 390.092 1644.64 388.728 1641.5 390.868 C 1638.14 390.879 1637.07 390.255 1633.98 389.1 C 1631.92 391.601 1634.97 390.708 1633.73 392.665 C 1631.47 396.237 1629.91 393.973 1625.17 396.121 C 1626.97 400.719 1628.95 394.843 1627.66 400.215 C 1625.81 401.64 1622.51 403.38 1622.49 405.933 C 1620.67 410.751 1619.91 413.235 1618.73 418.246 C 1623.1 421.074 1627.23 423.777 1631.75 426.374 C 1636.35 427.942 1639.34 429.426 1644.15 429.026 C 1644.49 424.568 1644.03 421.893 1643.53 417.472 L 1645.77 415.285 C 1650.76 416.995 1651.03 419.016 1655.12 420.38 L 1656.33 420.983 C 1666.57 426.101 1669.72 431.913 1670.46 442.979 C 1672.37 460.808 1672.2 479.286 1672.69 497.249 C 1673.58 530.03 1674.32 562.751 1673.76 595.55 C 1673.57 607.042 1672.06 618.486 1671.78 629.771 C 1684.15 629.732 1697.33 631.134 1706.09 640.618 C 1730.25 666.769 1715.27 697.036 1696.67 718.427 C 1715.42 746.176 1716.95 759.789 1695.87 787.192 C 1700.82 829.738 1683.65 849.519 1643.44 858.634 C 1642.13 860.866 1639.18 865.899 1637.27 867.477 C 1616.29 884.76 1582.81 894.552 1558.63 905.124 C 1556.2 933.207 1541.08 962.24 1519.2 979.457 C 1482.41 1008.41 1406.81 1048.73 1360.42 1043.96 C 1311.26 1038.91 1238.93 959.702 1212.96 920.599 C 1208.41 941.236 1197.11 974.445 1189.87 994.827 C 1178.54 1026.73 1163.92 1069.59 1147.95 1099.03 C 1151.8 1137.57 1159.84 1205.58 1157.69 1242.34 C 1156.84 1256.69 1067.27 1343.66 1053.31 1361.45 C 1094.17 1447.94 1133.1 1538.5 1171.69 1626.12 C 1182.08 1649.61 1192.36 1673.15 1202.52 1696.75 C 1208.77 1711.18 1216.51 1730.12 1223.76 1743.64 C 1235.28 1744.15 1246 1744.67 1257.28 1742.16 C 1278.8 1737.38 1298.78 1724.48 1320.81 1722.04 C 1395.62 1713.77 1426.29 1785.59 1365.83 1832.94 C 1331.69 1859.68 1295.52 1877.41 1255.35 1893.42 C 1251.09 1895.09 1245.58 1896.83 1241.7 1899.02 C 1270.48 1906.21 1371.25 1943.13 1333.49 1984.85 C 1314.32 2006.04 1254.77 2013.74 1226.74 2014.2 C 1174.46 2015.07 1121.31 2009.06 1071.15 1994.05 C 1035.3 1983.32 1001.37 1968.42 967.013 1954.05 C 912.942 1931.39 859.132 1908.11 805.594 1884.22 C 704.288 1839.39 601.901 1794.99 503.13 1744.72 C 476.941 1731.39 405.423 1688.49 441.512 1653.76 C 464.409 1631.72 521.672 1630.67 551.959 1631.55 C 543.586 1600.36 541.957 1583.07 541.985 1551.13 C 521.777 1536.53 511.716 1514.78 508.278 1490.69 C 499.599 1429.87 564.057 1384.5 618.898 1408.32 C 657.259 1386.82 710.967 1366.79 754.453 1359.49 C 743.587 1342.76 733.83 1323.77 724.664 1306.09 C 697.015 1290.15 669.019 1260.58 657.602 1230.67 C 660.48 1214.26 666.401 1195.09 670.424 1178.72 C 679.973 1139.86 692.662 1100.1 701.825 1061.28 C 692.215 1034.57 683.08 1007.69 674.424 980.647 C 670.833 969.222 666.1 955.3 663.771 943.758 C 648.149 950.173 630.593 955.085 614.624 961.37 C 594.765 969.185 576.685 977.663 557.608 987.222 C 555.013 994.13 552.172 1001.32 549.26 1008.14 C 529.562 1054.29 515.855 1102.94 496.055 1148.92 C 493.806 1154.15 485.318 1161.96 481.041 1166.04 C 516.667 1230.44 538.916 1313.55 443.172 1332.3 C 434.021 1353.58 417.477 1369.43 392.487 1367.32 C 373.398 1365.71 360.793 1354.82 348.871 1340.85 C 320.08 1336.06 301.106 1319.26 292.04 1291.3 C 274.914 1284.7 261.486 1276.34 258.673 1256.56 C 251.125 1203.48 283.427 1163.41 311.408 1123.34 C 307.696 1116.8 303.039 1109.64 302.404 1101.99 C 301.106 1086.37 330.268 1013.81 337.203 995.122 C 363.246 924.936 389.166 856.109 447.737 806.191 C 468.198 788.753 491.531 775.214 512.088 758.064 C 525.762 746.656 538.912 734.664 552.757 723.446 C 585.717 696.567 621.003 672.672 658.197 652.045 C 696.975 630.662 737.801 612.229 775.415 588.753 C 790.599 579.275 795.215 563.515 806.586 549.294 C 738.097 525.73 693.881 448.543 750.576 389.694 C 711.56 347.046 690.123 269.177 713.847 214.13 C 720.379 198.974 732.798 184.154 748.612 178.428 z M 985.768 1742.97 C 980.009 1732.66 974.175 1719.6 968.778 1708.8 C 958.213 1687.62 947.254 1666.64 935.907 1645.86 C 921.738 1620.09 907.249 1594.5 892.444 1569.09 C 883.989 1554.71 874.421 1539.98 866.518 1525.45 C 819.827 1547.39 735.278 1572.79 685.215 1581.32 C 694.994 1599.72 721.383 1632.43 735.338 1648.11 C 766.625 1658.85 797.003 1671.31 827.905 1682.87 C 880.49 1702.54 933.155 1723.55 985.768 1742.97 z"/>
<path transform="translate(0,0)" fill="rgb(186,188,190)" d="M 1241.7 1899.02 C 1270.48 1906.21 1371.25 1943.13 1333.49 1984.85 C 1314.32 2006.04 1254.77 2013.74 1226.74 2014.2 C 1174.46 2015.07 1121.31 2009.06 1071.15 1994.05 C 1035.3 1983.32 1001.37 1968.42 967.013 1954.05 C 912.942 1931.39 859.132 1908.11 805.594 1884.22 C 704.288 1839.39 601.901 1794.99 503.13 1744.72 C 476.941 1731.39 405.423 1688.49 441.512 1653.76 C 464.409 1631.72 521.672 1630.67 551.959 1631.55 C 562.087 1666.52 589.049 1691.69 620.441 1708.83 C 646.107 1722.85 673.597 1733.3 703.186 1724.74 C 728.845 1717.32 753.066 1695.4 743.628 1666 C 741.747 1660.14 738.136 1653.76 735.338 1648.11 C 766.625 1658.85 797.003 1671.31 827.905 1682.87 C 880.49 1702.54 933.155 1723.55 985.768 1742.97 C 1000.33 1777.3 1017.37 1815.02 1034.57 1848.21 C 1039.63 1857.98 1056.3 1852.39 1064.59 1849.81 L 1092.35 1922.55 C 1106.02 1958.61 1105.28 1982.6 1152.4 1963.12 C 1177.98 1952.55 1207.75 1937.71 1226.08 1916.31 C 1231.76 1909.4 1235.93 1898.85 1241.7 1899.02 z"/>
<path transform="translate(0,0)" fill="url(#Gradient4)" d="M 1537.03 398.304 C 1531.62 396.754 1517.09 394.341 1513.66 392.415 C 1520.46 385.223 1537.53 396.628 1551.42 384.926 C 1568.52 370.51 1576.17 333.084 1579.29 312.252 C 1582.52 321.379 1585.8 334.091 1588.73 343.784 C 1593.56 356.646 1598.4 375.618 1611.46 382.02 C 1621.2 386.797 1634.32 388.07 1645.05 386.685 C 1643.53 390.092 1644.64 388.728 1641.5 390.868 C 1638.14 390.879 1637.07 390.255 1633.98 389.1 C 1631.92 391.601 1634.97 390.708 1633.73 392.665 C 1631.47 396.237 1629.91 393.973 1625.17 396.121 C 1626.97 400.719 1628.95 394.843 1627.66 400.215 C 1625.81 401.64 1622.51 403.38 1622.49 405.933 C 1620.67 410.751 1619.91 413.235 1618.73 418.246 C 1623.1 421.074 1627.23 423.777 1631.75 426.374 C 1636.35 427.942 1639.34 429.426 1644.15 429.026 C 1647.78 428.133 1646.08 427.939 1649.43 429.684 C 1645.69 431.24 1643.63 432.149 1639.74 433.155 C 1639.74 434.842 1639.76 435.612 1640.16 437.282 C 1636.76 444.239 1625.64 449.332 1618.8 453.642 C 1627.44 452.872 1632.8 449.767 1640.88 448.837 C 1641.21 448.799 1643.62 449.068 1645.04 448.885 C 1646.92 504.845 1655.28 566.205 1648.62 622.356 C 1647.89 628.496 1639.23 641.702 1633.15 644.416 C 1626.34 654.771 1619.97 662.849 1613.74 673.777 C 1609.77 680.752 1605.8 692.968 1602.63 697.946 C 1588.64 713.933 1575.35 726.711 1553.63 730.087 C 1506.28 737.447 1465.84 711.975 1458.29 663.867 C 1456.68 654.131 1456.77 646.773 1457.2 637.006 L 1456.14 636.597 C 1454.3 637.654 1454.41 637.585 1453.25 639.225 C 1447.82 633.064 1428.86 620.677 1427.61 614.395 C 1417.32 562.689 1414.44 503.118 1412.89 450.896 C 1436.37 450.44 1460.47 451.078 1484.26 450.711 C 1488.2 448.306 1503.1 451.078 1507.24 448.814 L 1506.46 447.377 C 1511.96 446.991 1517.46 447.903 1522.96 448.545 C 1519.1 446.096 1516.16 445.022 1514.84 441.07 L 1516.07 439.111 C 1525.97 434.974 1529.66 438.33 1537.23 436.332 L 1540.9 436.977 L 1540.19 433.714 C 1538.13 432.506 1537.25 433.454 1534.7 431.285 L 1534.87 428.811 C 1542.25 427.757 1546.57 427.212 1553.39 424.093 C 1551.3 421.07 1552.09 420.947 1552.68 416.163 C 1556.13 413.257 1556.84 412.495 1559.57 408.891 C 1553.26 403.951 1545.24 398.445 1537.03 398.304 z"/>
<path transform="translate(0,0)" fill="rgb(251,196,116)" d="M 1536.45 523.08 C 1571.86 516.063 1653.14 508.663 1607.96 569.379 C 1629.7 590.252 1638.07 614.157 1633.15 644.416 C 1626.34 654.771 1619.97 662.849 1613.74 673.777 C 1609.77 680.752 1605.8 692.968 1602.63 697.946 C 1588.64 713.933 1575.35 726.711 1553.63 730.087 C 1506.28 737.447 1465.84 711.975 1458.29 663.867 C 1456.68 654.131 1456.77 646.773 1457.2 637.006 C 1457.87 635.57 1459.49 627.956 1460.13 625.68 C 1464.24 611.017 1470.16 600.233 1478.49 587.604 C 1463.78 581.691 1457.29 579.422 1452.63 563.125 C 1459.43 537.769 1489.77 533.461 1512.01 527.81 C 1518.92 526.058 1529.22 524.446 1536.45 523.08 z"/>
<path transform="translate(0,0)" fill="rgb(224,150,61)" d="M 1545.45 567.226 C 1559.81 566.379 1570.94 567.266 1582.87 576.407 C 1595.48 585.881 1603.64 600.128 1605.43 615.802 C 1609.72 655.444 1584.74 683.766 1545.97 687.629 C 1533.25 688.101 1518.46 684.702 1507.75 677.727 C 1496.44 670.412 1488.59 658.803 1486.02 645.576 C 1482.87 629.985 1485.09 613.238 1494.16 599.914 C 1506.18 582.58 1524.67 570.802 1545.45 567.226 z"/>
<path transform="translate(0,0)" fill="rgb(251,196,116)" d="M 1545.86 590.332 C 1588.23 589.658 1591.63 643.338 1550.27 656.015 C 1533.65 656.716 1518.19 646.622 1516.18 629.655 C 1513.38 605.955 1522.92 593.109 1545.86 590.332 z"/>
<path transform="translate(0,0)" fill="rgb(251,196,116)" d="M 1537.03 398.304 C 1531.62 396.754 1517.09 394.341 1513.66 392.415 C 1520.46 385.223 1537.53 396.628 1551.42 384.926 C 1568.52 370.51 1576.17 333.084 1579.29 312.252 C 1582.52 321.379 1585.8 334.091 1588.73 343.784 C 1593.56 356.646 1598.4 375.618 1611.46 382.02 C 1621.2 386.797 1634.32 388.07 1645.05 386.685 C 1643.53 390.092 1644.64 388.728 1641.5 390.868 C 1638.14 390.879 1637.07 390.255 1633.98 389.1 C 1631.92 391.601 1634.97 390.708 1633.73 392.665 C 1631.47 396.237 1629.91 393.973 1625.17 396.121 C 1626.97 400.719 1628.95 394.843 1627.66 400.215 C 1625.81 401.64 1622.51 403.38 1622.49 405.933 C 1620.67 410.751 1619.91 413.235 1618.73 418.246 C 1623.1 421.074 1627.23 423.777 1631.75 426.374 C 1636.35 427.942 1639.34 429.426 1644.15 429.026 C 1647.78 428.133 1646.08 427.939 1649.43 429.684 C 1645.69 431.24 1643.63 432.149 1639.74 433.155 L 1639.28 432.609 C 1634.27 428.098 1622.24 430.401 1609.27 423.529 C 1594.15 418.337 1585.56 391.598 1579.79 378.135 C 1573.99 395.189 1568.44 413.101 1553.39 424.093 C 1551.3 421.07 1552.09 420.947 1552.68 416.163 C 1556.13 413.257 1556.84 412.495 1559.57 408.891 C 1553.26 403.951 1545.24 398.445 1537.03 398.304 z"/>
<path transform="translate(0,0)" fill="rgb(224,150,61)" d="M 1588.73 343.784 C 1593.56 356.646 1598.4 375.618 1611.46 382.02 C 1621.2 386.797 1634.32 388.07 1645.05 386.685 C 1643.53 390.092 1644.64 388.728 1641.5 390.868 C 1638.14 390.879 1637.07 390.255 1633.98 389.1 C 1631.92 391.601 1634.97 390.708 1633.73 392.665 C 1631.47 396.237 1629.91 393.973 1625.17 396.121 C 1626.97 400.719 1628.95 394.843 1627.66 400.215 C 1625.81 401.64 1622.51 403.38 1622.49 405.933 C 1620.67 410.751 1619.91 413.235 1618.73 418.246 C 1623.1 421.074 1627.23 423.777 1631.75 426.374 C 1636.35 427.942 1639.34 429.426 1644.15 429.026 C 1647.78 428.133 1646.08 427.939 1649.43 429.684 C 1645.69 431.24 1643.63 432.149 1639.74 433.155 L 1639.28 432.609 C 1634.27 428.098 1622.24 430.401 1609.27 423.529 C 1628.67 425.186 1611.05 405.102 1617.51 400.659 L 1619.01 404.565 L 1620.09 404.912 L 1625.25 399.621 C 1621.82 397.979 1619.28 397.038 1616.44 394.489 C 1619.07 393.395 1621.49 393.514 1624.35 393.362 C 1622.57 391.662 1606.06 383.776 1602.97 382.212 C 1598.3 373.144 1587.07 353.589 1588.73 343.784 z"/>
<path transform="translate(0,0)" fill="rgb(229,232,232)" d="M 1579.79 378.135 C 1585.56 391.598 1594.15 418.337 1609.27 423.529 C 1622.24 430.401 1634.27 428.098 1639.28 432.609 C 1630.86 433.944 1614.68 436.083 1606.94 438.32 C 1583.04 442.593 1589.74 472.782 1581.26 482.347 L 1579.1 487.559 C 1571.24 464.981 1571.82 445.673 1545.11 438.668 L 1540.9 436.977 L 1540.19 433.714 C 1538.13 432.506 1537.25 433.454 1534.7 431.285 L 1534.87 428.811 C 1542.25 427.757 1546.57 427.212 1553.39 424.093 C 1568.44 413.101 1573.99 395.189 1579.79 378.135 z"/>
<path transform="translate(0,0)" fill="rgb(251,196,116)" d="M 1540.19 433.714 C 1575.82 438.613 1575.37 450.554 1581.26 482.347 L 1579.1 487.559 C 1571.24 464.981 1571.82 445.673 1545.11 438.668 L 1540.9 436.977 L 1540.19 433.714 z"/>
<path transform="translate(0,0)" fill="rgb(161,97,35)" d="M 1512.01 527.81 C 1511.22 508.711 1512.88 497.534 1518.88 479.772 C 1526.27 497.467 1525.22 506.147 1536.45 523.08 C 1529.22 524.446 1518.92 526.058 1512.01 527.81 z"/>
<path transform="translate(0,0)" fill="rgb(97,94,76)" d="M 1537.23 436.332 L 1540.9 436.977 L 1545.11 438.668 L 1545.15 440.089 C 1552.39 442.614 1553.65 441.504 1559.09 446.612 L 1559.97 448.881 C 1554.36 453.368 1540.03 449.78 1532.21 451.905 L 1522.96 448.545 C 1519.1 446.096 1516.16 445.022 1514.84 441.07 L 1516.07 439.111 C 1525.97 434.974 1529.66 438.33 1537.23 436.332 z"/>
<path transform="translate(0,0)" fill="rgb(97,94,76)" d="M 1639.28 432.609 L 1639.74 433.155 C 1639.74 434.842 1639.76 435.612 1640.16 437.282 C 1636.76 444.239 1625.64 449.332 1618.8 453.642 C 1615.88 455.561 1612.51 456.552 1609.02 456.08 C 1605.77 454.192 1605.86 453.839 1603.91 450.726 C 1603.84 448.915 1603.57 447.935 1602.97 446.227 C 1604.84 444.702 1610.2 442.097 1612.59 440.834 C 1614.09 441.214 1613.28 441.167 1615.03 440.828 L 1615.3 440.074 C 1611.63 439.979 1610.28 440.186 1606.94 438.32 C 1614.68 436.083 1630.86 433.944 1639.28 432.609 z"/>
<path transform="translate(0,0)" fill="rgb(228,213,162)" d="M 1581.26 482.347 C 1589.74 472.782 1583.04 442.593 1606.94 438.32 C 1610.28 440.186 1611.63 439.979 1615.3 440.074 L 1615.03 440.828 C 1613.28 441.167 1614.09 441.214 1612.59 440.834 C 1610.2 442.097 1604.84 444.702 1602.97 446.227 C 1589.47 455.481 1582.42 489.621 1581.31 505.655 C 1580.52 499.63 1579.78 493.597 1579.1 487.559 L 1581.26 482.347 z"/>
<path transform="translate(0,0)" fill="rgb(23,29,38)" d="M 1506.46 447.377 C 1511.96 446.991 1517.46 447.903 1522.96 448.545 L 1532.21 451.905 L 1532.3 452.135 L 1531.57 452.871 C 1515.53 450.14 1500.46 450.703 1484.26 450.711 C 1488.2 448.306 1503.1 451.078 1507.24 448.814 L 1506.46 447.377 z"/>
<path transform="translate(0,0)" fill="rgb(41,54,68)" d="M 1458.29 663.867 C 1465.84 711.975 1506.28 737.447 1553.63 730.087 C 1575.35 726.711 1588.64 713.933 1602.63 697.946 C 1604.2 701.639 1604.52 702.476 1605.01 706.445 C 1606.12 715.283 1610.84 723.457 1615.18 731.113 C 1594.22 750.213 1590.21 769.356 1592.54 796.78 C 1569.96 804.721 1545.98 809.287 1522.73 814.959 C 1504.67 819.366 1486.04 820.896 1467.68 824.03 C 1460.64 818.065 1460.29 819.45 1449.28 820.285 C 1442.31 808.794 1422.66 744.523 1429.01 733.59 C 1431.72 732.495 1432.01 732.992 1434.97 733.795 C 1461.44 752.399 1472.6 761.436 1506.05 766.658 L 1507.05 765.703 C 1490.68 752.001 1472.34 748.906 1458.51 731.361 C 1445.48 714.816 1447.29 696.242 1452 676.822 C 1454.03 668.431 1457.07 672.745 1458.29 663.867 z"/>
<path transform="translate(0,0)" fill="url(#Gradient3)" d="M 1507.12 427.572 C 1509.8 427.457 1514.63 426.187 1517.42 425.568 C 1518.81 428.665 1518.35 429.155 1521.81 430.681 C 1526.6 429.757 1530.01 429.299 1534.87 428.811 L 1534.7 431.285 C 1537.25 433.454 1538.13 432.506 1540.19 433.714 L 1540.9 436.977 L 1537.23 436.332 C 1529.66 438.33 1525.97 434.974 1516.07 439.111 L 1514.84 441.07 C 1516.16 445.022 1519.1 446.096 1522.96 448.545 C 1517.46 447.903 1511.96 446.991 1506.46 447.377 C 1492.33 444.422 1479.44 447.564 1466.3 443.154 C 1463.24 442.128 1465.68 433.962 1467.03 431.895 C 1470.54 430.245 1469.76 430.818 1474.17 431.105 C 1485.63 431.444 1490.67 432.277 1501.65 429.282 L 1507.12 427.572 z"/>
<path transform="translate(0,0)" fill="rgb(244,239,224)" d="M 1521.81 430.681 C 1526.6 429.757 1530.01 429.299 1534.87 428.811 L 1534.7 431.285 C 1537.25 433.454 1538.13 432.506 1540.19 433.714 L 1540.9 436.977 L 1537.23 436.332 C 1532.39 435.226 1523.86 434.357 1518.62 433.689 C 1518 432.926 1518.38 433.492 1518.01 431.749 L 1521.81 430.681 z"/>
<path transform="translate(0,0)" fill="rgb(251,196,116)" d="M 1507.12 427.572 C 1509.8 427.457 1514.63 426.187 1517.42 425.568 C 1518.81 428.665 1518.35 429.155 1521.81 430.681 L 1518.01 431.749 C 1518.38 433.492 1518 432.926 1518.62 433.689 C 1517.25 433.747 1512.91 433.074 1511.31 432.867 C 1506.51 431.937 1505.82 431.789 1501.65 429.282 L 1507.12 427.572 z"/>
<path transform="translate(0,0)" fill="rgb(161,154,129)" d="M 1474.17 431.105 C 1485.63 431.444 1490.67 432.277 1501.65 429.282 C 1505.82 431.789 1506.51 431.937 1511.31 432.867 C 1502.41 432.794 1481.87 435.856 1474.17 431.105 z"/>
<path transform="translate(0,0)" fill="rgb(41,54,68)" d="M 1537.03 398.304 C 1545.24 398.445 1553.26 403.951 1559.57 408.891 C 1556.84 412.495 1556.13 413.257 1552.68 416.163 C 1552.09 420.947 1551.3 421.07 1553.39 424.093 C 1546.57 427.212 1542.25 427.757 1534.87 428.811 C 1530.01 429.299 1526.6 429.757 1521.81 430.681 C 1518.35 429.155 1518.81 428.665 1517.42 425.568 C 1514.63 426.187 1509.8 427.457 1507.12 427.572 L 1507.23 427.121 C 1511 423.116 1523.06 423.872 1527.94 421.808 C 1533.62 419.404 1536.38 422.532 1540.53 419.396 C 1539.32 415.492 1526.06 405.542 1522.98 405.903 C 1517.08 406.597 1499.8 414.193 1494.39 412.323 C 1502.75 408.197 1533.69 403.381 1537.03 398.304 z"/>
<path transform="translate(0,0)" fill="rgb(251,196,116)" d="M 1517.42 425.568 C 1529.46 423.429 1542.37 422.409 1552.68 416.163 C 1552.09 420.947 1551.3 421.07 1553.39 424.093 C 1546.57 427.212 1542.25 427.757 1534.87 428.811 C 1530.01 429.299 1526.6 429.757 1521.81 430.681 C 1518.35 429.155 1518.81 428.665 1517.42 425.568 z"/>
<path transform="translate(0,0)" fill="rgb(41,54,68)" d="M 1643.53 417.472 L 1645.77 415.285 C 1650.76 416.995 1651.03 419.016 1655.12 420.38 L 1656.33 420.983 C 1666.57 426.101 1669.72 431.913 1670.46 442.979 L 1669.39 447.107 C 1666.74 444.438 1669.94 439.511 1668.27 435.126 C 1663.99 430.435 1656.81 431.649 1650.98 432.435 L 1652.08 432.086 L 1645.66 433.383 C 1646.22 435.521 1646.66 437.642 1647 439.826 C 1643.29 443.114 1645.61 438.915 1638.62 444.834 L 1639.55 445.721 C 1649.24 445.382 1657.51 440.746 1664.75 434.678 L 1665.75 435.433 C 1665.4 438.39 1665.73 438.677 1664.38 441.015 L 1663.53 437.474 C 1660.93 439.886 1658.39 442.227 1655.89 444.74 C 1652.72 445.295 1648.8 445.73 1646.02 447.154 L 1645.04 448.885 C 1643.62 449.068 1641.21 448.799 1640.88 448.837 C 1632.8 449.767 1627.44 452.872 1618.8 453.642 C 1625.64 449.332 1636.76 444.239 1640.16 437.282 C 1639.76 435.612 1639.74 434.842 1639.74 433.155 C 1643.63 432.149 1645.69 431.24 1649.43 429.684 C 1646.08 427.939 1647.78 428.133 1644.15 429.026 C 1644.49 424.568 1644.03 421.893 1643.53 417.472 z"/>
<path transform="translate(0,0)" fill="rgb(161,97,35)" d="M 1643.53 417.472 L 1645.77 415.285 C 1650.76 416.995 1651.03 419.016 1655.12 420.38 L 1656.33 420.983 L 1653 423.8 C 1654.33 425.733 1653.46 424.918 1656.2 425.678 L 1655.53 426.829 L 1655.99 427.007 C 1652.94 430.156 1652.16 428.237 1649.43 429.684 C 1646.08 427.939 1647.78 428.133 1644.15 429.026 C 1644.49 424.568 1644.03 421.893 1643.53 417.472 z"/>
<path transform="translate(0,0)" fill="rgb(23,29,38)" d="M 1434.97 733.795 C 1444.98 733.234 1443.29 732.631 1449.14 739.869 C 1461.56 755.222 1489.53 761.979 1507.05 765.703 L 1506.05 766.658 C 1472.6 761.436 1461.44 752.399 1434.97 733.795 z"/>
<path transform="translate(0,0)" fill="url(#Gradient2)" d="M 642.736 686.121 C 669.6 669.269 700.258 653.818 728.284 639.01 C 741.236 632.167 761.175 619.249 773.938 615.026 C 769.792 640.345 745.549 743.389 757.722 774.654 C 760.303 781.283 797.23 780.547 810.328 783.099 C 806.602 790.865 780.649 837.969 782.581 843.93 C 786.21 855.122 876.658 950.829 892.111 966.555 C 911.781 986.243 931.792 1005.59 952.136 1024.58 C 965.966 1037.24 980.401 1049.76 995.408 1061.01 C 998.888 1063.62 1002.67 1066.06 1006 1068.82 L 1005.94 1070.33 C 1005.31 1084.89 1002.39 1100.58 1001.2 1115.35 C 998.34 1150.79 1003.16 1183.17 1013.71 1216.8 C 1005.29 1235.46 995.384 1254.46 986.072 1272.77 C 982.599 1282.97 970.233 1307.45 961.893 1314.16 C 948.569 1324.76 936.998 1332.05 920.001 1335.29 C 866.43 1345.49 776.597 1316.96 732.015 1286.27 C 717.512 1276.28 686.819 1249.12 681.818 1232.17 C 675.947 1212.26 721.522 1097.62 720.366 1061.95 C 719.935 1048.65 714.447 1035.48 710.219 1023.02 C 699.966 992.821 686.487 962.659 680.742 931.275 C 688.618 926.532 704.623 915.833 700.096 905.188 C 690.56 900.242 677.163 917.169 670.213 921.276 C 663.3 925.006 656.144 926.998 648.654 929.587 C 614.043 941.552 577.072 952.701 545.779 971.961 C 542.598 973.919 537.556 980.602 536.143 983.961 C 521.329 1019.18 508.721 1055.59 495.331 1091.4 C 489.721 1106.26 482.824 1133.07 471.603 1143.84 C 460.308 1154.68 436.442 1156.06 421.578 1154.53 C 399.661 1150.6 378.734 1144.06 360.936 1131.95 C 341.94 1119.02 319.222 1109.09 329.321 1082.35 C 364.495 989.224 385.153 877.813 469.312 814.451 C 478.574 807.477 486.537 802.058 496.082 795.77 C 517.445 783.365 532.348 768.012 550.491 751.628 C 579.005 725.878 608.843 704.45 642.736 686.121 z"/>
<path transform="translate(0,0)" fill="rgb(41,54,68)" d="M 642.736 686.121 C 645.798 689.048 653.074 698.439 655.831 702.233 C 680.075 735.601 694.573 769.207 695.713 810.93 C 696.128 826.126 693.3 840.469 693.468 855.22 C 677.842 868.424 647.357 875.186 627.615 881.598 C 595.307 892.09 491.223 926.141 471.967 950.84 C 481.826 953.662 496.16 958.518 505.568 960.661 C 483.079 1010.43 465.922 1061.8 439.643 1109.86 C 433.599 1120.91 426.106 1142.27 421.578 1154.53 C 399.661 1150.6 378.734 1144.06 360.936 1131.95 C 341.94 1119.02 319.222 1109.09 329.321 1082.35 C 364.495 989.224 385.153 877.813 469.312 814.451 C 478.574 807.477 486.537 802.058 496.082 795.77 C 517.445 783.365 532.348 768.012 550.491 751.628 C 579.005 725.878 608.843 704.45 642.736 686.121 z"/>
<path transform="translate(0,0)" fill="rgb(28,40,51)" d="M 961.893 1314.16 C 964.603 1304.64 978.02 1279.31 986.072 1272.77 C 982.599 1282.97 970.233 1307.45 961.893 1314.16 z"/>
<path transform="translate(0,0)" fill="rgb(41,54,68)" d="M 995.695 1298.93 C 1013.58 1338.73 1033.96 1375.91 1052.77 1415.05 C 1083.32 1478.66 1111.18 1543.69 1140.29 1607.81 C 1152.64 1635.14 1164.66 1662.62 1176.37 1690.23 C 1182.03 1703.29 1190.8 1721.52 1195.57 1734.48 C 1166.74 1757.8 1125.98 1788.55 1095.19 1808.79 C 1085.66 1817.79 1059.97 1833.07 1048.34 1837.99 C 1039.86 1819.03 1029.82 1798.83 1022.09 1779.96 C 990.556 1702.36 950.521 1628.59 909.566 1555.66 C 887.311 1516.02 858.114 1482.39 833.03 1444.79 C 807.208 1406.09 783.059 1365.88 759.024 1326.01 C 771.398 1330.29 782.991 1336.22 795.21 1340.77 C 815.387 1348.29 837.565 1354.6 858.805 1358.1 C 871.019 1360.11 883.992 1358.26 896.335 1360.02 C 922.656 1357.82 957.133 1352.32 975.017 1330.77 C 982.177 1322.14 989.747 1308.79 995.695 1298.93 z"/>
<path transform="translate(0,0)" fill="rgb(28,40,51)" d="M 1048.34 1837.99 C 1039.86 1819.03 1029.82 1798.83 1022.09 1779.96 C 990.556 1702.36 950.521 1628.59 909.566 1555.66 C 887.311 1516.02 858.114 1482.39 833.03 1444.79 C 807.208 1406.09 783.059 1365.88 759.024 1326.01 C 771.398 1330.29 782.991 1336.22 795.21 1340.77 C 815.387 1348.29 837.565 1354.6 858.805 1358.1 C 871.019 1360.11 883.992 1358.26 896.335 1360.02 C 883.209 1368.59 853.203 1366.34 846.473 1372.23 C 847.334 1377.57 879.641 1416.39 885.083 1428.71 C 893.605 1448.02 916.504 1471.05 928.752 1488.91 C 947.859 1518.51 973.606 1556.44 986.777 1588.93 C 1012.71 1652.9 1048.95 1709.52 1077.5 1772.13 C 1082.89 1784.11 1090.54 1796.84 1095.19 1808.79 C 1085.66 1817.79 1059.97 1833.07 1048.34 1837.99 z"/>
<path transform="translate(0,0)" fill="rgb(248,183,137)" d="M 1086.15 374.669 C 1092.55 373.742 1099.68 372.863 1105.93 371.558 C 1115.12 408.466 1131.82 462.725 1180.52 438.439 C 1183.01 451.807 1185.67 467.224 1185.7 480.878 C 1185.79 522.977 1174.37 575.737 1150.51 610.768 C 1132.6 637.052 1111.38 650.994 1081.85 660.441 C 1053.95 666.144 1027.88 665.669 1000.43 657.312 C 953.167 642.483 912.48 611.767 885.268 570.37 C 875.557 555.695 864.8 534.431 856.327 518.682 C 834.202 535.597 821.793 537.702 796.757 524.826 C 776.329 513.481 764.085 502.003 753.811 480.588 C 740.931 453.742 742.579 415.998 773.024 402.051 C 823.672 389.045 824.445 446.419 857.104 458.548 C 877.583 450.453 881.263 431.415 882.322 411.709 C 901.638 413.851 905.659 412.632 923.12 412.74 C 924.565 415.183 924.248 414.224 924.461 417.02 C 928.583 441.227 934.522 464.385 955.518 479.372 C 989.422 503.572 1042.99 489.212 1065.62 455.836 C 1082.33 431.199 1084.99 403.396 1086.15 374.669 z"/>
<path transform="translate(0,0)" fill="rgb(212,145,104)" d="M 773.024 402.051 C 823.672 389.045 824.445 446.419 857.104 458.548 C 877.583 450.453 881.263 431.415 882.322 411.709 C 901.638 413.851 905.659 412.632 923.12 412.74 C 924.565 415.183 924.248 414.224 924.461 417.02 C 897.555 425.09 899.907 498.055 904.742 519.16 C 906.177 525.424 907.819 532.2 909.904 538.319 C 926.384 593.691 984.045 636.424 1037.27 652.114 C 1049.17 655.622 1072.16 655.219 1081.85 660.441 C 1053.95 666.144 1027.88 665.669 1000.43 657.312 C 953.167 642.483 912.48 611.767 885.268 570.37 C 875.557 555.695 864.8 534.431 856.327 518.682 C 834.202 535.597 821.793 537.702 796.757 524.826 C 776.329 513.481 764.085 502.003 753.811 480.588 C 740.931 453.742 742.579 415.998 773.024 402.051 z"/>
<path transform="translate(0,0)" fill="rgb(248,183,137)" d="M 796.757 524.826 C 776.329 513.481 764.085 502.003 753.811 480.588 C 740.931 453.742 742.579 415.998 773.024 402.051 C 778.105 411.095 779.952 413.81 782.066 424.105 C 774.072 427.872 769.759 429.522 763.224 435.602 C 759.091 468.132 783.721 495.246 798.224 521.115 C 798.273 521.202 797.092 524.181 796.757 524.826 z"/>
<path transform="translate(0,0)" fill="rgb(14,22,29)" d="M 785.016 436.173 C 818.468 434.652 827.101 484.545 818.606 488.216 L 816.999 486.787 C 814.167 472.402 811.341 458.182 800.302 447.401 C 793.001 440.27 787.383 442.425 778.893 440.517 C 780.59 437.794 781.704 437.925 785.016 436.173 z"/>
<path transform="translate(0,0)" fill="rgb(14,22,29)" d="M 1168.69 469.773 C 1192.82 485.673 1145.61 530.935 1094.11 503.425 C 1090.31 500.962 1085.24 497.53 1082.92 493.74 L 1083.42 492.037 L 1087.43 491.113 C 1088.02 489.582 1088.32 488.088 1088.57 486.469 C 1092.04 485.092 1100.86 487.292 1105.76 487.444 C 1129 488.163 1149.77 482.905 1168.69 469.773 z"/>
<path transform="translate(0,0)" fill="rgb(14,22,29)" d="M 1039.51 565.085 C 1032 562.86 1008.06 555.195 1010.6 545.043 C 1044.81 560.789 1074.09 559.706 1110.23 549.241 C 1113.93 548.171 1122.58 544.281 1125.19 544.772 C 1129.07 551.515 1118.15 558.531 1112.94 560.987 C 1105.92 577.318 1057.69 575.847 1043.19 569.791 C 1041.2 568.958 1040.38 566.837 1039.51 565.085 z"/>
<path transform="translate(0,0)" fill="url(#Gradient1)" d="M 1039.51 565.085 C 1058.71 568.287 1094.37 565.287 1112.94 560.987 C 1105.92 577.318 1057.69 575.847 1043.19 569.791 C 1041.2 568.958 1040.38 566.837 1039.51 565.085 z"/>
<path transform="translate(0,0)" fill="rgb(63,49,45)" d="M 1151.89 78.5628 C 1180.74 107.926 1175.91 151.804 1146.46 178.843 C 1098.84 222.554 1028.46 243.129 964.69 240.797 C 916.683 238.687 871.065 223.958 826.821 207.749 C 826.009 212.657 825.228 217.569 824.478 222.486 C 859.425 253.649 870.562 286.183 865.3 332.383 C 862.809 348.702 843.258 384.931 831.899 394.437 C 835.22 394.859 852.291 393.245 851.203 392.536 C 861.695 399.379 869.202 403.62 866.103 417.797 C 864.673 424.671 864.966 427.7 860.026 433.049 C 849.274 437.344 843.209 413.597 841.059 405.911 C 838.367 403.581 830.181 397.943 828.944 396.697 C 804.691 382.618 802.798 374.025 771.408 380.309 C 761.761 370.53 753.656 359.34 747.372 347.125 C 727.641 309.601 719.35 268.544 732.309 227.295 C 741.464 208.252 749.575 200.004 771.572 200.711 C 775.072 118.737 876.49 79.0304 947.708 82.4518 C 968.574 83.5759 989.27 86.841 1009.47 92.1958 C 1042.26 101.168 1073.89 121.596 1109.46 107.003 C 1125.86 100.277 1138.41 86.2172 1151.89 78.5628 z"/>
<path transform="translate(0,0)" fill="rgb(49,36,31)" d="M 732.309 227.295 C 743.054 247.319 801.991 280.143 822.189 296.063 C 831.141 303.118 859.477 324.888 865.3 332.383 C 862.809 348.702 843.258 384.931 831.899 394.437 C 835.22 394.859 852.291 393.245 851.203 392.536 C 861.695 399.379 869.202 403.62 866.103 417.797 C 864.673 424.671 864.966 427.7 860.026 433.049 C 849.274 437.344 843.209 413.597 841.059 405.911 C 838.367 403.581 830.181 397.943 828.944 396.697 C 804.691 382.618 802.798 374.025 771.408 380.309 C 761.761 370.53 753.656 359.34 747.372 347.125 C 727.641 309.601 719.35 268.544 732.309 227.295 z"/>
<path transform="translate(0,0)" fill="rgb(41,54,68)" d="M 1180.63 597.714 C 1192.01 601.931 1203.41 609.333 1211.49 618.333 C 1242.39 652.757 1267.61 694.094 1294.04 731.726 L 1330.47 782.968 C 1337.14 792.334 1345.93 803.93 1351.69 813.662 C 1331.68 838.691 1325.67 855.351 1318.71 886.563 C 1327.24 875.782 1376.82 817.023 1386.38 812.566 C 1392.21 821.417 1384.62 843.654 1384.68 854.454 C 1384.73 863.44 1385.13 865.468 1387.34 873.975 L 1382.6 872.425 C 1372.24 881.738 1364.38 897.372 1353.65 906.158 C 1344.59 913.568 1325.63 928.106 1314.03 928.343 C 1312.22 921.626 1309.71 916.782 1306.25 910.863 C 1301.46 902.17 1290.23 894.34 1284.04 885.313 C 1274.26 871.06 1246.93 834.461 1230.65 830.248 C 1232.7 808.454 1240.73 718.542 1229.85 703.405 L 1228.72 704.121 C 1227.33 712.408 1228.88 717.938 1226.81 726.563 C 1223.56 740.147 1217.1 751.161 1215.86 765.283 C 1213.63 790.428 1215.13 815.822 1210.41 840.747 C 1197.32 909.82 1175.99 975.812 1150.86 1041.48 C 1148.31 1048.16 1131.72 1093.3 1126.34 1102.84 C 1126.56 1103.15 1126.77 1103.46 1126.99 1103.77 L 1130.06 1103.8 C 1130.72 1105.07 1136.8 1206.49 1137.15 1215.48 C 1138.76 1230.42 1137.28 1236.54 1127.78 1248.37 C 1107.64 1273.44 1084.02 1296.62 1063.18 1320.55 C 1061.05 1309.43 1058.73 1298.18 1057.17 1286.98 C 1052.13 1270.34 1045.69 1255.97 1040.2 1239.75 C 1024.15 1192.3 1015.42 1149.69 1019.28 1099.5 C 1022.84 1100.62 1026.42 1101.71 1030 1102.76 C 1042.84 1090.35 1058.35 1069.55 1069.22 1055.5 C 1125.59 982.573 1164.52 900.331 1181.55 809.647 C 1184.59 793.418 1189.64 773.479 1191.18 757.266 C 1179.74 741.005 1169.32 737.194 1151.74 729.426 C 1155.24 724.627 1158.09 719.426 1160.28 714.277 C 1164.82 703.578 1153.32 650.983 1148.87 642.743 C 1162.85 629.234 1170.8 614.293 1180.63 597.714 z"/>
<path transform="translate(0,0)" fill="rgb(28,40,51)" d="M 1137.15 1215.48 C 1138.76 1230.42 1137.28 1236.54 1127.78 1248.37 C 1107.64 1273.44 1084.02 1296.62 1063.18 1320.55 C 1061.05 1309.43 1058.73 1298.18 1057.17 1286.98 C 1058.46 1284.79 1058.6 1281.9 1059.7 1280.56 C 1080.37 1255.4 1110.08 1243.93 1135.34 1224.88 C 1137.17 1223.49 1136.97 1217.91 1137.15 1215.48 z"/>
<path transform="translate(0,0)" fill="rgb(14,22,29)" d="M 1041.09 1106.03 C 1049.87 1105.93 1050.51 1106.8 1057.25 1113 C 1063.48 1129.78 1060.8 1139.29 1044.69 1146.98 C 1024.86 1147.91 1016.6 1116.97 1041.09 1106.03 z"/>
<path transform="translate(0,0)" fill="rgb(28,40,51)" d="M 1254.15 1765.56 C 1274.2 1760.87 1287.3 1755.34 1306.39 1748.81 C 1329.99 1740.74 1368.74 1742.59 1376.85 1771.14 C 1381.13 1815.84 1325.01 1836.89 1293.18 1854.52 C 1263.39 1871.01 1229.67 1881.39 1198.84 1896.63 C 1207.73 1897.35 1218.05 1895.94 1226.08 1897.34 L 1226.5 1898.51 C 1222.33 1903.95 1214.12 1908.79 1208.56 1912.83 C 1183.63 1930.94 1155.74 1943.88 1126.19 1952.79 C 1115.65 1937.23 1106.87 1909.28 1099.96 1891.56 C 1093.33 1874.55 1086.43 1857.66 1079.55 1840.74 C 1085.96 1835.43 1092.43 1831.34 1099.47 1826.97 C 1135.2 1804.83 1167.06 1777.73 1203.67 1757.06 C 1222.7 1764.23 1233.71 1764.32 1254.15 1765.56 z"/>
<path transform="translate(0,0)" fill="rgb(41,54,68)" d="M 1254.15 1765.56 C 1274.2 1760.87 1287.3 1755.34 1306.39 1748.81 C 1329.99 1740.74 1368.74 1742.59 1376.85 1771.14 C 1376.75 1771.48 1376.75 1771.86 1376.56 1772.16 C 1376.25 1772.66 1375.88 1773.17 1375.37 1773.49 C 1373.69 1774.55 1354.5 1774.63 1351.04 1775.01 C 1345.39 1775.62 1340.05 1776.77 1334.58 1778.28 C 1323.29 1781.41 1281.28 1811.96 1268.07 1819.83 C 1258.85 1825.31 1225.8 1843.43 1215.52 1839.99 C 1213.88 1839.44 1213.78 1838.49 1212.96 1837.1 C 1212.73 1824.04 1245.39 1777.93 1254.15 1765.56 z"/>
<path transform="translate(0,0)" fill="rgb(28,40,51)" d="M 765.662 1380.26 C 766.768 1380.1 767.316 1380.44 768.538 1380.77 C 778.428 1391.48 793.547 1419.25 802.093 1432.37 C 817.764 1456.45 840.416 1485.11 854.135 1509.58 C 837.437 1517.41 822.053 1521.94 804.986 1528.02 C 769.542 1540.64 735.245 1550.08 698.284 1557.76 C 689.687 1559.54 680.959 1560.79 672.281 1562.13 C 657.926 1549.9 620.402 1513.36 618.098 1495.03 C 616.665 1483.62 611.28 1445.14 618.842 1437.23 C 647.803 1406.91 727.749 1388 765.662 1380.26 z"/>
<path transform="translate(0,0)" fill="rgb(248,183,137)" d="M 870.672 241.613 C 902.645 252.439 927.389 260.341 961.939 261.953 C 1026.76 264.976 1099.93 245.499 1148.24 200.292 L 1154.07 221.52 C 1160.35 246.862 1166.39 272.261 1172.2 297.713 C 1115.16 327.292 1042.06 345.027 980.018 362.36 C 962.849 367.157 931.811 377.903 915.908 378.037 C 904.226 378.013 886.979 374.542 875.116 372.477 C 877.429 362.563 881.348 351.9 883.585 341.666 C 892.134 302.55 889.218 276.429 870.672 241.613 z"/>
<path transform="translate(0,0)" fill="rgb(212,145,104)" d="M 870.672 241.613 C 902.645 252.439 927.389 260.341 961.939 261.953 C 1026.76 264.976 1099.93 245.499 1148.24 200.292 L 1154.07 221.52 C 1074.45 272.627 1006.06 289.195 911.261 287.932 C 910.505 318.305 914.534 347.705 915.908 378.037 C 904.226 378.013 886.979 374.542 875.116 372.477 C 877.429 362.563 881.348 351.9 883.585 341.666 C 892.134 302.55 889.218 276.429 870.672 241.613 z"/>
<path transform="translate(0,0)" fill="rgb(41,54,68)" d="M 802.878 598.738 C 806.069 601.509 811.065 625.483 812.841 631.611 C 833.055 701.367 865.011 764.153 901.141 826.88 C 918.58 857.367 936.709 887.455 955.514 917.119 L 996.554 981.592 C 1005.07 995.038 1015.63 1010.87 1022.86 1024.73 C 1020.94 1034 1017.41 1045.46 1014.83 1054.74 C 1005.85 1047.57 995.174 1037.59 986.43 1029.8 C 944.473 991.839 901.504 952.226 863.886 909.926 C 843.147 886.606 822.581 863.275 801.753 839.976 C 809.119 825.768 838.632 785.908 834.167 771.187 C 827.507 764.275 787.686 763.178 774.135 760.367 C 771.454 727.79 779.44 619.897 802.878 598.738 z"/>
<path transform="translate(0,0)" fill="rgb(28,40,51)" d="M 549.016 1530.39 C 531.918 1518.39 526.925 1494.7 527.745 1474.96 C 529.139 1441.39 568.449 1421.28 598.541 1424.07 C 601.115 1424.31 602.992 1424.36 604.635 1426.31 C 595.685 1446.53 598.748 1443.57 595.302 1463.75 C 596.32 1481.92 597.519 1494.44 605.191 1511.19 C 611.249 1524.22 619.241 1536.26 628.897 1546.9 C 639.752 1558.96 644.454 1564.71 653.756 1578.16 C 664.992 1594.41 678.274 1609.86 688.941 1626.78 C 700.446 1642.63 726.241 1653.01 727.311 1675.07 C 727.96 1698.42 700.96 1710.28 680.969 1709.4 C 650.089 1708.45 614.005 1687.41 592.532 1666.28 C 575.344 1649.37 566.72 1618.57 563.84 1595.52 C 562.302 1576.53 563.92 1571.05 558.893 1551.41 C 561.777 1545.63 567.842 1547.94 571.883 1543.51 C 568.084 1534.33 556.709 1537.92 549.016 1530.39 z"/>
<path transform="translate(0,0)" fill="rgb(41,54,68)" d="M 549.016 1530.39 C 531.918 1518.39 526.925 1494.7 527.745 1474.96 C 529.139 1441.39 568.449 1421.28 598.541 1424.07 C 601.115 1424.31 602.992 1424.36 604.635 1426.31 C 595.685 1446.53 598.748 1443.57 595.302 1463.75 C 583.021 1480.19 575.345 1494.54 566.472 1513.08 C 564.916 1516.33 563.02 1516.13 559.64 1516.25 C 556.267 1519.04 556.238 1523.81 549.016 1530.39 z"/>
<path transform="translate(0,0)" fill="rgb(212,145,104)" d="M 314.85 1151.82 C 347.367 1192.58 422.163 1221.67 467.851 1186.91 C 472.544 1195.49 475.409 1201.22 479.193 1210.22 C 486.272 1231.37 492.206 1253.59 489.078 1276.09 C 482.228 1298.94 469.112 1306.51 446.953 1312.12 L 446.768 1290.11 L 446.131 1255.25 C 437.896 1258.49 432.498 1260.87 424.758 1265.29 C 425.224 1278 426.004 1292.36 425.959 1305.01 C 426.23 1318.91 424.279 1335.78 411.117 1343.77 C 386.74 1358.56 362.695 1329.33 352.303 1309.98 C 352.195 1310.31 352.086 1310.63 351.978 1310.95 L 351.411 1312.55 C 351.097 1313.45 349.597 1317.88 349.242 1318.23 C 338.285 1328.8 319.227 1304.01 315.426 1296.57 C 307.999 1282.03 303.975 1269.9 301.059 1254.96 C 295.755 1261.94 293.938 1265.15 290.445 1273.03 C 256.849 1242.73 295.923 1180.21 314.85 1151.82 z"/>
<path transform="translate(0,0)" fill="rgb(248,183,137)" d="M 425.959 1305.01 C 419.067 1307.96 397.184 1301.75 389.475 1298.93 C 363.453 1289.44 333.629 1265.54 320.779 1240.91 C 314.62 1229.1 322.629 1203.76 327.427 1191.85 C 370.159 1223.38 410.575 1227.12 461.026 1215.37 C 467.229 1213.92 473.963 1214.02 479.193 1210.22 C 486.272 1231.37 492.206 1253.59 489.078 1276.09 C 482.228 1298.94 469.112 1306.51 446.953 1312.12 L 446.768 1290.11 L 446.131 1255.25 C 437.896 1258.49 432.498 1260.87 424.758 1265.29 C 425.224 1278 426.004 1292.36 425.959 1305.01 z"/>
<path transform="translate(0,0)" fill="rgb(212,145,104)" d="M 489.078 1276.09 C 482.228 1298.94 469.112 1306.51 446.953 1312.12 L 446.768 1290.11 C 453.408 1287.28 463.855 1287.64 470.386 1285.28 C 476.927 1282.92 481.367 1274.74 489.078 1276.09 z"/>
<path transform="translate(0,0)" fill="rgb(41,54,68)" d="M 1094.3 676.899 C 1107.03 672.007 1119.56 664.148 1132.17 657.998 C 1138.31 672.834 1142.55 688.391 1144.77 704.296 L 1144.44 705.193 C 1139.2 718.943 1131.93 728.107 1128.44 743.315 C 1130.17 744.579 1129.37 744.256 1130.65 744.646 C 1141.95 745.458 1157.41 752.218 1169.2 755.789 C 1167.59 866.783 1105.13 1000.44 1026.5 1078.22 C 1033 1047.55 1035.92 1044.25 1049.36 1017.36 C 1070.28 975.484 1091.36 919.159 1098.65 872.614 C 1107.96 813.124 1109.12 735.872 1094.3 676.899 z"/>
<path transform="translate(0,0)" fill="rgb(28,40,51)" d="M 1144.77 704.296 L 1144.44 705.193 C 1139.2 718.943 1131.93 728.107 1128.44 743.315 C 1130.17 744.579 1129.37 744.256 1130.65 744.646 C 1127.62 745.206 1129.17 745.152 1125.77 743.603 L 1125.35 742.083 C 1136.02 731.79 1124.39 728.246 1136.64 713.428 L 1137.53 716.679 C 1138.19 712.752 1141.55 706.848 1144.77 704.296 z"/>
<path transform="translate(0,0)" fill="rgb(28,40,51)" d="M 1314.03 928.343 C 1325.63 928.106 1344.59 913.568 1353.65 906.158 C 1364.38 897.372 1372.24 881.738 1382.6 872.425 L 1387.34 873.975 C 1401.36 907.478 1425.71 934.668 1457.45 952.943 C 1472.86 961.818 1483.93 962.223 1501.13 964.492 C 1472.76 992.172 1407.56 1023.54 1367.39 1023.1 C 1365.76 1023.09 1364.13 1023.05 1362.5 1022.98 C 1358.05 1018.2 1348.67 1008.31 1345.47 1003.27 C 1332.98 983.666 1320.66 950.677 1314.03 928.343 z"/>
<path transform="translate(0,0)" fill="rgb(28,40,51)" d="M 1230.65 830.248 C 1246.93 834.461 1274.26 871.06 1284.04 885.313 C 1290.23 894.34 1301.46 902.17 1306.25 910.863 C 1304.16 924.66 1319.75 972.069 1326.73 985.184 C 1332.41 995.859 1339.35 1007.99 1344.72 1019.44 L 1343.8 1019.02 C 1302.62 1001 1243.97 936.09 1221.22 896.903 C 1226.46 872.532 1227.73 854.898 1230.65 830.248 z"/>
<path transform="translate(0,0)" fill="rgb(212,145,104)" d="M 1590.94 817.249 C 1594.53 820.099 1583.89 829.618 1588.07 838.234 C 1593.17 848.73 1608.14 852.927 1618.6 856.812 C 1616.26 858.401 1613.84 859.888 1611.37 861.268 C 1583.2 877.349 1520.93 902.163 1489.51 893.691 C 1477.1 888.847 1465.31 881.977 1460.5 868.775 C 1458.38 862.986 1456.43 851.321 1459.16 845.355 C 1461.14 842.315 1466.19 839.869 1469.4 839.07 C 1474.8 837.649 1478.19 845.124 1483.86 843.154 C 1518.78 831.004 1555.23 826.428 1590.94 817.249 z"/>
<path transform="translate(0,0)" fill="rgb(229,232,232)" d="M 938.403 692.46 C 960.002 702.021 978.967 709.404 1000.75 718.128 C 991.326 727.049 979.769 737.578 972.175 747.929 C 964.832 757.936 958.499 769.071 951.064 779.255 C 925.301 763.596 900.648 748.159 873.867 734.302 C 869.223 724.43 863.754 713.183 859.61 703.146 C 860.27 703.378 863.811 704.534 864.135 704.609 C 874.712 707.038 932.233 695.809 938.403 692.46 z"/>
<path transform="translate(0,0)" fill="rgb(212,145,104)" d="M 847.744 545.113 C 851.151 548.07 863.632 573.984 867.844 579.969 C 879.106 595.971 890.512 610.804 905.13 623.99 C 940.004 655.448 991.728 680.802 1039.51 678.426 L 1015.69 704.025 C 988.361 696.235 966.485 690.609 940.51 677.873 C 890.408 653.308 842.737 603.914 824.95 550.405 C 834.501 549.595 839.003 548.558 847.744 545.113 z"/>
<path transform="translate(0,0)" fill="rgb(229,232,232)" d="M 887.8 762.467 C 897.076 765.234 941.866 798.436 954.796 805.357 C 963.083 798.63 972.589 785.186 979.787 776.381 C 983.802 783.291 988.896 789.506 993.804 795.821 C 987.821 824.275 983.543 846.517 981.981 875.751 C 981.269 889.876 981.159 904.026 981.652 918.16 C 949.91 871.644 912.379 813.514 887.8 762.467 z"/>
<path transform="translate(0,0)" fill="rgb(212,145,104)" d="M 1383.2 703.278 C 1379.75 681.714 1379.99 666.637 1392.32 646.849 C 1395.52 641.713 1401.15 637.451 1407.3 636.493 C 1412.49 635.727 1417.77 637.089 1421.94 640.271 C 1438.52 652.715 1437.9 691.986 1423.49 705.971 C 1417.94 709.314 1412.88 706.953 1406.28 705.586 C 1405.46 706.378 1405.33 706.39 1404.74 707.57 C 1398.96 719.064 1421 795.074 1425.92 810.659 C 1429.36 821.533 1433.89 832.032 1437.15 842.942 C 1436.05 844.502 1436.25 844.389 1434.58 845.126 C 1433.21 845.736 1430.49 846.714 1429.09 845.263 C 1410.06 825.641 1386.44 726.461 1383.2 703.278 z"/>
<path transform="translate(0,0)" fill="rgb(248,183,137)" d="M 1383.2 703.278 C 1379.75 681.714 1379.99 666.637 1392.32 646.849 C 1395.52 641.713 1401.15 637.451 1407.3 636.493 C 1412.49 635.727 1417.77 637.089 1421.94 640.271 C 1438.52 652.715 1437.9 691.986 1423.49 705.971 C 1422.2 703.824 1419.93 701.648 1418.09 699.926 C 1403.83 686.588 1406.53 678.464 1406.51 659.982 C 1403.25 665.114 1400.34 670.453 1397.75 675.959 C 1392.57 687.022 1393.55 695.933 1383.2 703.278 z"/>
<path transform="translate(0,0)" fill="rgb(28,40,51)" d="M 1000.46 383.4 C 1019.72 372.775 1052.14 365.877 1074.16 362.004 C 1073.23 397.043 1068.8 421.694 1048.07 449.722 C 1025.93 440.796 1004.6 425.883 984.493 418.039 C 980.428 408.206 985.238 403.282 991.634 395.789 C 994.366 392.054 998.106 387.246 1000.46 383.4 z"/>
<path transform="translate(0,0)" fill="rgb(23,29,38)" d="M 984.493 418.039 C 980.428 408.206 985.238 403.282 991.634 395.789 C 990.801 405.694 989.002 409.407 984.493 418.039 z"/>
<path transform="translate(0,0)" fill="rgb(186,188,190)" d="M 817.562 571.607 C 835.943 608.345 865.38 645.527 899.06 669.228 C 911.974 678.315 924.566 684.986 938.403 692.46 C 932.233 695.809 874.712 707.038 864.135 704.609 C 863.811 704.534 860.27 703.378 859.61 703.146 C 855.541 696.588 849.574 681.366 846.706 674.041 C 833.487 640.282 823.238 607.43 817.562 571.607 z"/>
<path transform="translate(0,0)" fill="rgb(28,40,51)" d="M 1162.54 401.981 C 1164.67 395.858 1163.81 389.29 1163.64 382.778 C 1163.16 365.602 1161.46 343.755 1174.51 330.41 C 1179.19 325.632 1185.55 321.664 1191.11 317.695 C 1198.11 312.813 1204.69 301.821 1214.7 304.808 C 1221.46 306.825 1219.25 322.006 1218.33 327.874 C 1215.27 347.404 1210.32 373.279 1200.72 390.616 C 1197.35 396.705 1183.16 407.944 1177.63 412.572 C 1169.55 416.91 1159.8 410.942 1162.54 401.981 z"/>
<path transform="translate(0,0)" fill="rgb(23,29,38)" d="M 1162.54 401.981 C 1169.67 405.981 1171.32 407.189 1177.63 412.572 C 1169.55 416.91 1159.8 410.942 1162.54 401.981 z"/>
<path transform="translate(0,0)" fill="rgb(186,188,190)" d="M 1406.97 843.996 C 1409.37 845.845 1414.69 851.363 1417.4 853.778 C 1424.42 860.039 1429.5 863.082 1437.61 867.832 C 1445.2 896.832 1477.32 913.704 1505.44 915.559 C 1516.34 916.278 1525.2 914.965 1535.88 913.349 C 1533.3 923.187 1531.67 928.838 1526.89 937.758 C 1500.16 975.886 1398.23 897.249 1406.97 843.996 z"/>
<path transform="translate(0,0)" fill="rgb(248,183,137)" d="M 1673.48 726.678 C 1703.97 742.042 1694.04 770.499 1667.96 783.986 C 1653.05 791.643 1621.63 798.645 1609.92 783.105 C 1608.34 772.824 1610.03 763.928 1616.32 755.404 C 1630.73 735.874 1652 738.05 1673.48 726.678 z"/>
<path transform="translate(0,0)" fill="rgb(212,145,104)" d="M 1609.92 783.105 C 1615.5 782.233 1624.41 771.309 1629.77 766.809 C 1641.26 772.988 1651.89 777.754 1664.58 781.08 C 1665.62 781.352 1667.25 783.195 1667.96 783.986 C 1653.05 791.643 1621.63 798.645 1609.92 783.105 z"/>
<path transform="translate(0,0)" fill="rgb(248,183,137)" d="M 1624.53 700.82 C 1626.47 684.675 1631.84 675.329 1644.4 663.9 C 1658.68 650.92 1703.45 644.236 1697.27 675.374 C 1692.82 697.792 1674.69 711.577 1654.06 720.03 C 1652.84 720.39 1651.6 720.696 1650.35 720.947 C 1644.56 722.131 1638.54 720.897 1633.68 717.532 C 1627.68 713.325 1625.77 707.68 1624.53 700.82 z"/>
<path transform="translate(0,0)" fill="rgb(212,145,104)" d="M 1624.53 700.82 C 1641.34 698.741 1631.87 685.256 1651.36 681.412 L 1652.53 681.855 C 1647.34 696.622 1646.82 705.25 1654.06 720.03 C 1652.84 720.39 1651.6 720.696 1650.35 720.947 C 1644.56 722.131 1638.54 720.897 1633.68 717.532 C 1627.68 713.325 1625.77 707.68 1624.53 700.82 z"/>
<path transform="translate(0,0)" fill="rgb(229,232,232)" d="M 1085.53 757.773 C 1090.22 765.852 1085.89 831.058 1084.11 843.922 C 1082.78 853.574 1079.92 870.913 1078.24 881.216 L 1063.55 843.246 C 1056.27 824.669 1049.75 811.066 1040.07 793.78 C 1043.09 783.354 1044.82 776.699 1045.46 765.899 C 1053.41 772.354 1058.77 776.328 1068.15 780.382 C 1075.82 773.552 1080.03 766.287 1085.53 757.773 z"/>
<path transform="translate(0,0)" fill="rgb(229,232,232)" d="M 1075.3 681.299 C 1075.89 681.295 1076.39 681.745 1076.92 682.007 C 1079.87 691.191 1082.25 709.38 1083.63 719.396 C 1080.1 728.792 1071.25 745.145 1066.57 755.285 C 1061.95 750.513 1057.34 745.552 1052.77 740.72 C 1044.59 731.771 1039.11 728.119 1029.05 721.026 C 1035.03 710.989 1049.43 693.718 1057.74 684.94 C 1064.48 683.886 1068.76 683.28 1075.3 681.299 z"/>
<path transform="translate(0,0)" fill="rgb(248,183,137)" d="M 1617.71 808.295 C 1644.07 807.608 1652.89 806.622 1677.23 795.887 C 1678.64 822.063 1673.17 829.458 1648.68 838.638 C 1635.35 842.601 1602.99 846.16 1608.12 823.209 C 1611.04 817.24 1613.11 813.394 1617.71 808.295 z"/>
<path transform="translate(0,0)" fill="rgb(212,145,104)" d="M 1648.68 838.638 C 1635.35 842.601 1602.99 846.16 1608.12 823.209 C 1617.22 829.425 1624.9 832.205 1635.72 834.105 C 1642.11 835.226 1643.74 834.445 1648.68 838.638 z"/>
<path transform="translate(0,0)" fill="rgb(28,40,51)" d="M 1022.24 1244.62 C 1029.81 1255.72 1048.29 1337.85 1039.74 1344.77 C 1036.76 1343.82 1037.62 1343.96 1035.38 1340.71 C 1026.88 1324.31 1017.24 1307.38 1011.13 1289.98 C 1004.79 1271.93 1013.57 1260.8 1022.24 1244.62 z"/>
<path transform="translate(0,0)" fill="rgb(41,54,68)" d="M 1014.83 735.585 C 1021.33 736.135 1028.2 746.05 1032.22 750.979 C 1030.17 760.154 1023.19 797.498 1014.07 800.972 L 1012.53 799.641 C 1004.49 785.529 998.834 775.276 990.021 761.616 C 999.223 753.679 1006.22 744.346 1014.83 735.585 z"/>
<path transform="translate(0,0)" fill="rgb(229,232,232)" d="M 329.407 1134.6 C 332.94 1135.67 347.845 1147.67 353.054 1150.63 C 378.06 1164.84 406.449 1174.78 435.525 1173.88 C 444.602 1173.6 450.412 1170.73 457.069 1170.37 L 457.948 1171.83 L 456.412 1174.94 C 430.775 1190.11 389.94 1179.69 365.708 1166.38 C 354.104 1160.01 333.651 1147.98 329.407 1134.6 z"/>
<path transform="translate(0,0)" fill="rgb(212,145,104)" d="M 1645.05 386.685 C 1654.76 381.879 1655.67 376.43 1661.55 366.761 C 1662.65 392.358 1662.68 392.409 1688.06 394.521 C 1674.5 401.053 1660.46 404.822 1655.12 420.38 C 1651.03 419.016 1650.76 416.995 1645.77 415.285 L 1643.53 417.472 L 1643.45 413.636 C 1640.48 408.346 1638.79 407.587 1632.92 405.542 C 1627.27 403.774 1627.84 402.858 1622.49 405.933 C 1622.51 403.38 1625.81 401.64 1627.66 400.215 C 1628.95 394.843 1626.97 400.719 1625.17 396.121 C 1629.91 393.973 1631.47 396.237 1633.73 392.665 C 1634.97 390.708 1631.92 391.601 1633.98 389.1 C 1637.07 390.255 1638.14 390.879 1641.5 390.868 C 1644.64 388.728 1643.53 390.092 1645.05 386.685 z"/>
<path transform="translate(0,0)" fill="rgb(251,196,116)" fill-opacity="0.713725" d="M 1622.49 405.933 C 1627.84 402.858 1627.27 403.774 1632.92 405.542 C 1632.41 409.953 1635.19 410.234 1637.29 414.051 C 1638.02 415.388 1633.16 417.921 1633.31 419.969 C 1633.45 421.906 1632.75 424.523 1631.75 426.374 C 1627.23 423.777 1623.1 421.074 1618.73 418.246 C 1619.91 413.235 1620.67 410.751 1622.49 405.933 z"/>
<path transform="translate(0,0)" fill="rgb(251,196,116)" fill-opacity="0.776471" d="M 1632.92 405.542 C 1638.79 407.587 1640.48 408.346 1643.45 413.636 L 1643.53 417.472 C 1644.03 421.893 1644.49 424.568 1644.15 429.026 C 1639.34 429.426 1636.35 427.942 1631.75 426.374 C 1632.75 424.523 1633.45 421.906 1633.31 419.969 C 1633.16 417.921 1638.02 415.388 1637.29 414.051 C 1635.19 410.234 1632.41 409.953 1632.92 405.542 z"/>
</svg>
</file>

<file path="icons/icon128.svg">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" style="display: block;" viewBox="0 0 2048 2048" width="1024" height="1024" preserveAspectRatio="none">
<path transform="translate(0,0)" fill="rgb(54,128,198)" d="M 996.188 459.85 C 942.075 445.796 914.204 386.21 928.122 333.941 C 934.81 307.964 951.727 285.8 975.021 272.498 C 997.251 259.846 1025.4 256.864 1049.97 263.655 C 1075.59 270.941 1097.26 288.142 1110.17 311.45 C 1123.49 335.371 1127.3 364.931 1119.51 391.305 C 1111.74 417.468 1093.89 439.472 1069.89 452.477 C 1063.21 456.068 1057.5 458.086 1050.34 460.576 C 1052.27 490.999 1050.42 530.78 1050.9 562.417 C 1051.16 579.303 1051.86 623.167 1050.29 638.975 L 1383.56 639.131 L 1468.94 639.074 C 1488.78 639.07 1514.62 637.817 1533.8 641.789 C 1580.13 651.383 1619.48 689.963 1629.29 736.396 C 1635.08 763.754 1633.17 796.486 1633.17 824.79 L 1633.02 927.856 C 1645.03 927.55 1657.05 927.448 1669.07 927.55 C 1683.36 927.564 1697.94 926.486 1711.57 931.939 C 1744.84 945.243 1759.6 974.196 1759.53 1008.68 C 1759.4 1066.44 1759.61 1124.06 1759.63 1181.7 L 1759.69 1235.63 C 1759.73 1249.3 1760.32 1263.77 1758.15 1277.25 C 1752.7 1311.17 1720.62 1337.91 1686.06 1335.82 C 1676.83 1335.95 1640.93 1336.91 1633.03 1335.19 C 1633.75 1382.32 1633.54 1430.19 1633.2 1477.39 C 1632.78 1534.34 1643.08 1597.34 1599.22 1641.66 C 1570.95 1670.23 1541.48 1681.55 1502.18 1681.86 L 824.968 1681.84 L 621.224 1681.79 L 563.864 1681.93 C 518.423 1682.04 485.202 1680.21 450.178 1645.78 C 421.599 1617.69 414.046 1587.51 413.923 1548.26 L 413.961 1407.7 C 413.957 1390.1 412.834 1350.85 414.42 1336.04 C 409.899 1334.7 363.747 1336.01 355.547 1336.08 C 342.985 1334.71 333.84 1333 322.739 1326.57 C 281.953 1302.92 288.383 1259.23 288.417 1218.66 L 288.403 1124.69 L 288.381 1038.81 C 288.378 1025.85 287.789 1006.12 289.03 993.716 C 290.908 974.931 302.221 954.145 317.524 942.736 C 338.702 926.945 355.403 927.303 380.689 927.404 C 391.927 927.449 402.615 927.059 414.011 927.63 L 413.968 819.41 C 413.954 764.002 408.26 717.529 451.586 674.597 C 468.619 657.483 490.465 645.967 514.209 641.584 C 531.323 638.255 557.16 639.038 575.236 639.042 L 655.552 639.087 L 875.586 639.114 C 915.12 639.115 956.703 639.734 996.075 638.936 L 996.188 459.85 z M 1507.53 1620.09 C 1538.27 1620.88 1570.2 1598.56 1573.89 1566.55 C 1576.04 1547.88 1575.07 1526.38 1575.07 1507.32 L 1575.06 1430.33 L 1575.05 1131.6 L 1575.04 885.971 C 1575.03 846.283 1575.29 806.567 1575.04 766.905 C 1574.92 747.642 1567.7 731.592 1553.97 718.322 C 1546.75 711.345 1530.49 700.171 1520.42 699.612 C 1494.24 698.159 1467.41 698.783 1441.16 698.766 L 1237.11 698.821 L 773.06 698.827 L 627.992 698.752 C 598.16 698.671 568.312 698.537 538.486 699.031 C 523.143 699.285 514.531 702.412 502.113 710.84 C 469.729 732.816 470.774 767.002 471.09 801.839 C 471.232 817.491 471.092 833.342 471.098 848.964 L 471.145 1031.28 L 471.144 1379.85 L 471.126 1492.29 C 471.073 1548.25 460.077 1604.39 528.878 1620.17 L 1507.53 1620.09 z M 346.076 1262.53 C 348.801 1267.36 349.617 1269.05 353.558 1273.08 C 367.559 1282.13 395.56 1277.43 414.047 1278.63 C 413.984 1256.19 414.695 989.453 413.033 987.751 C 404.132 987.904 392.274 988.334 383.63 987.772 C 341.234 985.015 345.574 1004.44 345.563 1037.72 L 345.734 1095.17 C 345.813 1148.7 344.533 1206.66 345.967 1259.66 C 345.997 1260.62 346.033 1261.58 346.076 1262.53 z M 1633.09 1278.7 C 1651.59 1278.07 1681.98 1282.17 1694.53 1271.49 C 1697.43 1268.03 1700.37 1264.12 1700.64 1259.46 C 1701.38 1246.61 1701.08 1233.02 1701.02 1220.16 L 1700.87 1148.45 L 1700.97 1056.31 C 1701.05 979.507 1707.41 989.746 1633.22 987.789 L 1633.15 1178.59 C 1633.17 1211.01 1633.96 1246.67 1633.09 1278.7 z M 1027.47 403.154 C 1050.34 401.425 1067.53 381.542 1065.92 358.657 C 1064.32 335.772 1044.53 318.482 1021.63 319.963 C 998.565 321.455 981.113 341.431 982.73 364.491 C 984.348 387.552 1004.42 404.896 1027.47 403.154 z"/>
<path transform="translate(0,0)" fill="rgb(18,83,158)" d="M 355.547 1336.08 L 356.707 1333.76 C 365.131 1332.23 405.521 1332.43 414.114 1333.24 L 415.566 1334.37 L 415.117 1335.73 L 414.42 1336.04 C 409.899 1334.7 363.747 1336.01 355.547 1336.08 z"/>
<path transform="translate(0,0)" fill="rgb(18,83,158)" d="M 1633.03 1335.19 C 1634.17 1333.64 1633.64 1333.57 1635.06 1333.44 C 1643.92 1332.66 1678.02 1332.23 1684.65 1333.96 L 1686.06 1335.82 C 1676.83 1335.95 1640.93 1336.91 1633.03 1335.19 z"/>
<path transform="translate(0,0)" fill="rgb(54,128,198)" d="M 1263.81 921.312 C 1333.64 912.429 1397.42 961.886 1406.22 1031.73 C 1415.01 1101.56 1365.47 1165.29 1295.61 1173.99 C 1225.89 1182.67 1162.32 1133.24 1153.54 1063.53 C 1144.77 993.821 1194.11 930.178 1263.81 921.312 z"/>
<path transform="translate(0,0)" fill="rgb(54,128,198)" d="M 749.787 921.894 C 819.364 912.004 883.73 960.541 893.355 1030.15 C 902.981 1099.77 854.201 1163.95 784.551 1173.31 C 715.273 1182.62 651.509 1134.16 641.935 1064.92 C 632.361 995.677 680.582 931.73 749.787 921.894 z"/>
<path transform="translate(0,0)" fill="rgb(54,128,198)" d="M 791.087 1304.3 C 813.766 1303.03 821.472 1323.56 834.205 1338.16 C 929.249 1447.2 1118.99 1446.14 1213.27 1336.61 C 1220.11 1328.66 1225.67 1318.32 1233.66 1311.49 C 1238.1 1307.63 1243.56 1305.12 1249.37 1304.25 C 1257.63 1302.99 1266.04 1305.09 1272.73 1310.09 C 1279.7 1315.4 1284.16 1323.37 1285.03 1332.08 C 1286.9 1349.74 1274.27 1364.65 1263.87 1377.31 C 1222.38 1429.28 1148.23 1465.41 1083.48 1477.06 C 999.906 1492.86 907.146 1475.7 836.739 1427 C 814.095 1411.33 740.859 1352.98 767.638 1316.14 C 772.847 1308.98 782.409 1305.51 791.087 1304.3 z"/>
<path transform="translate(0,0)" fill="rgb(18,83,158)" d="M 528.878 1620.17 L 1507.53 1620.09 C 1505.95 1621.19 1504.04 1622.36 1502.4 1623.42 C 1486.71 1624.6 1463.41 1623.97 1447.16 1623.99 L 1344.6 1624 L 1037.5 1623.49 L 662.916 1623.92 C 644.042 1623.93 540.603 1625.88 529.739 1622.15 L 528.878 1620.17 z"/>
</svg>
</file>

<file path="scripts/generate-icons.js">
/**
 * Generate PNG icons from SVG source.
 */
import sharp from 'sharp';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const iconsDir = path.join(__dirname, '..', 'icons');

const sizes = [16, 48, 128];

// Simple robot icon SVG
const robotSvg = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128">
  <defs>
    <linearGradient id="bg" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#3b82f6"/>
      <stop offset="100%" style="stop-color:#1d4ed8"/>
    </linearGradient>
  </defs>
  <!-- Background -->
  <rect width="128" height="128" rx="24" fill="url(#bg)"/>
  <!-- Robot head -->
  <rect x="28" y="36" width="72" height="64" rx="12" fill="#fff"/>
  <!-- Eyes -->
  <circle cx="48" cy="62" r="10" fill="#1e40af"/>
  <circle cx="80" cy="62" r="10" fill="#1e40af"/>
  <circle cx="50" cy="60" r="4" fill="#fff"/>
  <circle cx="82" cy="60" r="4" fill="#fff"/>
  <!-- Mouth -->
  <rect x="44" y="80" width="40" height="8" rx="4" fill="#1e40af"/>
  <!-- Antenna -->
  <line x1="64" y1="36" x2="64" y2="20" stroke="#fff" stroke-width="4" stroke-linecap="round"/>
  <circle cx="64" cy="16" r="6" fill="#4ade80"/>
</svg>
`;

async function generateIcons() {
  // Ensure icons directory exists
  if (!fs.existsSync(iconsDir)) {
    fs.mkdirSync(iconsDir, { recursive: true });
  }

  for (const size of sizes) {
    const outputPath = path.join(iconsDir, `icon${size}.png`);

    await sharp(Buffer.from(robotSvg))
      .resize(size, size)
      .png()
      .toFile(outputPath);

    console.log(`Generated: ${outputPath}`);
  }

  console.log('Done!');
}

generateIcons().catch(console.error);
</file>

<file path="src/background/tools/index.ts">
/**
 * Tool handlers module index.
 * Re-exports schemas and provides the main handler creation function.
 */

export { schemas, type ToolName, type ToolPayload } from './schemas';
export { isNavigationError, createToolContext, type ToolContext } from './utils';

// The main createToolHandlers function is still in tool-handlers.ts
// It will be migrated to use these extracted modules incrementally
</file>

<file path="src/background/tools/schemas.ts">
/**
 * Zod validation schemas for browser automation tool parameters.
 * Each schema validates the input payload for its corresponding tool.
 */

import { z } from 'zod';

export const schemas = {
  browser_navigate: z.object({
    url: z.string().url(),
  }),

  browser_click: z.object({
    ref: z.string().describe('Element reference from snapshot (e.g., s1e42)'),
    selector: z.string().optional().describe('CSS selector fallback'),
  }),

  browser_type: z.object({
    ref: z.string(),
    text: z.string(),
    clear: z.boolean().optional().default(false),
  }),

  browser_hover: z.object({
    ref: z.string(),
    selector: z.string().optional(),
  }),

  browser_drag: z.object({
    startRef: z.string(),
    endRef: z.string(),
  }),

  browser_select_option: z.object({
    ref: z.string(),
    value: z.string().optional(),
    label: z.string().optional(),
    index: z.number().optional(),
  }),

  browser_press_key: z.object({
    key: z.string().describe('Key name like "Enter", "Tab", "ArrowDown", or "a"'),
  }),

  browser_wait: z.object({
    time: z.number().min(0).max(30).describe('Time to wait in seconds'),
  }),

  browser_new_tab: z.object({
    url: z.string().url(),
  }),

  browser_switch_tab: z.object({
    tabId: z.number(),
  }),

  browser_get_text: z.object({
    ref: z.string(),
  }),

  browser_get_attribute: z.object({
    ref: z.string(),
    attribute: z.string(),
  }),

  browser_wait_for_element: z.object({
    ref: z.string(),
    timeout: z.number().optional().default(10000),
  }),

  browser_highlight: z.object({
    ref: z.string(),
  }),

  browser_is_visible: z.object({
    ref: z.string(),
  }),

  browser_evaluate: z.object({
    code: z.string().describe('JavaScript code to evaluate via CDP (CSP-safe)'),
  }),

  browser_resize_viewport: z.object({
    width: z.number().int().min(320).max(3840),
    height: z.number().int().min(200).max(2160),
  }),

  browser_upload_file: z.object({
    ref: z.string().optional(),
    selector: z.string().optional(),
    filePath: z.string(),
  }),
} as const;

export type ToolName = keyof typeof schemas;
export type ToolPayload<T extends ToolName> = z.infer<typeof schemas[T]>;
</file>

<file path="src/background/tools/utils.ts">
/**
 * Shared utility functions for tool handlers.
 * Contains navigation error detection and other common helpers.
 */

import { log } from '@/utils/logger';
import { CONFIG } from '@/types/config';
import type { TabManager } from '../tab-manager';

/**
 * Check if an error is a navigation-related error (BFCache, port closed, etc).
 * These errors often occur after a successful action that triggers navigation.
 */
export function isNavigationError(error: Error): boolean {
  const msg = error.message.toLowerCase();
  return msg.includes('back/forward cache') ||
         msg.includes('message channel') ||
         msg.includes('port') ||
         msg.includes('closed') ||
         msg.includes('receiving end does not exist');
}

/**
 * Context object passed to tool handlers.
 * Contains dependencies needed for tool execution.
 */
export interface ToolContext {
  tabManager: TabManager;
  sendToContent: <T>(action: string, payload?: Record<string, unknown>) => Promise<T>;
  getSelector: (ref: string) => Promise<string>;
  waitForStable: () => Promise<void>;
  waitForStableOrNavigation: (initialUrl: string) => Promise<{ navigated: boolean; newUrl?: string }>;
  dispatchMouseEvent: (type: string, x: number, y: number, button?: string, clickCount?: number) => Promise<void>;
  dispatchKeyEvent: (type: string, keyDef: { key: string; code: string; keyCode: number }) => Promise<void>;
}

/**
 * Create tool context from a tab manager.
 * This binds all helper functions to the tab manager instance.
 */
export function createToolContext(tabManager: TabManager): ToolContext {
  /**
   * Send message to content script in connected tab.
   */
  async function sendToContent<T>(
    action: string,
    payload: Record<string, unknown> = {}
  ): Promise<T> {
    const tabId = tabManager.getConnectedTabId();
    if (!tabId) {
      throw new Error('No tab connected. Use the popup to connect a tab first.');
    }

    const response = await chrome.tabs.sendMessage(tabId, { action, payload });

    if (!response.success) {
      throw new Error(response.error || 'Content script error');
    }

    return response.data as T;
  }

  /**
   * Get selector for element ref.
   */
  async function getSelector(ref: string): Promise<string> {
    return sendToContent<string>('getSelector', { ref });
  }

  /**
   * Wait for DOM to stabilize after action.
   */
  async function waitForStable(): Promise<void> {
    await sendToContent('waitForDomStable', { timeout: CONFIG.DOM_STABILITY_MS });
  }

  /**
   * Try to wait for DOM stability, handling navigation gracefully.
   * Returns navigated: true if page navigated, false if stable on same page.
   */
  async function waitForStableOrNavigation(initialUrl: string): Promise<{ navigated: boolean; newUrl?: string }> {
    const tabId = tabManager.getConnectedTabId();
    if (!tabId) throw new Error('No tab connected');

    try {
      await waitForStable();
      return { navigated: false };
    } catch (error) {
      if (isNavigationError(error as Error)) {
        // Check if navigation actually occurred
        const currentTab = await chrome.tabs.get(tabId);
        if (currentTab.url !== initialUrl) {
          log.info('[waitForStableOrNavigation] Navigation detected - action succeeded');
          return { navigated: true, newUrl: currentTab.url };
        }
        // Same URL but port closed - might be page refresh or form submit
        log.warn('[waitForStableOrNavigation] Port closed but same URL - assuming success');
        return { navigated: false };
      }
      throw error;
    }
  }

  /**
   * Dispatch mouse event via CDP.
   */
  async function dispatchMouseEvent(
    type: string,
    x: number,
    y: number,
    button: string = 'left',
    clickCount: number = 1
  ): Promise<void> {
    await tabManager.sendDebuggerCommand('Input.dispatchMouseEvent', {
      type,
      x,
      y,
      button,
      clickCount,
    });
  }

  /**
   * Dispatch key event via CDP.
   */
  async function dispatchKeyEvent(
    type: string,
    keyDef: { key: string; code: string; keyCode: number }
  ): Promise<void> {
    await tabManager.sendDebuggerCommand('Input.dispatchKeyEvent', {
      type,
      key: keyDef.key,
      code: keyDef.code,
      windowsVirtualKeyCode: keyDef.keyCode,
      nativeVirtualKeyCode: keyDef.keyCode,
    });
  }

  return {
    tabManager,
    sendToContent,
    getSelector,
    waitForStable,
    waitForStableOrNavigation,
    dispatchMouseEvent,
    dispatchKeyEvent,
  };
}
</file>

<file path="src/background/activity-log.ts">
/**
 * Activity log singleton for tracking extension events.
 * Persists to chrome.storage.local with FIFO eviction.
 */

import type { ActivityEntry, ActivityEntryInput, ActivityLogResponse } from '@/types/activity';

const STORAGE_KEY = 'agent_jake_activity_log';
const MAX_ENTRIES = 100;

class ActivityLog {
  private static instance: ActivityLog;
  private cache: ActivityEntry[] | null = null;

  private constructor() {
    // Private constructor for singleton
  }

  static getInstance(): ActivityLog {
    if (!ActivityLog.instance) {
      ActivityLog.instance = new ActivityLog();
    }
    return ActivityLog.instance;
  }

  /**
   * Add a new activity entry.
   * Auto-generates id and timestamp.
   */
  async addEntry(input: ActivityEntryInput): Promise<ActivityEntry> {
    const entry: ActivityEntry = {
      id: crypto.randomUUID(),
      timestamp: Date.now(),
      ...input,
    };

    const entries = await this.loadEntries();
    entries.unshift(entry); // Add to beginning (newest first)

    // Enforce max entries (FIFO eviction)
    if (entries.length > MAX_ENTRIES) {
      entries.length = MAX_ENTRIES;
    }

    await this.saveEntries(entries);
    return entry;
  }

  /**
   * Get the latest N entries.
   */
  async getLatest(count: number = 5): Promise<ActivityLogResponse> {
    const entries = await this.loadEntries();
    return {
      activities: entries.slice(0, count),
      total: entries.length,
    };
  }

  /**
   * Get all entries.
   */
  async getAll(): Promise<ActivityLogResponse> {
    const entries = await this.loadEntries();
    return {
      activities: entries,
      total: entries.length,
    };
  }

  /**
   * Clear all entries.
   */
  async clear(): Promise<void> {
    this.cache = [];
    await chrome.storage.local.remove(STORAGE_KEY);
  }

  /**
   * Load entries from storage.
   */
  private async loadEntries(): Promise<ActivityEntry[]> {
    if (this.cache !== null) {
      return this.cache;
    }

    try {
      const result = await chrome.storage.local.get(STORAGE_KEY);
      const stored = result[STORAGE_KEY];
      this.cache = Array.isArray(stored) ? stored : [];
      return this.cache;
    } catch (error) {
      console.error('[ActivityLog] Failed to load entries:', error);
      this.cache = [];
      return this.cache;
    }
  }

  /**
   * Save entries to storage.
   */
  private async saveEntries(entries: ActivityEntry[]): Promise<void> {
    this.cache = entries;
    try {
      await chrome.storage.local.set({ [STORAGE_KEY]: entries });
    } catch (error) {
      console.error('[ActivityLog] Failed to save entries:', error);
    }
  }
}

// Export singleton instance
export const activityLog = ActivityLog.getInstance();

// Helper functions for common logging patterns
export function logConnection(action: string, description: string, success: boolean, details?: Record<string, unknown>): Promise<ActivityEntry> {
  return activityLog.addEntry({
    type: 'connection',
    action,
    description,
    success,
    details,
  });
}

export function logTab(action: string, description: string, success: boolean, details?: Record<string, unknown>): Promise<ActivityEntry> {
  return activityLog.addEntry({
    type: 'tab',
    action,
    description,
    success,
    details,
  });
}

export function logTool(action: string, description: string, success: boolean, durationMs?: number, details?: Record<string, unknown>): Promise<ActivityEntry> {
  return activityLog.addEntry({
    type: 'tool',
    action,
    description,
    success,
    durationMs,
    details,
  });
}

export function logError(action: string, description: string, details?: Record<string, unknown>): Promise<ActivityEntry> {
  return activityLog.addEntry({
    type: 'error',
    action,
    description,
    success: false,
    details,
  });
}

export function logAuth(action: string, description: string, success: boolean, durationMs?: number, details?: Record<string, unknown>): Promise<ActivityEntry> {
  return activityLog.addEntry({
    type: 'auth',
    action,
    description,
    success,
    durationMs,
    details,
  });
}

/**
 * Generic log function that accepts full entry input.
 */
export function logActivity(input: Omit<ActivityEntry, 'id' | 'timestamp'>): Promise<ActivityEntry> {
  return activityLog.addEntry(input);
}
</file>

<file path="src/constants/debugger.ts">
/**
 * Chrome Debugger API constants.
 */

export const DEBUGGER = {
  /** Chrome DevTools Protocol version */
  PROTOCOL_VERSION: '1.3',

  /** Storage key for persisting connected tab ID */
  STORAGE_KEY: 'connectedTabId',

  /** Domains to enable after attaching debugger */
  DOMAINS: ['Page', 'DOM', 'Runtime'] as const,
} as const;

export type DebuggerDomain = (typeof DEBUGGER.DOMAINS)[number];
</file>

<file path="src/constants/highlight.ts">
/**
 * Highlight overlay styling constants.
 * Used when highlighting elements on the page.
 */

export const HIGHLIGHT_STYLES = {
  /** Border color for highlight overlay */
  BORDER_COLOR: '#ff4444',

  /** Border width in pixels */
  BORDER_WIDTH: 3,

  /** Background color with opacity */
  BACKGROUND_COLOR: 'rgba(255, 68, 68, 0.2)',

  /** Z-index to ensure overlay is on top */
  Z_INDEX: 2147483647,

  /** Transition duration for animations */
  TRANSITION: '0.2s ease',
} as const;

/**
 * Generate CSS for highlight overlay at given rect position.
 */
export function getHighlightCSS(rect: { top: number; left: number; width: number; height: number }): string {
  return `
    position: fixed;
    top: ${rect.top}px;
    left: ${rect.left}px;
    width: ${rect.width}px;
    height: ${rect.height}px;
    border: ${HIGHLIGHT_STYLES.BORDER_WIDTH}px solid ${HIGHLIGHT_STYLES.BORDER_COLOR};
    background: ${HIGHLIGHT_STYLES.BACKGROUND_COLOR};
    pointer-events: none;
    z-index: ${HIGHLIGHT_STYLES.Z_INDEX};
    transition: all ${HIGHLIGHT_STYLES.TRANSITION};
  `.trim();
}
</file>

<file path="src/constants/index.ts">
/**
 * Central export for all constants.
 * Import from '@/constants' to access all constants.
 */

export * from './timeouts';
export * from './keys';
export * from './highlight';
export * from './debugger';
</file>

<file path="src/constants/keys.ts">
/**
 * Keyboard key definitions for CDP Input.dispatchKeyEvent.
 * Maps key names to their key, code, and keyCode values.
 */

export interface KeyDefinition {
  key: string;
  code: string;
  keyCode: number;
}

export const KEY_DEFINITIONS: Record<string, KeyDefinition> = {
  Enter: { key: 'Enter', code: 'Enter', keyCode: 13 },
  Tab: { key: 'Tab', code: 'Tab', keyCode: 9 },
  Escape: { key: 'Escape', code: 'Escape', keyCode: 27 },
  Backspace: { key: 'Backspace', code: 'Backspace', keyCode: 8 },
  Delete: { key: 'Delete', code: 'Delete', keyCode: 46 },
  ArrowUp: { key: 'ArrowUp', code: 'ArrowUp', keyCode: 38 },
  ArrowDown: { key: 'ArrowDown', code: 'ArrowDown', keyCode: 40 },
  ArrowLeft: { key: 'ArrowLeft', code: 'ArrowLeft', keyCode: 37 },
  ArrowRight: { key: 'ArrowRight', code: 'ArrowRight', keyCode: 39 },
  Home: { key: 'Home', code: 'Home', keyCode: 36 },
  End: { key: 'End', code: 'End', keyCode: 35 },
  PageUp: { key: 'PageUp', code: 'PageUp', keyCode: 33 },
  PageDown: { key: 'PageDown', code: 'PageDown', keyCode: 34 },
  Space: { key: ' ', code: 'Space', keyCode: 32 },
} as const;

/**
 * Get key definition for a key name or character.
 * Falls back to generating definition for single characters.
 */
export function getKeyDefinition(key: string): KeyDefinition {
  if (KEY_DEFINITIONS[key]) {
    return KEY_DEFINITIONS[key];
  }

  // Single character
  if (key.length === 1) {
    const charCode = key.charCodeAt(0);
    const code = key.toUpperCase().match(/[A-Z]/)
      ? `Key${key.toUpperCase()}`
      : `Digit${key}`;

    return { key, code, keyCode: charCode };
  }

  // Unknown key - return as-is
  return { key, code: key, keyCode: 0 };
}
</file>

<file path="src/constants/timeouts.ts">
/**
 * Timeout constants used throughout the extension.
 * Centralizes magic numbers for easier maintenance.
 */

export const TIMEOUTS = {
  /** Duration to show element highlight overlay (ms) */
  HIGHLIGHT_DURATION: 2000,

  /** Time to wait for DOM stability check (ms) */
  DOM_STABILITY_MS: 500,

  /** Maximum wait for debugger commands (ms) */
  DEBUGGER_COMMAND: 25000,

  /** Popup polling interval (ms) */
  POLLING_INTERVAL: 2000,

  /** Keep-alive alarm interval (minutes) */
  KEEPALIVE_MINUTES: 0.2,

  /** WebSocket reconnect delay (ms) */
  WS_RECONNECT_DELAY: 1000,

  /** Request timeout for MCP messages (ms) */
  REQUEST_TIMEOUT: 30000,
} as const;

export type TimeoutKey = keyof typeof TIMEOUTS;
</file>

<file path="src/content/aria/index.ts">
/**
 * ARIA module exports.
 * Provides role constants and utilities for building accessibility trees.
 */

export * from './roles';
</file>

<file path="src/content/aria/roles.ts">
/**
 * ARIA role constants and tag-to-role mappings.
 * Used for building accessibility trees from DOM elements.
 */

/** Roles that can have checked state (aria-checked) */
export const CHECKABLE_ROLES: string[] = [
  'checkbox',
  'radio',
  'menuitemcheckbox',
  'menuitemradio',
  'switch',
];

/** Roles that can be disabled (aria-disabled) */
export const DISABLEABLE_ROLES: string[] = [
  'button',
  'textbox',
  'checkbox',
  'radio',
  'combobox',
  'listbox',
  'slider',
  'spinbutton',
];

/** Roles that can be expanded (aria-expanded) */
export const EXPANDABLE_ROLES: string[] = [
  'button',
  'combobox',
  'listbox',
  'treeitem',
  'row',
];

/** Roles that have levels (aria-level) */
export const LEVELED_ROLES: string[] = [
  'heading',
  'treeitem',
  'listitem',
];

/** Roles that can be selected (aria-selected) */
export const SELECTABLE_ROLES: string[] = [
  'option',
  'tab',
  'treeitem',
  'row',
  'cell',
];

/** Elements that are implicitly interactive */
export const INTERACTIVE_TAGS: string[] = [
  'A',
  'BUTTON',
  'INPUT',
  'SELECT',
  'TEXTAREA',
];

/** Maps HTML tag names to their implicit ARIA roles */
export const TAG_TO_ROLE: Record<string, string> = {
  A: 'link',
  BUTTON: 'button',
  INPUT: 'textbox',
  SELECT: 'combobox',
  TEXTAREA: 'textbox',
  IMG: 'img',
  H1: 'heading',
  H2: 'heading',
  H3: 'heading',
  H4: 'heading',
  H5: 'heading',
  H6: 'heading',
  NAV: 'navigation',
  MAIN: 'main',
  ASIDE: 'complementary',
  HEADER: 'banner',
  FOOTER: 'contentinfo',
  FORM: 'form',
  TABLE: 'table',
  TR: 'row',
  TH: 'columnheader',
  TD: 'cell',
  UL: 'list',
  OL: 'list',
  LI: 'listitem',
  ARTICLE: 'article',
  SECTION: 'region',
};
</file>

<file path="src/content/selector.ts">
/**
 * Builds unique CSS selectors for DOM elements.
 * Prioritizes stable, semantic selectors over position-based ones.
 */

// Attributes to use for selectors (in priority order)
const SELECTOR_ATTRIBUTES = [
  'data-testid',
  'data-test-id',
  'data-test',
  'aria-label',
  'name',
  'id',
  'placeholder',
  'title',
  'alt',
  'role',
  'type',
];

/**
 * Build a unique CSS selector for an element.
 * Returns the shortest selector that uniquely identifies the element.
 */
export function buildSelector(element: Element): string {
  // Try simple strategies first
  const simple = trySimpleSelector(element);
  if (simple && isUnique(simple)) {
    return simple;
  }

  // Build path from element to root
  const path = buildSelectorPath(element);
  return path;
}

/**
 * Try to build a simple, single-part selector.
 */
function trySimpleSelector(element: Element): string | null {
  // Try ID (if it doesn't look auto-generated)
  const id = element.getAttribute('id');
  if (id && isStableId(id)) {
    return `#${escapeSelector(id)}`;
  }

  // Try data-testid
  for (const attr of ['data-testid', 'data-test-id', 'data-test']) {
    const value = element.getAttribute(attr);
    if (value) {
      return `[${attr}="${escapeSelector(value)}"]`;
    }
  }

  // Try unique aria-label
  const ariaLabel = element.getAttribute('aria-label');
  if (ariaLabel && isStableText(ariaLabel)) {
    const selector = `[aria-label="${escapeSelector(ariaLabel)}"]`;
    if (isUnique(selector)) {
      return selector;
    }
  }

  // Try unique name attribute
  const name = element.getAttribute('name');
  if (name) {
    const selector = `[name="${escapeSelector(name)}"]`;
    if (isUnique(selector)) {
      return selector;
    }
  }

  return null;
}

/**
 * Build a selector path from element up to a unique ancestor.
 */
function buildSelectorPath(element: Element): string {
  const parts: string[] = [];
  let current: Element | null = element;
  let attempts = 0;
  const maxAttempts = 10;

  while (current && attempts < maxAttempts) {
    const part = buildElementSelector(current);
    parts.unshift(part);

    // Check if current path is unique
    const selector = parts.join(' > ');
    if (isUnique(selector)) {
      return selector;
    }

    current = current.parentElement;
    attempts++;
  }

  // Fall back to full path if nothing is unique
  return parts.join(' > ');
}

/**
 * Build a selector for a single element.
 */
function buildElementSelector(element: Element): string {
  const tag = element.tagName.toLowerCase();

  // Try attribute-based selectors first
  for (const attr of SELECTOR_ATTRIBUTES) {
    const value = element.getAttribute(attr);
    if (value && isStableValue(attr, value)) {
      return `${tag}[${attr}="${escapeSelector(value)}"]`;
    }
  }

  // Try class-based selector
  const classes = getStableClasses(element);
  if (classes.length > 0) {
    const classSelector = classes.map(c => `.${escapeSelector(c)}`).join('');
    const fullSelector = `${tag}${classSelector}`;
    if (isUniqueAmongSiblings(element, fullSelector)) {
      return fullSelector;
    }
  }

  // Fall back to nth-of-type
  const index = getNthOfType(element);
  return `${tag}:nth-of-type(${index})`;
}

/**
 * Get the nth-of-type index for an element.
 */
function getNthOfType(element: Element): number {
  const parent = element.parentElement;
  if (!parent) {
    return 1;
  }

  const siblings = Array.from(parent.children).filter(
    child => child.tagName === element.tagName
  );

  return siblings.indexOf(element) + 1;
}

/**
 * Check if a selector is unique in the document.
 */
function isUnique(selector: string): boolean {
  try {
    const matches = document.querySelectorAll(selector);
    return matches.length === 1;
  } catch {
    return false;
  }
}

/**
 * Check if a selector is unique among siblings.
 */
function isUniqueAmongSiblings(element: Element, selector: string): boolean {
  const parent = element.parentElement;
  if (!parent) {
    return true;
  }

  try {
    const matches = parent.querySelectorAll(`:scope > ${selector}`);
    return matches.length === 1;
  } catch {
    return false;
  }
}

/**
 * Check if an ID looks stable (not auto-generated).
 */
function isStableId(id: string): boolean {
  // Skip IDs that look auto-generated
  if (/^[a-f0-9]{8,}$/i.test(id)) return false;
  if (/^(ember|react|vue|ng|_|:)/.test(id)) return false;
  if (/\d{5,}/.test(id)) return false;
  if (id.includes('--')) return false;
  return true;
}

/**
 * Check if text is stable (not likely to change).
 */
function isStableText(text: string): boolean {
  // Skip text with many numbers (likely dynamic)
  const numberCount = (text.match(/\d/g) || []).length;
  if (numberCount > 3) return false;

  // Skip very short text
  if (text.length < 2) return false;

  // Skip text that's too long
  if (text.length > 100) return false;

  return true;
}

/**
 * Check if an attribute value is stable.
 */
function isStableValue(attr: string, value: string): boolean {
  // data-test* values are always stable
  if (attr.startsWith('data-test')) {
    return true;
  }

  // IDs might be auto-generated
  if (attr === 'id') {
    return isStableId(value);
  }

  // Text attributes should be stable
  if (['aria-label', 'title', 'placeholder', 'alt'].includes(attr)) {
    return isStableText(value);
  }

  return true;
}

/**
 * Get stable CSS classes from an element.
 */
function getStableClasses(element: Element): string[] {
  const classes = Array.from(element.classList);

  return classes.filter(cls => {
    // Skip utility classes from frameworks
    if (/^(hover:|focus:|active:|sm:|md:|lg:|xl:)/.test(cls)) return false;

    // Skip classes with many numbers
    if (/\d{4,}/.test(cls)) return false;

    // Skip hash-like classes (CSS modules)
    if (/^[a-z]+_[a-zA-Z0-9]{5,}$/.test(cls)) return false;
    if (/^_[a-zA-Z0-9]{6,}$/.test(cls)) return false;

    // Skip single-letter classes
    if (cls.length === 1) return false;

    return true;
  }).slice(0, 3); // Limit to 3 classes
}

/**
 * Escape a string for use in a CSS selector.
 */
function escapeSelector(str: string): string {
  return str.replace(/["\\]/g, '\\$&');
}

/**
 * Find an element using a selector with retry.
 */
export async function findElement(
  selector: string,
  options: {
    timeout?: number;
    visible?: boolean;
    clickable?: boolean;
  } = {}
): Promise<Element> {
  const { timeout = 5000, visible = false, clickable = false } = options;
  const startTime = Date.now();

  while (Date.now() - startTime < timeout) {
    const element = document.querySelector(selector);

    if (element) {
      if (visible && !isElementVisible(element)) {
        await sleep(100);
        continue;
      }

      if (clickable && !isElementClickable(element)) {
        await sleep(100);
        continue;
      }

      return element;
    }

    await sleep(100);
  }

  throw new Error(`Element not found: ${selector}`);
}

/**
 * Check if an element is visible.
 */
export function isElementVisible(element: Element): boolean {
  if (!(element instanceof HTMLElement)) {
    return true;
  }

  const style = window.getComputedStyle(element);

  if (style.display === 'none') return false;
  if (style.visibility === 'hidden') return false;
  if (style.opacity === '0') return false;

  const rect = element.getBoundingClientRect();
  if (rect.width === 0 || rect.height === 0) return false;

  return true;
}

/**
 * Check if an element is clickable (not covered by another element).
 */
export function isElementClickable(element: Element): boolean {
  if (!isElementVisible(element)) {
    return false;
  }

  const rect = element.getBoundingClientRect();
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;

  const topElement = document.elementFromPoint(centerX, centerY);

  if (!topElement) {
    return false;
  }

  return element === topElement || element.contains(topElement);
}

/**
 * Get the center coordinates of an element.
 */
export function getElementCenter(element: Element): { x: number; y: number } {
  const rect = element.getBoundingClientRect();
  return {
    x: Math.round(rect.left + rect.width / 2),
    y: Math.round(rect.top + rect.height / 2),
  };
}

/**
 * Scroll an element into view.
 */
export async function scrollIntoView(element: Element): Promise<void> {
  element.scrollIntoView({
    behavior: 'smooth',
    block: 'center',
    inline: 'center',
  });

  // Wait for scroll to complete
  await sleep(300);
}

function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}
</file>

<file path="src/types/activity.ts">
/**
 * Activity log types for tracking extension events.
 * Used for debugging MCP connections, tool executions, and errors.
 */

export type ActivityType = 'connection' | 'tab' | 'tool' | 'error' | 'auth';

export interface ActivityEntry {
  /** Unique identifier (crypto.randomUUID) */
  id: string;
  /** Unix timestamp in milliseconds */
  timestamp: number;
  /** Category of activity */
  type: ActivityType;
  /** Specific action (e.g., 'ws_connected', 'browser_click') */
  action: string;
  /** Human-readable description */
  description: string;
  /** Additional details (tool payload, error stack, etc.) */
  details?: Record<string, unknown>;
  /** Whether the action succeeded */
  success: boolean;
  /** Duration in milliseconds (for tool executions) */
  durationMs?: number;
}

/** Input for creating a new activity entry (id and timestamp auto-generated) */
export type ActivityEntryInput = Omit<ActivityEntry, 'id' | 'timestamp'>;

/** Activity log query response */
export interface ActivityLogResponse {
  activities: ActivityEntry[];
  total: number;
}
</file>

<file path="src/types/messages.ts">
/**
 * Message types for communication between extension components
 * and the browser-mcp WebSocket server.
 */

// Tool names exposed via MCP
export type ToolName =
  | 'browser_navigate'
  | 'browser_go_back'
  | 'browser_go_forward'
  | 'browser_snapshot'
  | 'browser_click'
  | 'browser_type'
  | 'browser_hover'
  | 'browser_drag'
  | 'browser_select_option'
  | 'browser_press_key'
  | 'browser_wait'
  | 'browser_screenshot'
  | 'browser_get_console_logs'
  // New tools (improvements)
  | 'browser_new_tab'
  | 'browser_list_tabs'
  | 'browser_switch_tab'
  | 'browser_close_tab'
  | 'browser_get_text'
  | 'browser_get_attribute'
  | 'browser_is_visible'
  | 'browser_wait_for_element'
  | 'browser_highlight';

// Messages from browser-mcp server
export interface IncomingMessage {
  id: string;
  type: ToolName;
  payload: Record<string, unknown>;
}

// Response back to browser-mcp server
export interface OutgoingMessage {
  id: string;
  success: boolean;
  result?: unknown;
  error?: {
    code: string;
    message: string;
    details?: Record<string, unknown>;
  };
}

// Internal messages between background and content scripts
export interface ContentScriptRequest {
  action: string;
  payload: Record<string, unknown>;
}

export interface ContentScriptResponse {
  success: boolean;
  data?: unknown;
  error?: string;
}

// ARIA tree node representation
export interface AriaNode {
  role: string;
  name: string;
  ref: string;
  children: (AriaNode | string)[];
  props: Record<string, unknown>;
  checked?: boolean | 'mixed';
  disabled?: boolean;
  expanded?: boolean;
  selected?: boolean;
  level?: number;
}

// Snapshot metadata
export interface Snapshot {
  generation: number;
  elements: Map<number, Element>;
  root: AriaNode;
  timestamp: number;
}

// Tab info for tab management
export interface TabInfo {
  id: number;
  url: string;
  title: string;
  active: boolean;
  connected: boolean;
}

// Viewport coordinates
export interface Coordinates {
  x: number;
  y: number;
}

// Element bounding box
export interface BoundingBox {
  x: number;
  y: number;
  width: number;
  height: number;
}
</file>

<file path="src/utils/logger.ts">
/**
 * Simple logger utility for extension debugging.
 * Prefixes all messages with [AgentJake] for easy filtering.
 */

const PREFIX = '[AgentJake]';

type LogLevel = 'debug' | 'info' | 'warn' | 'error';

const LOG_LEVELS: Record<LogLevel, number> = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
};

// Set minimum log level (can be changed for production)
let minLevel: LogLevel = 'debug';

export function setLogLevel(level: LogLevel): void {
  minLevel = level;
}

function shouldLog(level: LogLevel): boolean {
  return LOG_LEVELS[level] >= LOG_LEVELS[minLevel];
}

function formatArgs(args: unknown[]): unknown[] {
  return args.map(arg => {
    if (arg instanceof Error) {
      return `${arg.message}\n${arg.stack}`;
    }
    if (typeof arg === 'object' && arg !== null) {
      try {
        return JSON.stringify(arg, null, 2);
      } catch {
        return String(arg);
      }
    }
    return arg;
  });
}

export const log = {
  debug: (...args: unknown[]): void => {
    if (shouldLog('debug')) {
      console.debug(PREFIX, ...formatArgs(args));
    }
  },

  info: (...args: unknown[]): void => {
    if (shouldLog('info')) {
      console.info(PREFIX, ...formatArgs(args));
    }
  },

  warn: (...args: unknown[]): void => {
    if (shouldLog('warn')) {
      console.warn(PREFIX, ...formatArgs(args));
    }
  },

  error: (...args: unknown[]): void => {
    if (shouldLog('error')) {
      console.error(PREFIX, ...formatArgs(args));
    }
  },
};
</file>

<file path="test-results/.last-run.json">
{
  "status": "failed",
  "failedTests": []
}
</file>

<file path="tests/unit/aria/roles.test.ts">
/**
 * Unit tests for ARIA role constants.
 * Tests role arrays and tag-to-role mappings from extracted module.
 */

import { describe, it, expect } from 'vitest';
import {
  CHECKABLE_ROLES,
  DISABLEABLE_ROLES,
  EXPANDABLE_ROLES,
  LEVELED_ROLES,
  SELECTABLE_ROLES,
  TAG_TO_ROLE,
} from '@/content/aria/roles';

describe('CHECKABLE_ROLES', () => {
  it('includes checkbox', () => {
    expect(CHECKABLE_ROLES).toContain('checkbox');
  });

  it('includes radio', () => {
    expect(CHECKABLE_ROLES).toContain('radio');
  });

  it('includes switch', () => {
    expect(CHECKABLE_ROLES).toContain('switch');
  });

  it('does not include button', () => {
    expect(CHECKABLE_ROLES).not.toContain('button');
  });
});

describe('DISABLEABLE_ROLES', () => {
  it('includes button', () => {
    expect(DISABLEABLE_ROLES).toContain('button');
  });

  it('includes textbox', () => {
    expect(DISABLEABLE_ROLES).toContain('textbox');
  });

  it('includes combobox', () => {
    expect(DISABLEABLE_ROLES).toContain('combobox');
  });
});

describe('EXPANDABLE_ROLES', () => {
  it('includes combobox', () => {
    expect(EXPANDABLE_ROLES).toContain('combobox');
  });

  it('includes treeitem', () => {
    expect(EXPANDABLE_ROLES).toContain('treeitem');
  });
});

describe('LEVELED_ROLES', () => {
  it('includes heading', () => {
    expect(LEVELED_ROLES).toContain('heading');
  });

  it('includes treeitem', () => {
    expect(LEVELED_ROLES).toContain('treeitem');
  });
});

describe('SELECTABLE_ROLES', () => {
  it('includes option', () => {
    expect(SELECTABLE_ROLES).toContain('option');
  });

  it('includes tab', () => {
    expect(SELECTABLE_ROLES).toContain('tab');
  });
});

describe('TAG_TO_ROLE', () => {
  it('maps A to link', () => {
    expect(TAG_TO_ROLE.A).toBe('link');
  });

  it('maps BUTTON to button', () => {
    expect(TAG_TO_ROLE.BUTTON).toBe('button');
  });

  it('maps INPUT to textbox', () => {
    expect(TAG_TO_ROLE.INPUT).toBe('textbox');
  });

  it('maps SELECT to combobox', () => {
    expect(TAG_TO_ROLE.SELECT).toBe('combobox');
  });

  it('maps all heading tags to heading', () => {
    expect(TAG_TO_ROLE.H1).toBe('heading');
    expect(TAG_TO_ROLE.H2).toBe('heading');
    expect(TAG_TO_ROLE.H3).toBe('heading');
    expect(TAG_TO_ROLE.H4).toBe('heading');
    expect(TAG_TO_ROLE.H5).toBe('heading');
    expect(TAG_TO_ROLE.H6).toBe('heading');
  });

  it('maps semantic landmark elements', () => {
    expect(TAG_TO_ROLE.NAV).toBe('navigation');
    expect(TAG_TO_ROLE.MAIN).toBe('main');
    expect(TAG_TO_ROLE.ASIDE).toBe('complementary');
    expect(TAG_TO_ROLE.HEADER).toBe('banner');
    expect(TAG_TO_ROLE.FOOTER).toBe('contentinfo');
  });

  it('maps table elements', () => {
    expect(TAG_TO_ROLE.TABLE).toBe('table');
    expect(TAG_TO_ROLE.TR).toBe('row');
    expect(TAG_TO_ROLE.TH).toBe('columnheader');
    expect(TAG_TO_ROLE.TD).toBe('cell');
  });

  it('maps list elements', () => {
    expect(TAG_TO_ROLE.UL).toBe('list');
    expect(TAG_TO_ROLE.OL).toBe('list');
    expect(TAG_TO_ROLE.LI).toBe('listitem');
  });
});
</file>

<file path="tests/unit/tools/keyboard.test.ts">
/**
 * Unit tests for keyboard-related tool handlers.
 * Tests getKeyDefinition function from constants.
 */

import { describe, it, expect } from 'vitest';
import { getKeyDefinition, KEY_DEFINITIONS } from '@/constants/keys';

describe('KEY_DEFINITIONS', () => {
  it('includes Enter key', () => {
    expect(KEY_DEFINITIONS.Enter).toEqual({
      key: 'Enter',
      code: 'Enter',
      keyCode: 13,
    });
  });

  it('includes Tab key', () => {
    expect(KEY_DEFINITIONS.Tab).toEqual({
      key: 'Tab',
      code: 'Tab',
      keyCode: 9,
    });
  });

  it('includes Escape key', () => {
    expect(KEY_DEFINITIONS.Escape).toEqual({
      key: 'Escape',
      code: 'Escape',
      keyCode: 27,
    });
  });

  it('includes arrow keys', () => {
    expect(KEY_DEFINITIONS.ArrowUp.keyCode).toBe(38);
    expect(KEY_DEFINITIONS.ArrowDown.keyCode).toBe(40);
    expect(KEY_DEFINITIONS.ArrowLeft.keyCode).toBe(37);
    expect(KEY_DEFINITIONS.ArrowRight.keyCode).toBe(39);
  });

  it('includes Space key with correct key value', () => {
    expect(KEY_DEFINITIONS.Space).toEqual({
      key: ' ',
      code: 'Space',
      keyCode: 32,
    });
  });
});

describe('getKeyDefinition', () => {
  describe('known keys', () => {
    it('returns correct definition for Enter', () => {
      expect(getKeyDefinition('Enter')).toEqual({
        key: 'Enter',
        code: 'Enter',
        keyCode: 13,
      });
    });

    it('returns correct definition for Backspace', () => {
      expect(getKeyDefinition('Backspace')).toEqual({
        key: 'Backspace',
        code: 'Backspace',
        keyCode: 8,
      });
    });

    it('returns correct definition for Delete', () => {
      expect(getKeyDefinition('Delete')).toEqual({
        key: 'Delete',
        code: 'Delete',
        keyCode: 46,
      });
    });
  });

  describe('single character keys', () => {
    it('generates definition for lowercase letter', () => {
      expect(getKeyDefinition('a')).toEqual({
        key: 'a',
        code: 'KeyA',
        keyCode: 97, // ASCII code for 'a'
      });
    });

    it('generates definition for uppercase letter', () => {
      expect(getKeyDefinition('A')).toEqual({
        key: 'A',
        code: 'KeyA',
        keyCode: 65, // ASCII code for 'A'
      });
    });

    it('generates definition for digit', () => {
      expect(getKeyDefinition('5')).toEqual({
        key: '5',
        code: 'Digit5',
        keyCode: 53, // ASCII code for '5'
      });
    });

    it('handles special characters', () => {
      const result = getKeyDefinition('@');
      expect(result.key).toBe('@');
      expect(result.keyCode).toBe(64); // ASCII code for '@'
    });
  });

  describe('unknown keys', () => {
    it('returns fallback for multi-char unknown key', () => {
      expect(getKeyDefinition('F13')).toEqual({
        key: 'F13',
        code: 'F13',
        keyCode: 0,
      });
    });
  });
});
</file>

<file path="tests/unit/tools/utils.test.ts">
/**
 * Unit tests for tool handler utility functions.
 * Tests isNavigationError from the extracted utils module.
 */

import { describe, it, expect } from 'vitest';
import { isNavigationError } from '@/background/tools/utils';

describe('isNavigationError', () => {
  it('detects BFCache errors', () => {
    const error = new Error('The page keeping the extension port is moved into back/forward cache');
    expect(isNavigationError(error)).toBe(true);
  });

  it('detects message channel closed errors', () => {
    const error = new Error('message channel is closed');
    expect(isNavigationError(error)).toBe(true);
  });

  it('detects port closed errors', () => {
    const error = new Error('port closed');
    expect(isNavigationError(error)).toBe(true);
  });

  it('detects receiving end does not exist errors', () => {
    const error = new Error('Could not establish connection. Receiving end does not exist.');
    expect(isNavigationError(error)).toBe(true);
  });

  it('returns false for element not found errors', () => {
    const error = new Error('Element not found: #submit-btn');
    expect(isNavigationError(error)).toBe(false);
  });

  it('returns false for timeout errors', () => {
    const error = new Error('Timeout waiting for element');
    expect(isNavigationError(error)).toBe(false);
  });

  it('returns false for debugger not attached errors', () => {
    const error = new Error('Debugger is not attached to the tab');
    expect(isNavigationError(error)).toBe(false);
  });

  it('is case-insensitive', () => {
    const error = new Error('MESSAGE CHANNEL IS CLOSED');
    expect(isNavigationError(error)).toBe(true);
  });
});
</file>

<file path="tests/unit/tool-schemas.test.ts">
/**
 * Unit tests for MCP tool Zod schemas.
 *
 * Verifies that tool parameter validation matches the PHP driver's expectations.
 * These tests prevent regressions when schemas change.
 */

import { describe, it, expect } from 'vitest';
import { z } from 'zod';

// Mirror schemas from tool-handlers.ts for testing
// (We test the schema shapes, not the actual exports, to catch drift)
const schemas = {
  browser_click: z.object({
    ref: z.string().describe('Element reference from snapshot (e.g., s1e42)'),
    selector: z.string().optional().describe('CSS selector fallback'),
  }),

  browser_type: z.object({
    ref: z.string(),
    text: z.string(),
    clear: z.boolean().optional().default(false),
  }),

  browser_select_option: z.object({
    ref: z.string(),
    value: z.string().optional(),
    label: z.string().optional(),
    index: z.number().optional(),
  }),

  browser_navigate: z.object({
    url: z.string().url(),
  }),

  browser_press_key: z.object({
    key: z.string().describe('Key name like "Enter", "Tab", "ArrowDown", or "a"'),
  }),

  browser_evaluate: z.object({
    code: z.string(),
  }),

  browser_upload_file: z.object({
    ref: z.string().optional(),
    selector: z.string().optional(),
    filePath: z.string(),
  }),
};

describe('browser_click schema', () => {
  const schema = schemas.browser_click;

  it('accepts ref only', () => {
    const result = schema.safeParse({ ref: 's1e42' });
    expect(result.success).toBe(true);
  });

  it('accepts ref with optional selector', () => {
    const result = schema.safeParse({ ref: 's1e42', selector: '#btn' });
    expect(result.success).toBe(true);
  });

  it('rejects missing ref', () => {
    const result = schema.safeParse({});
    expect(result.success).toBe(false);
    if (!result.success) {
      expect(result.error.issues[0].path).toContain('ref');
    }
  });

  it('rejects empty ref', () => {
    const result = schema.safeParse({ ref: '' });
    // Note: Zod string() allows empty by default, but we can test type
    expect(result.success).toBe(true); // Empty string is valid type
  });

  describe('strict mode (deprecated parameter detection)', () => {
    const strictSchema = schema.strict();

    it('rejects "element" parameter (deprecated)', () => {
      const result = strictSchema.safeParse({ ref: 's1e42', element: '#btn' });
      expect(result.success).toBe(false);
    });

    it('rejects "target" parameter (never existed)', () => {
      const result = strictSchema.safeParse({ ref: 's1e42', target: '#btn' });
      expect(result.success).toBe(false);
    });
  });
});

describe('browser_type schema', () => {
  const schema = schemas.browser_type;

  it('accepts ref and text', () => {
    const result = schema.safeParse({ ref: 's1e42', text: 'hello' });
    expect(result.success).toBe(true);
  });

  it('accepts optional clear flag', () => {
    const result = schema.safeParse({ ref: 's1e42', text: 'hello', clear: true });
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data.clear).toBe(true);
    }
  });

  it('defaults clear to false', () => {
    const result = schema.safeParse({ ref: 's1e42', text: 'hello' });
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data.clear).toBe(false);
    }
  });

  it('rejects missing ref', () => {
    const result = schema.safeParse({ text: 'hello' });
    expect(result.success).toBe(false);
  });

  it('rejects missing text', () => {
    const result = schema.safeParse({ ref: 's1e42' });
    expect(result.success).toBe(false);
  });

  describe('strict mode (deprecated parameter detection)', () => {
    const strictSchema = schema.strict();

    it('rejects "element" parameter (deprecated)', () => {
      const result = strictSchema.safeParse({ ref: 's1e42', text: 'hello', element: '#input' });
      expect(result.success).toBe(false);
    });

    it('rejects "submit" parameter (deprecated)', () => {
      const result = strictSchema.safeParse({ ref: 's1e42', text: 'hello', submit: true });
      expect(result.success).toBe(false);
    });
  });
});

describe('browser_select_option schema', () => {
  const schema = schemas.browser_select_option;

  it('accepts ref with value string', () => {
    const result = schema.safeParse({ ref: 's1e42', value: 'option1' });
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data.value).toBe('option1');
    }
  });

  it('accepts ref with label', () => {
    const result = schema.safeParse({ ref: 's1e42', label: 'Option One' });
    expect(result.success).toBe(true);
  });

  it('accepts ref with index', () => {
    const result = schema.safeParse({ ref: 's1e42', index: 0 });
    expect(result.success).toBe(true);
  });

  it('accepts ref alone (no selection specified)', () => {
    const result = schema.safeParse({ ref: 's1e42' });
    expect(result.success).toBe(true);
  });

  it('rejects missing ref', () => {
    const result = schema.safeParse({ value: 'option1' });
    expect(result.success).toBe(false);
  });

  describe('strict mode (deprecated parameter detection)', () => {
    const strictSchema = schema.strict();

    it('rejects "values" array (deprecated - use "value" string)', () => {
      const result = strictSchema.safeParse({ ref: 's1e42', values: ['option1'] });
      expect(result.success).toBe(false);
    });

    it('rejects "element" parameter (deprecated)', () => {
      const result = strictSchema.safeParse({ ref: 's1e42', value: 'option1', element: '#select' });
      expect(result.success).toBe(false);
    });
  });
});

describe('browser_navigate schema', () => {
  const schema = schemas.browser_navigate;

  it('accepts valid URL', () => {
    const result = schema.safeParse({ url: 'https://example.com' });
    expect(result.success).toBe(true);
  });

  it('accepts URL with path', () => {
    const result = schema.safeParse({ url: 'https://example.com/path/to/page' });
    expect(result.success).toBe(true);
  });

  it('rejects invalid URL', () => {
    const result = schema.safeParse({ url: 'not-a-url' });
    expect(result.success).toBe(false);
  });

  it('rejects missing URL', () => {
    const result = schema.safeParse({});
    expect(result.success).toBe(false);
  });
});

describe('browser_press_key schema', () => {
  const schema = schemas.browser_press_key;

  it('accepts key name', () => {
    const result = schema.safeParse({ key: 'Enter' });
    expect(result.success).toBe(true);
  });

  it('accepts single character', () => {
    const result = schema.safeParse({ key: 'a' });
    expect(result.success).toBe(true);
  });

  it('accepts modifier combo', () => {
    const result = schema.safeParse({ key: 'Control+A' });
    expect(result.success).toBe(true);
  });

  it('rejects missing key', () => {
    const result = schema.safeParse({});
    expect(result.success).toBe(false);
  });
});

describe('browser_evaluate schema', () => {
  const schema = schemas.browser_evaluate;

  it('accepts code string', () => {
    const result = schema.safeParse({ code: 'document.title' });
    expect(result.success).toBe(true);
  });

  it('accepts multiline code', () => {
    const result = schema.safeParse({
      code: `
        (function() {
          return document.querySelectorAll('a').length;
        })()
      `,
    });
    expect(result.success).toBe(true);
  });

  it('rejects missing code', () => {
    const result = schema.safeParse({});
    expect(result.success).toBe(false);
  });
});

describe('browser_upload_file schema', () => {
  const schema = schemas.browser_upload_file;

  it('accepts ref and filePath', () => {
    const result = schema.safeParse({ ref: 's1e42', filePath: '/path/to/file.pdf' });
    expect(result.success).toBe(true);
  });

  it('accepts selector and filePath', () => {
    const result = schema.safeParse({ selector: '#file-input', filePath: '/path/to/file.pdf' });
    expect(result.success).toBe(true);
  });

  it('accepts filePath alone (for file dialog)', () => {
    const result = schema.safeParse({ filePath: '/path/to/file.pdf' });
    expect(result.success).toBe(true);
  });

  it('rejects missing filePath', () => {
    const result = schema.safeParse({ ref: 's1e42' });
    expect(result.success).toBe(false);
  });
});

// Schema contract tests - ensure PHP driver expectations are met
describe('PHP driver contract compliance', () => {
  describe('click() parameters', () => {
    it('PHP sends { ref: string }', () => {
      const result = schemas.browser_click.safeParse({ ref: 's1e42' });
      expect(result.success).toBe(true);
    });
  });

  describe('fill() parameters', () => {
    it('PHP sends { ref: string, text: string }', () => {
      const result = schemas.browser_type.safeParse({ ref: 's1e42', text: 'hello' });
      expect(result.success).toBe(true);
    });
  });

  describe('selectOption() parameters', () => {
    it('PHP sends { ref: string, value: string }', () => {
      const result = schemas.browser_select_option.safeParse({ ref: 's1e42', value: 'option1' });
      expect(result.success).toBe(true);
    });
  });

  describe('navigate() parameters', () => {
    it('PHP sends { url: string }', () => {
      const result = schemas.browser_navigate.safeParse({ url: 'https://example.com' });
      expect(result.success).toBe(true);
    });
  });

  describe('press() parameters', () => {
    it('PHP sends { key: string }', () => {
      const result = schemas.browser_press_key.safeParse({ key: 'Enter' });
      expect(result.success).toBe(true);
    });
  });
});
</file>

<file path="tests/extension.spec.ts">
/**
 * Extension integration tests.
 * Tests the extension with Playwright to verify functionality.
 */
import { test, expect, chromium, type BrowserContext } from '@playwright/test';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const EXTENSION_PATH = path.join(__dirname, '..', 'dist');

/**
 * Helper to launch browser with extension loaded.
 */
async function launchWithExtension(): Promise<BrowserContext> {
  const context = await chromium.launchPersistentContext('', {
    headless: false,
    args: [
      `--disable-extensions-except=${EXTENSION_PATH}`,
      `--load-extension=${EXTENSION_PATH}`,
      '--no-sandbox',
    ],
  });

  // Wait for extension to initialize
  await new Promise(resolve => setTimeout(resolve, 1000));

  return context;
}

/**
 * Get the extension ID from the loaded extension.
 */
async function getExtensionId(context: BrowserContext): Promise<string> {
  // Open extensions page
  const page = await context.newPage();
  await page.goto('chrome://extensions');

  // Get extension ID (this is a simplified approach)
  // In real tests, you'd parse the extensions page
  await page.close();

  // For now, we'll get it from service worker
  const workers = context.serviceWorkers();
  for (const worker of workers) {
    const url = worker.url();
    if (url.includes('chrome-extension://')) {
      const match = url.match(/chrome-extension:\/\/([^/]+)/);
      if (match) {
        return match[1];
      }
    }
  }

  throw new Error('Extension ID not found');
}

test.describe('Extension Loading', () => {
  let context: BrowserContext;

  test.beforeAll(async () => {
    context = await launchWithExtension();
  });

  test.afterAll(async () => {
    await context.close();
  });

  test('extension loads successfully', async () => {
    // Check that service worker is running
    const workers = context.serviceWorkers();
    expect(workers.length).toBeGreaterThan(0);

    // Check for our extension's service worker
    const extensionWorker = workers.find(w =>
      w.url().includes('chrome-extension://')
    );
    expect(extensionWorker).toBeDefined();
  });

  test('popup opens', async () => {
    const extensionId = await getExtensionId(context);
    const popupPage = await context.newPage();
    await popupPage.goto(`chrome-extension://${extensionId}/src/popup/index.html`);

    // Check popup elements exist
    await expect(popupPage.locator('h1')).toContainText('Agent Jake');
    await expect(popupPage.locator('#statusText')).toBeVisible();

    await popupPage.close();
  });
});

test.describe('Content Script', () => {
  let context: BrowserContext;

  test.beforeAll(async () => {
    context = await launchWithExtension();
  });

  test.afterAll(async () => {
    await context.close();
  });

  test('content script injects on page load', async () => {
    const page = await context.newPage();
    await page.goto('https://example.com');

    // Check that content script logged its presence
    const logs: string[] = [];
    page.on('console', msg => {
      if (msg.text().includes('[AgentJake]')) {
        logs.push(msg.text());
      }
    });

    // Give content script time to load
    await page.waitForTimeout(1000);

    // Reload to capture the log
    await page.reload();
    await page.waitForTimeout(500);

    expect(logs.some(log => log.includes('Content script loaded'))).toBe(true);

    await page.close();
  });
});

test.describe('ARIA Snapshot', () => {
  let context: BrowserContext;

  test.beforeAll(async () => {
    context = await launchWithExtension();
  });

  test.afterAll(async () => {
    await context.close();
  });

  test('generates snapshot for simple page', async () => {
    const page = await context.newPage();
    await page.goto('https://example.com');
    await page.waitForLoadState('networkidle');

    // Trigger snapshot generation via evaluate
    // Note: In real usage, this would come through the WebSocket
    const snapshot = await page.evaluate(() => {
      return new Promise((resolve, reject) => {
        chrome.runtime.sendMessage(
          { action: 'generateSnapshot' },
          response => {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError);
            } else {
              resolve(response);
            }
          }
        );
      });
    });

    // Basic validation - should have some content
    expect(snapshot).toBeDefined();

    await page.close();
  });
});
</file>

<file path=".gitignore">
# Dependencies
node_modules/

# Build output
dist/

# Environment files
.env
.env.local
.env.*.local

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*

# Test coverage
coverage/

# Chrome extension keys (keep private)
*.pem
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Jacob Chapa

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="playwright.config.ts">
/**
 * Playwright configuration for extension testing.
 */
import { defineConfig } from '@playwright/test';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const extensionPath = path.join(__dirname, 'dist');

export default defineConfig({
  testDir: './tests',
  timeout: 30000,
  retries: 0,
  workers: 1, // Extensions require single worker

  use: {
    headless: false, // Extensions don't work in headless mode
    viewport: { width: 1280, height: 720 },
    actionTimeout: 10000,
  },

  projects: [
    {
      name: 'chromium',
      use: {
        browserName: 'chromium',
        launchOptions: {
          args: [
            `--disable-extensions-except=${extensionPath}`,
            `--load-extension=${extensionPath}`,
            '--no-sandbox',
          ],
        },
      },
    },
  ],
});
</file>

<file path="README.md">
# Agent Jake Browser MCP Extension

A Chrome extension that enables AI agents to automate browser interactions through the Model Context Protocol (MCP).

## Overview

This extension works as a companion to [agent-jake-browser-mcp-server](https://github.com/SnakeO/agent-jake-browser-mcp-server). Together, they provide a complete browser automation solution for AI agents like Claude, enabling them to navigate websites, click elements, fill forms, take screenshots, and more.

## Architecture

```
âââââââââââââââââââ     stdio      âââââââââââââââââââ   WebSocket    ââââââââââââââââââââ
â   AI Agent      âââââââââââââââââºâ   MCP Server    âââââââââââââââââºâ Chrome Extension â
â (Claude, etc.)  â   JSON-RPC     â  (Node.js)      â   port 8765    â  (This project)  â
âââââââââââââââââââ                âââââââââââââââââââ                ââââââââââ¬ââââââââââ
                                                                               â
                                                                               â Chrome
                                                                               â Debugger
                                                                               â API
                                                                               â¼
                                                                      ââââââââââââââââââââ
                                                                      â   Browser Tab    â
                                                                      â  (Any website)   â
                                                                      ââââââââââââââââââââ
```

## Features

- **23 Browser Automation Tools** - Navigate, click, type, screenshot, and more
- **ARIA Accessibility Tree** - Get structured page snapshots for AI understanding
- **Tab Management** - Open, switch, and close browser tabs
- **Console Log Access** - Read browser console messages
- **Visual Debugging** - Highlight elements for debugging

## Installation

### Load as Unpacked Extension

1. Clone this repository:
   ```bash
   git clone https://github.com/SnakeO/agent-jake-browser-mcp-extension.git
   cd agent-jake-browser-mcp-extension
   ```

2. Install dependencies and build:
   ```bash
   npm install
   npm run build
   ```

3. Open Chrome and go to `chrome://extensions/`

4. Enable "Developer mode" (toggle in top right)

5. Click "Load unpacked" and select the `dist/` folder

6. The extension icon should appear in your toolbar

## Usage

1. **Start the MCP Server** - Make sure [agent-jake-browser-mcp-server](https://github.com/SnakeO/agent-jake-browser-mcp-server) is running

2. **Connect a Tab** - Click the extension icon and select a tab to automate

3. **Use with AI** - The AI agent can now control the connected tab

### Popup UI

- **Green dot** - Connected to MCP server and ready
- **Yellow dot** - Tab connected, waiting for server
- **Gray dot** - No tab connected

## Development

```bash
# Install dependencies
npm install

# Development build with watch
npm run dev

# Production build
npm run build

# Type checking
npm run typecheck

# Run E2E tests with Playwright
npm test
```

## Project Structure

```
src/
âââ background/          # Service worker
â   âââ index.ts         # Entry point
â   âââ ws-client.ts     # WebSocket client
â   âââ tab-manager.ts   # Tab connection management
â   âââ tool-handlers/   # Tool implementations
âââ popup/               # Extension popup UI
â   âââ index.html
â   âââ popup.ts
â   âââ popup.css
âââ types/               # Shared TypeScript types
âââ utils/               # Utility functions
```

## Tech Stack

- TypeScript
- Vite + CRXJS (Chrome Extension build)
- Chrome Extension Manifest V3
- Chrome Debugger API (CDP)
- WebSocket for server communication

## Related

- [agent-jake-browser-mcp-server](https://github.com/SnakeO/agent-jake-browser-mcp-server) - MCP server that exposes browser tools to AI agents

## License

MIT - See [LICENSE](LICENSE)
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
</file>

<file path="vite.config.ts">
/**
 * Vite configuration for Chrome extension build.
 * Uses CRXJS plugin for seamless extension development with HMR.
 */
import { defineConfig } from 'vite';
import { crx } from '@crxjs/vite-plugin';
import { resolve } from 'path';
import manifest from './manifest.json';

export default defineConfig({
  plugins: [
    crx({ manifest }),
  ],
  base: './', // Use relative paths for Chrome extension
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
    },
  },
  build: {
    outDir: 'dist',
    rollupOptions: {
      input: {
        popup: resolve(__dirname, 'src/popup/index.html'),
      },
    },
  },
  server: {
    port: 5173,
    strictPort: true,
    hmr: {
      port: 5173,
    },
  },
});
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config';
import { resolve } from 'path';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    include: ['tests/unit/**/*.test.ts'],
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
    },
  },
});
</file>

<file path="src/popup/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Agent Jake Browser MCP</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      /* Core palette - Cyberpunk Noir */
      --bg-deepest: #0a0a12;
      --bg-deep: #12121e;
      --bg-surface: #1a1a2e;
      --bg-elevated: #242442;
      --bg-hover: #2a2a4a;

      /* Accent colors */
      --accent-primary: #00d4ff;
      --accent-primary-dim: rgba(0, 212, 255, 0.15);
      --accent-primary-glow: rgba(0, 212, 255, 0.4);
      --accent-secondary: #a855f7;
      --accent-secondary-dim: rgba(168, 85, 247, 0.15);
      --accent-success: #10b981;
      --accent-success-dim: rgba(16, 185, 129, 0.15);
      --accent-warning: #f59e0b;
      --accent-warning-dim: rgba(245, 158, 11, 0.15);
      --accent-danger: #ef4444;
      --accent-danger-dim: rgba(239, 68, 68, 0.15);

      /* Text */
      --text-primary: #f0f0f5;
      --text-secondary: #8888a0;
      --text-tertiary: #555566;
      --text-accent: var(--accent-primary);

      /* Borders */
      --border-subtle: rgba(255, 255, 255, 0.06);
      --border-default: rgba(255, 255, 255, 0.1);
      --border-accent: var(--accent-primary);

      /* Shadows & Effects */
      --glow-primary: 0 0 20px var(--accent-primary-glow);
      --glow-success: 0 0 15px rgba(16, 185, 129, 0.3);

      /* Radii */
      --radius-sm: 4px;
      --radius-md: 8px;
      --radius-lg: 12px;
      --radius-xl: 16px;

      /* Typography */
      --font-sans: 'DM Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      --font-mono: 'JetBrains Mono', 'Fira Code', monospace;
    }

    body {
      font-family: var(--font-sans);
      width: 340px;
      background: var(--bg-deepest);
      color: var(--text-primary);
      overflow-x: hidden;
    }

    /* Scanline effect overlay */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 0, 0, 0.03) 2px,
        rgba(0, 0, 0, 0.03) 4px
      );
      pointer-events: none;
      z-index: 9999;
    }

    /* Container with gradient border effect */
    .container {
      padding: 20px;
      background: var(--bg-deep);
      min-height: 100vh;
    }

    /* ==================== AUTH SECTION ==================== */
    .auth-section {
      margin-bottom: 20px;
    }

    /* Auth Card - Signed Out State */
    .auth-card {
      background: var(--bg-surface);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      overflow: hidden;
      position: relative;
    }

    .auth-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
    }

    .auth-card-content {
      padding: 20px;
    }

    .auth-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .auth-title-icon {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .auth-title-icon svg {
      width: 14px;
      height: 14px;
      stroke: var(--accent-primary);
    }

    /* Input Group */
    .input-group {
      margin-bottom: 12px;
    }

    .input-label {
      display: block;
      font-size: 11px;
      font-weight: 500;
      color: var(--text-tertiary);
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .input-field {
      width: 100%;
      padding: 12px 14px;
      background: var(--bg-deepest);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-md);
      color: var(--text-primary);
      font-size: 14px;
      font-family: var(--font-sans);
      transition: all 0.2s ease;
      outline: none;
    }

    .input-field::placeholder {
      color: var(--text-tertiary);
    }

    .input-field:focus {
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px var(--accent-primary-dim), var(--glow-primary);
    }

    .input-field.error {
      border-color: var(--accent-danger);
      box-shadow: 0 0 0 3px var(--accent-danger-dim);
    }

    /* Error Message */
    .auth-error {
      display: none;
      padding: 10px 12px;
      background: var(--accent-danger-dim);
      border: 1px solid rgba(239, 68, 68, 0.3);
      border-radius: var(--radius-md);
      color: var(--accent-danger);
      font-size: 12px;
      margin-bottom: 12px;
      animation: shake 0.4s ease;
    }

    .auth-error.visible {
      display: block;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      20%, 60% { transform: translateX(-4px); }
      40%, 80% { transform: translateX(4px); }
    }

    /* Sign In Button */
    .btn-signin {
      width: 100%;
      padding: 14px 20px;
      background: linear-gradient(135deg, var(--accent-primary), #00a8cc);
      border: none;
      border-radius: var(--radius-md);
      color: var(--bg-deepest);
      font-size: 14px;
      font-weight: 600;
      font-family: var(--font-sans);
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .btn-signin:hover {
      transform: translateY(-1px);
      box-shadow: var(--glow-primary);
    }

    .btn-signin:active {
      transform: translateY(0);
    }

    .btn-signin:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    /* Loading state with scanning effect */
    .btn-signin.loading {
      color: transparent;
    }

    .btn-signin.loading::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 200%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(255, 255, 255, 0.4) 50%,
        transparent 100%
      );
      animation: scan 1.5s ease-in-out infinite;
    }

    @keyframes scan {
      0% { transform: translateX(-50%); }
      100% { transform: translateX(50%); }
    }

    .btn-signin .spinner {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      border: 2px solid var(--bg-deepest);
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    .btn-signin.loading .spinner {
      display: block;
    }

    @keyframes spin {
      to { transform: translate(-50%, -50%) rotate(360deg); }
    }

    /* ==================== SIGNED IN STATE ==================== */
    .auth-signed-in {
      display: none;
    }

    .auth-signed-in.visible {
      display: block;
    }

    .user-card {
      background: var(--bg-surface);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      overflow: hidden;
      position: relative;
    }

    .user-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, var(--accent-success), var(--accent-primary));
    }

    .user-info {
      padding: 16px;
      display: flex;
      align-items: center;
      gap: 14px;
    }

    .user-avatar {
      width: 48px;
      height: 48px;
      border-radius: var(--radius-md);
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: 600;
      color: var(--bg-deepest);
      box-shadow: var(--glow-primary);
      text-transform: uppercase;
    }

    .user-details {
      flex: 1;
      min-width: 0;
    }

    .user-name {
      font-size: 15px;
      font-weight: 600;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .user-email {
      font-size: 12px;
      color: var(--text-secondary);
      font-family: var(--font-mono);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-top: 2px;
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      background: var(--accent-success-dim);
      border-radius: 20px;
      font-size: 10px;
      font-weight: 500;
      color: var(--accent-success);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .connection-status.connecting {
      background: var(--accent-warning-dim);
      color: var(--accent-warning);
    }

    .connection-status.offline {
      background: var(--accent-danger-dim);
      color: var(--accent-danger);
    }

    .connection-status.error {
      background: var(--accent-danger-dim);
      color: var(--accent-danger);
    }

    .connection-status.online {
      background: var(--accent-success-dim);
      color: var(--accent-success);
    }

    .connection-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: currentColor;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Inline user action buttons */
    .user-actions-inline {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-left: auto;
    }

    .btn-show-tab {
      padding: 6px 10px;
      background: var(--accent-primary);
      border: none;
      border-radius: var(--radius-sm);
      color: var(--bg-deepest);
      font-size: 10px;
      font-weight: 600;
      font-family: var(--font-sans);
      cursor: pointer;
      transition: all 0.15s ease;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .btn-show-tab:hover {
      box-shadow: var(--glow-primary);
    }

    .btn-show-tab:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      box-shadow: none;
    }

    .btn-disconnect {
      width: 24px;
      height: 24px;
      padding: 0;
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      color: var(--text-tertiary);
      font-size: 14px;
      font-family: var(--font-sans);
      cursor: pointer;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .btn-disconnect:hover {
      background: var(--accent-danger-dim);
      border-color: var(--accent-danger);
      color: var(--accent-danger);
    }

    .btn-disconnect:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .btn-signout-icon {
      width: 24px;
      height: 24px;
      padding: 0;
      background: transparent;
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      color: var(--text-tertiary);
      font-size: 11px;
      font-family: var(--font-sans);
      cursor: pointer;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .btn-signout-icon:hover {
      background: var(--bg-elevated);
      color: var(--text-primary);
    }

    /* Hide auth form when signed in */
    .auth-form.hidden {
      display: none;
    }

    /* ==================== STATUS BAR ==================== */
    .status {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      background: var(--bg-surface);
      border-radius: var(--radius-md);
      margin-bottom: 16px;
      border: 1px solid var(--border-subtle);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-tertiary);
      transition: all 0.3s ease;
    }

    .status-dot.connected {
      background: var(--accent-success);
      box-shadow: var(--glow-success);
    }

    .status-dot.tab-connected {
      background: var(--accent-warning);
    }

    .status-text {
      font-size: 12px;
      color: var(--text-secondary);
      flex: 1;
    }

    /* ==================== SECTIONS ==================== */
    .section {
      margin-bottom: 16px;
    }

    .section-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      color: var(--text-tertiary);
      margin-bottom: 10px;
      letter-spacing: 0.8px;
    }

    /* ==================== BUTTONS ==================== */
    .btn {
      display: block;
      width: 100%;
      padding: 12px 16px;
      border: none;
      border-radius: var(--radius-md);
      font-size: 13px;
      font-weight: 500;
      font-family: var(--font-sans);
      cursor: pointer;
      transition: all 0.15s ease;
      margin-bottom: 8px;
    }

    .btn-primary {
      background: var(--accent-primary);
      color: var(--bg-deepest);
    }

    .btn-primary:hover {
      background: #00b8e6;
      box-shadow: var(--glow-primary);
    }

    .btn-secondary {
      background: var(--bg-elevated);
      color: var(--text-primary);
      border: 1px solid var(--border-default);
    }

    .btn-secondary:hover {
      background: var(--bg-hover);
    }

    .btn-danger {
      background: var(--accent-danger);
      color: white;
    }

    .btn-danger:hover {
      background: #dc2626;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* ==================== TAB LIST ==================== */
    .tab-list {
      max-height: 180px;
      overflow-y: auto;
    }

    .tab-list::-webkit-scrollbar {
      width: 4px;
    }

    .tab-list::-webkit-scrollbar-track {
      background: var(--bg-deepest);
      border-radius: 2px;
    }

    .tab-list::-webkit-scrollbar-thumb {
      background: var(--bg-elevated);
      border-radius: 2px;
    }

    .tab-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: var(--bg-surface);
      border-radius: var(--radius-md);
      margin-bottom: 6px;
      cursor: pointer;
      transition: all 0.15s ease;
      border: 1px solid transparent;
    }

    .tab-item:hover {
      background: var(--bg-elevated);
    }

    .tab-item.active {
      background: var(--accent-primary-dim);
      border-color: var(--accent-primary);
    }

    .tab-favicon {
      width: 18px;
      height: 18px;
      border-radius: var(--radius-sm);
      flex-shrink: 0;
      transition: box-shadow 0.15s ease;
    }

    /* Green ring on connected tab favicon */
    .tab-item.active .tab-favicon {
      box-shadow: 0 0 0 2px var(--accent-success);
    }

    .tab-title {
      flex: 1;
      font-size: 13px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text-primary);
    }

    .connected-badge {
      font-size: 9px;
      padding: 3px 7px;
      background: var(--accent-success);
      color: var(--bg-deepest);
      border-radius: 20px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .current-badge {
      font-size: 9px;
      padding: 3px 7px;
      background: var(--accent-primary-dim);
      color: var(--accent-primary);
      border-radius: 20px;
      font-weight: 500;
      text-transform: uppercase;
    }

    /* ==================== ACTIVITY LOG ==================== */
    .activity-section {
      margin-bottom: 16px;
    }

    .activity-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .activity-header .section-title {
      margin-bottom: 0;
    }

    .activity-actions {
      display: flex;
      gap: 6px;
    }

    .activity-btn {
      background: transparent;
      border: none;
      color: var(--text-tertiary);
      cursor: pointer;
      padding: 4px 8px;
      font-size: 11px;
      font-family: var(--font-mono);
      border-radius: var(--radius-sm);
      transition: all 0.15s ease;
    }

    .activity-btn:hover {
      color: var(--text-primary);
      background: var(--bg-elevated);
    }

    .activity-log {
      font-family: var(--font-mono);
      font-size: 11px;
      background: var(--bg-deepest);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      overflow: hidden;
    }

    .activity-log:empty::before {
      content: 'No activity yet...';
      display: block;
      padding: 16px;
      color: var(--text-tertiary);
      text-align: center;
      font-style: italic;
    }

    .activity-entry {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border-subtle);
    }

    .activity-entry:last-child {
      border-bottom: none;
    }

    .activity-entry.error {
      background: var(--accent-danger-dim);
    }

    .activity-time {
      color: var(--text-tertiary);
      font-size: 10px;
    }

    .activity-type {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: var(--radius-sm);
      background: var(--bg-elevated);
      color: var(--text-secondary);
      text-transform: uppercase;
      font-weight: 500;
    }

    .activity-entry[data-type="connection"] .activity-type {
      background: var(--accent-primary-dim);
      color: var(--accent-primary);
    }

    .activity-entry[data-type="tool"] .activity-type {
      background: var(--accent-secondary-dim);
      color: var(--accent-secondary);
    }

    .activity-entry[data-type="tab"] .activity-type {
      background: var(--accent-success-dim);
      color: var(--accent-success);
    }

    .activity-entry[data-type="error"] .activity-type {
      background: var(--accent-danger-dim);
      color: var(--accent-danger);
    }

    .activity-entry[data-type="auth"] .activity-type {
      background: var(--accent-warning-dim);
      color: var(--accent-warning);
    }

    .activity-spacer {
      flex: 1;
    }

    .activity-desc {
      color: var(--text-secondary);
      word-break: break-word;
      line-height: 1.4;
    }

    .activity-duration {
      color: var(--text-tertiary);
      font-size: 10px;
    }

    .activity-icon {
      font-size: 10px;
    }

    .activity-entry.success .activity-icon {
      color: var(--accent-success);
    }

    .activity-entry.error .activity-icon {
      color: var(--accent-danger);
    }

    .activity-see-more {
      display: block;
      width: 100%;
      padding: 10px;
      background: var(--bg-surface);
      border: none;
      border-top: 1px solid var(--border-subtle);
      color: var(--accent-primary);
      font-size: 11px;
      font-family: var(--font-mono);
      cursor: pointer;
      transition: background 0.15s ease;
    }

    .activity-see-more:hover {
      background: var(--bg-elevated);
    }

    /* ==================== MODAL ==================== */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(4px);
      display: none;
      align-items: flex-end;
      justify-content: center;
      z-index: 1000;
    }

    .modal-overlay.open {
      display: flex;
    }

    .modal-content {
      width: 100%;
      max-height: 80%;
      background: var(--bg-deep);
      border-radius: var(--radius-xl) var(--radius-xl) 0 0;
      border: 1px solid var(--border-subtle);
      border-bottom: none;
      animation: modalSlideUp 0.25s ease-out;
      display: flex;
      flex-direction: column;
    }

    @keyframes modalSlideUp {
      from {
        transform: translateY(100%);
      }
      to {
        transform: translateY(0);
      }
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-subtle);
    }

    .modal-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .modal-close {
      background: transparent;
      border: none;
      color: var(--text-tertiary);
      font-size: 20px;
      cursor: pointer;
      padding: 4px 8px;
      line-height: 1;
      transition: color 0.15s ease;
    }

    .modal-close:hover {
      color: var(--text-primary);
    }

    .modal-filters {
      display: flex;
      gap: 6px;
      padding: 12px 20px;
      border-bottom: 1px solid var(--border-subtle);
      overflow-x: auto;
    }

    .filter-btn {
      padding: 6px 12px;
      font-size: 11px;
      font-family: var(--font-mono);
      background: var(--bg-elevated);
      border: 1px solid var(--border-default);
      border-radius: 20px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s ease;
      white-space: nowrap;
    }

    .filter-btn:hover {
      color: var(--text-primary);
    }

    .filter-btn.active {
      background: var(--accent-primary);
      border-color: var(--accent-primary);
      color: var(--bg-deepest);
    }

    .modal-body {
      flex: 1;
      overflow-y: auto;
      font-family: var(--font-mono);
      font-size: 11px;
    }

    .modal-body .activity-entry {
      cursor: pointer;
    }

    .modal-body .activity-entry:hover {
      background: var(--bg-surface);
    }

    .activity-details {
      display: none;
      padding: 10px 12px;
      margin-top: 6px;
      background: var(--bg-deepest);
      border-radius: var(--radius-md);
      font-size: 10px;
      color: var(--text-tertiary);
      white-space: pre-wrap;
      word-break: break-all;
      border: 1px solid var(--border-subtle);
    }

    .activity-entry.expanded .activity-details {
      display: block;
    }

    /* ==================== FOOTER ==================== */
    .footer {
      padding-top: 16px;
      border-top: 1px solid var(--border-subtle);
      font-size: 10px;
      color: var(--text-tertiary);
      text-align: center;
      font-family: var(--font-mono);
    }

    .footer a {
      color: var(--accent-primary);
      text-decoration: none;
      transition: color 0.15s ease;
    }

    .footer a:hover {
      color: var(--text-primary);
    }

    /* ==================== UTILITIES ==================== */
    .hidden {
      display: none !important;
    }

    /* Auth required overlay for browser controls */
    .auth-required-overlay {
      position: relative;
    }

    .auth-required-overlay::after {
      content: 'Sign in to connect';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg-deep);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-tertiary);
      font-size: 12px;
      border-radius: var(--radius-md);
      opacity: 0.95;
    }

    .auth-required-overlay.authenticated::after {
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Auth Section -->
    <div class="auth-section">
      <!-- Sign In Form (shown when not authenticated) -->
      <div class="auth-card auth-form" id="authForm">
        <div class="auth-card-content">
          <div class="auth-title">
            <span class="auth-title-icon">
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M16.5 10.5V6.75a4.5 4.5 0 10-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 002.25-2.25v-6.75a2.25 2.25 0 00-2.25-2.25H6.75a2.25 2.25 0 00-2.25 2.25v6.75a2.25 2.25 0 002.25 2.25z" />
              </svg>
            </span>
            Sign In to Sortie
          </div>

          <div class="auth-error" id="authError"></div>

          <div class="input-group">
            <label class="input-label" for="email">Email</label>
            <input
              type="email"
              id="email"
              class="input-field"
              placeholder="you@example.com"
              autocomplete="email"
            >
          </div>

          <div class="input-group">
            <label class="input-label" for="password">Password</label>
            <input
              type="password"
              id="password"
              class="input-field"
              placeholder="â¢â¢â¢â¢â¢â¢â¢â¢"
              autocomplete="current-password"
            >
          </div>

          <button class="btn-signin" id="signinBtn" type="button">
            <span class="btn-text">Sign In</span>
            <div class="spinner"></div>
          </button>
        </div>
      </div>

      <!-- Signed In State -->
      <div class="auth-signed-in" id="authSignedIn">
        <div class="user-card">
          <div class="user-info">
            <div class="user-avatar" id="userAvatar">?</div>
            <div class="user-details">
              <div class="user-name" id="userName">Loading...</div>
              <div class="user-email" id="userEmail">...</div>
            </div>
            <div class="user-actions-inline">
              <button class="btn-show-tab" id="showTabBtn" title="Show connected tab" disabled>Show Tab</button>
              <button class="btn-disconnect" id="disconnectInlineBtn" title="Disconnect from tab" disabled>Ã</button>
              <button class="btn-signout-icon" id="signoutBtn" title="Sign out">â»</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- MCP Status -->
    <div class="status">
      <div class="status-dot" id="statusDot"></div>
      <span class="status-text" id="statusText">Checking...</span>
    </div>

    <!-- Tab Connection Section (requires auth) -->
    <div class="section auth-required-overlay" id="connectSection">
      <div class="section-title">Connect to Tab</div>
      <div class="tab-list" id="tabList">
        Loading tabs...
      </div>
    </div>

    <!-- Connected Tab Actions -->
    <div class="section hidden" id="connectedSection">
      <button class="btn btn-secondary" id="focusBtn">Focus Connected Tab</button>
      <button class="btn btn-danger" id="disconnectBtn">Disconnect</button>
    </div>

    <!-- Activity Log -->
    <div class="activity-section">
      <div class="activity-header">
        <div class="section-title">Activity</div>
        <div class="activity-actions">
          <button class="activity-btn" id="clearActivityBtn" title="Clear">Clear</button>
          <button class="activity-btn" id="refreshActivityBtn" title="Refresh">â»</button>
        </div>
      </div>
      <div class="activity-log" id="activityLog"></div>
      <button class="activity-see-more hidden" id="seeMoreBtn">
        See More (<span id="activityTotal">0</span> total)
      </button>
    </div>

    <!-- Activity Modal -->
    <div class="modal-overlay" id="activityModal">
      <div class="modal-content">
        <div class="modal-header">
          <div class="modal-title">Activity Log</div>
          <button class="modal-close" id="modalClose">Ã</button>
        </div>
        <div class="modal-filters">
          <button class="filter-btn active" data-filter="all">All</button>
          <button class="filter-btn" data-filter="auth">Auth</button>
          <button class="filter-btn" data-filter="connection">Connection</button>
          <button class="filter-btn" data-filter="tab">Tab</button>
          <button class="filter-btn" data-filter="tool">Tool</button>
          <button class="filter-btn" data-filter="error">Error</button>
        </div>
        <div class="modal-body" id="modalActivityLog"></div>
      </div>
    </div>

    <!-- Footer -->
    <div class="footer">
      WebSocket: localhost:8765 Â· Reverb: localhost:8085 Â· <a href="https://github.com/SnakeO/agent-jake-browser-mcp-extension" target="_blank">Docs</a>
    </div>
  </div>

  <script src="popup.ts" type="module"></script>
</body>
</html>
</file>

<file path="src/types/config.ts">
/**
 * Extension configuration constants.
 */

export const CONFIG = {
  // Laravel API server
  // For local testing: 'http://localhost:8000'
  // For remote/ngrok: 'https://jakes.ngrok.pizza'
  API_URL: 'http://localhost:8000',

  // Laravel Reverb WebSocket server
  // For local testing: 'localhost'
  // For remote: must match API domain or use separate ngrok tunnel
  REVERB_HOST: 'localhost',
  REVERB_PORT: 8085,
  REVERB_APP_KEY: 'sortie-extension-key',

  // WebSocket connection to browser-mcp server (local only)
  WS_PORT: 8765,
  WS_HOST: 'localhost',

  // Reconnection settings
  RECONNECT_INTERVAL_MS: 5000,  // Check every 5 seconds (fixed, no backoff)
  MAX_RECONNECT_ATTEMPTS: 0,    // 0 = unlimited retries

  // Timeouts
  MESSAGE_TIMEOUT_MS: 30000,
  ELEMENT_WAIT_TIMEOUT_MS: 10000,
  DOM_STABILITY_MS: 500,

  // Retry settings
  MAX_RETRIES: 3,
  RETRY_DELAY_MS: 500,

  // Snapshot settings
  MAX_SNAPSHOT_AGE_MS: 30000,
  MAX_NAME_LENGTH: 500,

  // Error codes
  ERRORS: {
    NO_TAB: 'NO_CONNECTED_TAB',
    STALE_REF: 'STALE_ELEMENT_REF',
    NOT_FOUND: 'ELEMENT_NOT_FOUND',
    NOT_VISIBLE: 'ELEMENT_NOT_VISIBLE',
    NOT_CLICKABLE: 'ELEMENT_NOT_CLICKABLE',
    TIMEOUT: 'OPERATION_TIMEOUT',
    WS_DISCONNECTED: 'WEBSOCKET_DISCONNECTED',
  },
} as const;

export type ErrorCode = typeof CONFIG.ERRORS[keyof typeof CONFIG.ERRORS];
</file>

<file path="src/background/index.ts">
/**
 * Background service worker entry point.
 * Manages WebSocket connection to browser-mcp and routes tool calls.
 *
 * Uses chrome.alarms API to keep the service worker alive when a tab is connected.
 * Manifest V3 service workers can go to sleep after ~30 seconds of inactivity,
 * which would kill the WebSocket connection to browser-mcp.
 */

// MUST be first import - polyfills window/document for service worker context
import './sw-polyfill';

import { WebSocketClient } from './ws-client';
import { TabManager } from './tab-manager';
import { createToolHandlers, executeToolFromReverb } from './tool-handlers';
import { activityLog } from './activity-log';
import { authService, AuthState } from './auth-service';
import { reverbClient, BrowserCommand } from './reverb-client';
import { log } from '@/utils/logger';
import { CONFIG } from '@/types/config';

// Keep-alive alarm name - fires every 12 seconds to prevent service worker sleep
const KEEPALIVE_ALARM = 'keepalive';
const KEEPALIVE_INTERVAL_MINUTES = 0.2; // 12 seconds

// Singleton instances
let wsClient: WebSocketClient | null = null;
let tabManager: TabManager | null = null;

/**
 * Initialize the extension.
 */
async function initialize(): Promise<void> {
  log.info('Initializing Agent Jake Browser MCP Extension');

  // Create tab manager
  tabManager = new TabManager();
  await tabManager.initialize();

  // Create WebSocket client (for local MCP server)
  wsClient = new WebSocketClient(CONFIG.WS_PORT);

  // Create tool handlers
  const handleMessage = createToolHandlers(tabManager);
  wsClient.setMessageHandler(handleMessage);

  // Set up Reverb command handler (for remote Laravel commands)
  reverbClient.setCommandHandler(async (command: BrowserCommand) => {
    return executeToolFromReverb(tabManager!, command.type, command.payload);
  });

  // Initialize auth service (restores session from storage, connects to Reverb if authenticated)
  await authService.initialize();
  log.info('Auth service initialized');

  // Start connection loop for local MCP
  startConnectionLoop();

  log.info('Extension initialized');
}

/**
 * Start or stop the keep-alive alarm based on whether a tab is connected.
 * The alarm prevents the service worker from going to sleep.
 */
async function updateKeepAliveAlarm(): Promise<void> {
  const tabId = tabManager?.getConnectedTabId();

  if (tabId) {
    // Tab connected - start keep-alive alarm
    const existing = await chrome.alarms.get(KEEPALIVE_ALARM);
    if (!existing) {
      await chrome.alarms.create(KEEPALIVE_ALARM, {
        periodInMinutes: KEEPALIVE_INTERVAL_MINUTES,
      });
      log.info('[KeepAlive] Alarm started - service worker will stay awake');
    }
  } else {
    // No tab connected - stop keep-alive alarm to allow service worker to sleep
    await chrome.alarms.clear(KEEPALIVE_ALARM);
    log.debug('[KeepAlive] Alarm cleared - no connected tab');
  }
}

/**
 * Handle keep-alive alarm - triggers connection check.
 */
chrome.alarms.onAlarm.addListener((alarm) => {
  if (alarm.name === KEEPALIVE_ALARM) {
    log.debug('[KeepAlive] Alarm fired - checking connection');
    tryConnect();
  }
});

/**
 * Try to connect to browser-mcp if we have a connected tab.
 */
async function tryConnect(): Promise<void> {
  if (!wsClient) return;

  const tabId = tabManager?.getConnectedTabId();
  const wsConnected = wsClient?.isConnected();
  log.debug(`[Loop] tryConnect - tabId: ${tabId}, wsConnected: ${wsConnected}`);

  // Only connect if we have a connected tab
  if (!tabId) {
    log.debug('[Loop] No connected tab, skipping WebSocket connection');
    return;
  }

  if (!wsConnected) {
    log.info('[Loop] Not connected, attempting WebSocket connect...');
    try {
      await wsClient.connect();
      log.info('[Loop] Connected to browser-mcp');
    } catch (error) {
      log.warn(`[Loop] Connect failed: ${(error as Error).message}`);
    }
  }
}

/**
 * Connection loop - keeps trying to connect to browser-mcp.
 */
async function startConnectionLoop(): Promise<void> {
  if (!wsClient) return;

  // Try immediately
  await tryConnect();

  // Update keep-alive alarm based on current state
  await updateKeepAliveAlarm();

  // Also poll every 5 seconds as backup (in case alarm fails)
  setInterval(tryConnect, CONFIG.RECONNECT_INTERVAL_MS);
}

/**
 * Handle messages from popup.
 */
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  // Log all incoming messages for debugging
  log.debug('Message received, url:', sender.url, 'action:', message?.action);

  // Check if message is from our extension pages (popup, etc.)
  // When popup is opened as a page (Playwright), sender.tab is set but URL is still chrome-extension://
  const isFromExtension = sender.url?.startsWith('chrome-extension://');
  const isFromContentScript = sender.tab && !isFromExtension;

  if (isFromContentScript) {
    // Message from content script in a regular web page - handle separately
    // Don't return false - just don't respond to popup-style messages
    return;
  }

  // This is from popup or other extension page
  (async () => {
    try {
      const response = await handlePopupMessage(message);
      log.debug('Sending popup response');
      sendResponse(response);
    } catch (error) {
      log.error('Message handler error:', error);
      sendResponse({ success: false, error: (error as Error).message });
    }
  })();

  return true; // Keep sendResponse channel open for async response
});

/**
 * Handle popup messages.
 */
async function handlePopupMessage(message: {
  action: string;
  payload?: unknown;
}): Promise<unknown> {
  const { action, payload } = message;

  switch (action) {
    case 'getStatus': {
      // Ensure tabManager is initialized before accessing
      const tabs = tabManager ? await tabManager.listTabs() : [];
      return {
        connected: wsClient?.isConnected() || false,
        tabId: tabManager?.getConnectedTabId() || null,
        tabs,
      };
    }

    case 'connectTab': {
      const { tabId, tabUrl } = payload as { tabId: number; tabUrl?: string };
      await tabManager?.connectTab(tabId, tabUrl);
      // Reset reconnect counter and try to connect immediately
      wsClient?.resetReconnectAttempts();
      wsClient?.connect().catch(() => {}); // Fire and forget
      // Start keep-alive alarm to prevent service worker sleep
      await updateKeepAliveAlarm();
      return { success: true };
    }

    case 'disconnectTab': {
      await tabManager?.disconnectTab();
      wsClient?.disconnect();
      // Stop keep-alive alarm
      await updateKeepAliveAlarm();
      return { success: true };
    }

    case 'getActivity': {
      try {
        const { limit } = (payload as { limit?: number }) || {};
        if (limit) {
          return await activityLog.getLatest(limit);
        }
        return await activityLog.getAll();
      } catch (error) {
        log.error('Failed to get activity:', error);
        // Return empty response on error
        return { activities: [], total: 0 };
      }
    }

    case 'clearActivity': {
      await activityLog.clear();
      return { success: true };
    }

    // Auth actions
    case 'getAuthState': {
      return authService.getState();
    }

    case 'login': {
      const { email, password } = payload as { email: string; password: string };
      return await authService.login(email, password);
    }

    case 'logout': {
      await authService.logout();
      return { success: true };
    }

    default:
      throw new Error(`Unknown action: ${action}`);
  }
}

/**
 * Handle extension install/update.
 */
chrome.runtime.onInstalled.addListener((details) => {
  log.info(`Extension installed: ${details.reason}`);
});

/**
 * Handle debugger detach.
 * Attempts to reattach if it wasn't user-initiated.
 */
chrome.debugger.onDetach.addListener(async (source, reason) => {
  log.warn(`Debugger detached from tab ${source.tabId}: ${reason}`);

  // Mark debugger as detached in TabManager
  tabManager?.markDebuggerDetached();

  // If it's our connected tab and reason isn't user-initiated, try to reattach
  const connectedTabId = tabManager?.getConnectedTabId();
  if (source.tabId === connectedTabId && reason !== 'canceled_by_user') {
    // Small delay to let Chrome settle
    await new Promise(resolve => setTimeout(resolve, 500));

    try {
      await tabManager?.reattachDebugger();
      log.info('[onDetach] Debugger reattached successfully');
    } catch (error) {
      log.error('[onDetach] Failed to reattach debugger:', error);
      // Don't throw - the next tool call will try again via sendDebuggerCommand
    }
  }
});

// Initialize on load
console.log('========================================');
console.log('Agent Jake Browser MCP Extension v2.0.3');
console.log('========================================');
initialize().catch(error => {
  log.error('Failed to initialize:', error);
});

// Expose debug helpers for service worker console
(globalThis as Record<string, unknown>).__debug = {
  getStatus: () => ({
    wsConnected: wsClient?.isConnected(),
    tabId: tabManager?.getConnectedTabId(),
    reconnectAttempts: (wsClient as unknown as { reconnectAttempts?: number })?.reconnectAttempts,
  }),
  forceConnect: () => wsClient?.connect(),
  forceDisconnect: () => wsClient?.disconnect(),
  resetReconnect: () => wsClient?.resetReconnectAttempts(),
};
</file>

<file path="src/background/ws-client.ts">
/**
 * WebSocket client for connecting to browser-mcp server.
 * Handles connection lifecycle, reconnection, and message routing.
 */

import { CONFIG } from '@/types/config';
import { log } from '@/utils/logger';
import { logConnection, logError } from './activity-log';
import type { IncomingMessage, OutgoingMessage } from '@/types/messages';

type MessageHandler = (message: IncomingMessage) => Promise<OutgoingMessage>;

interface PendingRequest {
  resolve: (value: unknown) => void;
  reject: (error: Error) => void;
  timeout: ReturnType<typeof setTimeout>;
}

export class WebSocketClient {
  private socket: WebSocket | null = null;
  private messageHandler: MessageHandler | null = null;
  private reconnectAttempts = 0;
  private reconnectTimer: ReturnType<typeof setTimeout> | null = null;
  private pendingRequests = new Map<string, PendingRequest>();
  private isConnecting = false;
  private shouldReconnect = true;

  constructor(private port: number = CONFIG.WS_PORT) {}

  /**
   * Set the handler for incoming tool requests.
   */
  setMessageHandler(handler: MessageHandler): void {
    this.messageHandler = handler;
  }

  /**
   * Reset reconnect counter (call when user initiates new connection).
   */
  resetReconnectAttempts(): void {
    this.reconnectAttempts = 0;
    log.info('[WS] Reconnect attempts counter reset');
  }

  /**
   * Connect to the browser-mcp WebSocket server.
   */
  async connect(): Promise<void> {
    log.info(`[WS] connect() called, current state: ${this.socket?.readyState ?? 'no socket'}, attempts: ${this.reconnectAttempts}`);

    if (this.socket?.readyState === WebSocket.OPEN) {
      log.debug('[WS] Already connected');
      return;
    }

    if (this.isConnecting) {
      log.debug('[WS] Connection in progress');
      return;
    }

    this.isConnecting = true;
    this.shouldReconnect = true;

    return new Promise((resolve, reject) => {
      try {
        const url = `ws://${CONFIG.WS_HOST}:${this.port}`;
        log.info(`Connecting to ${url}`);

        this.socket = new WebSocket(url);

        this.socket.onopen = () => {
          log.info('WebSocket connected');
          this.isConnecting = false;
          this.reconnectAttempts = 0;
          logConnection('ws_connect', `Connected to browser-mcp on port ${this.port}`, true, { port: this.port });
          resolve();
        };

        this.socket.onclose = (event) => {
          log.info(`WebSocket closed: ${event.code} ${event.reason}`);
          this.isConnecting = false;
          this.socket = null;
          logConnection('ws_close', `WebSocket closed: ${event.code} ${event.reason || 'No reason'}`, true, { code: event.code, reason: event.reason });
          this.handleDisconnect();
        };

        this.socket.onerror = (error) => {
          log.error('WebSocket error:', error);
          this.isConnecting = false;
          logError('ws_error', 'WebSocket connection error', { error: String(error) });
          if (this.reconnectAttempts === 0) {
            reject(new Error('Failed to connect to browser-mcp'));
          }
        };

        this.socket.onmessage = (event) => {
          this.handleMessage(event.data);
        };
      } catch (error) {
        this.isConnecting = false;
        reject(error);
      }
    });
  }

  /**
   * Disconnect from the server.
   */
  disconnect(): void {
    this.shouldReconnect = false;

    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    if (this.socket) {
      this.socket.close(1000, 'Client disconnect');
      this.socket = null;
    }

    // Reject all pending requests
    const pendingCount = this.pendingRequests.size;
    for (const [id, pending] of this.pendingRequests) {
      clearTimeout(pending.timeout);
      pending.reject(new Error('WebSocket disconnected'));
    }
    this.pendingRequests.clear();

    log.info('Disconnected');
    logConnection('ws_disconnect', 'WebSocket disconnected by client', true, { pendingRequestsCancelled: pendingCount });
  }

  /**
   * Check if connected.
   */
  isConnected(): boolean {
    return this.socket?.readyState === WebSocket.OPEN;
  }

  /**
   * Send a response back to the server.
   */
  send(message: OutgoingMessage): void {
    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
      log.error('Cannot send: not connected');
      return;
    }

    const data = JSON.stringify(message);
    log.debug('Sending:', data);
    this.socket.send(data);
  }

  /**
   * Handle incoming WebSocket message.
   */
  private async handleMessage(data: string): Promise<void> {
    let messageId: string | undefined;

    try {
      const message = JSON.parse(data) as IncomingMessage;
      messageId = message.id;
      log.info('[WS] Received message:', message.type, message.id);

      if (!this.messageHandler) {
        log.error('No message handler set');
        this.send({
          id: message.id,
          success: false,
          error: {
            code: 'NO_HANDLER',
            message: 'No message handler configured',
          },
        });
        return;
      }

      log.info('[WS] Calling message handler for:', message.type);
      const response = await this.messageHandler(message);
      log.info('[WS] Message handler returned, sending response');
      this.send(response);
    } catch (error) {
      log.error('[WS] Failed to handle message:', error);
      // Send error response back to server so it doesn't timeout
      if (messageId) {
        this.send({
          id: messageId,
          success: false,
          error: {
            code: 'HANDLER_ERROR',
            message: error instanceof Error ? error.message : String(error),
          },
        });
      }
    }
  }

  /**
   * Handle disconnection with auto-reconnect.
   * Uses fixed 5-second interval, no exponential backoff.
   * Retries indefinitely when MAX_RECONNECT_ATTEMPTS is 0.
   */
  private handleDisconnect(): void {
    log.info(`[WS] handleDisconnect() - shouldReconnect: ${this.shouldReconnect}, attempts: ${this.reconnectAttempts}/${CONFIG.MAX_RECONNECT_ATTEMPTS || 'unlimited'}`);

    if (!this.shouldReconnect) {
      return;
    }

    // Skip max attempts check if unlimited (0)
    if (CONFIG.MAX_RECONNECT_ATTEMPTS > 0 && this.reconnectAttempts >= CONFIG.MAX_RECONNECT_ATTEMPTS) {
      log.error('[WS] Max reconnect attempts reached');
      logError('ws_reconnect_failed', `Max reconnect attempts reached (${CONFIG.MAX_RECONNECT_ATTEMPTS})`, { attempts: this.reconnectAttempts, maxAttempts: CONFIG.MAX_RECONNECT_ATTEMPTS });
      return;
    }

    this.reconnectAttempts++;
    // Fixed interval, no exponential backoff
    const delay = CONFIG.RECONNECT_INTERVAL_MS;

    log.info(`[WS] Reconnecting in ${delay / 1000}s (attempt ${this.reconnectAttempts})`);
    logConnection('ws_reconnecting', `Reconnecting in ${delay / 1000}s (attempt ${this.reconnectAttempts})`, true, { attempt: this.reconnectAttempts, delayMs: delay });

    this.reconnectTimer = setTimeout(() => {
      this.connect().catch(error => {
        log.error('[WS] Reconnect failed:', error);
      });
    }, delay);
  }
}
</file>

<file path="src/content/aria-tree.ts">
/**
 * Builds an accessibility tree from the DOM.
 * Captures element roles, names, and states for AI consumption.
 */

import type { AriaNode, Snapshot } from '@/types/messages';
import { CONFIG } from '@/types/config';
import { buildSelector } from './selector';
import {
  CHECKABLE_ROLES,
  DISABLEABLE_ROLES,
  EXPANDABLE_ROLES,
  LEVELED_ROLES,
  SELECTABLE_ROLES,
  INTERACTIVE_TAGS,
  TAG_TO_ROLE,
} from './aria/roles';

let currentGeneration = 0;
let currentSnapshot: Snapshot | null = null;

/**
 * Generate a fresh accessibility snapshot of the document.
 */
export function generateSnapshot(): Snapshot {
  currentGeneration++;
  const elements = new Map<number, Element>();
  let elementIndex = 0;

  const assignRef = (element: Element): number => {
    const index = ++elementIndex;
    elements.set(index, element);
    return index;
  };

  const root = buildAriaTree(document.body, assignRef);

  currentSnapshot = {
    generation: currentGeneration,
    elements,
    root,
    timestamp: Date.now(),
  };

  return currentSnapshot;
}

/**
 * Get the current snapshot if it's still fresh.
 */
export function getCurrentSnapshot(): Snapshot | null {
  if (!currentSnapshot) {
    return null;
  }

  const age = Date.now() - currentSnapshot.timestamp;
  if (age > CONFIG.MAX_SNAPSHOT_AGE_MS) {
    return null;
  }

  return currentSnapshot;
}

/**
 * Get an element by its reference string.
 */
export function getElementByRef(ref: string): Element | null {
  const match = ref.match(/^s(\d+)e(\d+)$/);
  if (!match) {
    return null;
  }

  const [, genStr, idStr] = match;
  const generation = parseInt(genStr, 10);
  const elementId = parseInt(idStr, 10);

  if (!currentSnapshot || currentSnapshot.generation !== generation) {
    return null;
  }

  return currentSnapshot.elements.get(elementId) || null;
}

/**
 * Build the ARIA tree recursively.
 */
function buildAriaTree(
  element: Element,
  assignRef: (el: Element) => number
): AriaNode {
  const role = getElementRole(element);
  const name = getAccessibleName(element);
  const ref = `s${currentGeneration}e${assignRef(element)}`;

  const node: AriaNode = {
    role,
    name: truncateName(name),
    ref,
    children: [],
    props: {},
  };

  // Add state properties
  addStateProps(element, role, node);

  // Add URL for links
  if (role === 'link' && element instanceof HTMLAnchorElement) {
    node.props.url = element.href;
  }

  // Process children
  for (const child of element.children) {
    if (shouldSkipElement(child)) {
      continue;
    }

    const childRole = getElementRole(child);

    // Skip elements with no semantic role
    if (childRole === 'generic' && !hasInteractiveDescendants(child)) {
      // Flatten generic containers
      const grandchildren = buildChildrenList(child, assignRef);
      node.children.push(...grandchildren);
    } else {
      const childNode = buildAriaTree(child, assignRef);
      node.children.push(childNode);
    }
  }

  // Add text content for leaf nodes
  if (node.children.length === 0 && !name) {
    const text = getDirectTextContent(element);
    if (text) {
      node.children.push(text);
    }
  }

  return node;
}

/**
 * Build children list for an element.
 */
function buildChildrenList(
  element: Element,
  assignRef: (el: Element) => number
): (AriaNode | string)[] {
  const children: (AriaNode | string)[] = [];

  for (const child of element.children) {
    if (shouldSkipElement(child)) {
      continue;
    }

    const childRole = getElementRole(child);
    if (childRole === 'generic' && !hasInteractiveDescendants(child)) {
      children.push(...buildChildrenList(child, assignRef));
    } else {
      children.push(buildAriaTree(child, assignRef));
    }
  }

  return children;
}

/**
 * Get the ARIA role for an element.
 */
function getElementRole(element: Element): string {
  // Explicit role takes precedence
  const explicitRole = element.getAttribute('role');
  if (explicitRole && explicitRole !== 'presentation' && explicitRole !== 'none') {
    return explicitRole;
  }

  // Skip presentational elements
  if (explicitRole === 'presentation' || explicitRole === 'none') {
    return 'generic';
  }

  // Map tag to role
  const tagRole = TAG_TO_ROLE[element.tagName];
  if (tagRole) {
    // Special handling for input types
    if (element.tagName === 'INPUT') {
      const type = (element as HTMLInputElement).type.toLowerCase();
      if (type === 'checkbox') return 'checkbox';
      if (type === 'radio') return 'radio';
      if (type === 'button' || type === 'submit' || type === 'reset') return 'button';
      if (type === 'range') return 'slider';
      if (type === 'number') return 'spinbutton';
      return 'textbox';
    }
    return tagRole;
  }

  // Check if element is interactive via click handlers or tabindex
  if (element.hasAttribute('onclick') || element.hasAttribute('tabindex')) {
    return 'button';
  }

  return 'generic';
}

/**
 * Get the accessible name for an element.
 */
function getAccessibleName(element: Element): string {
  // aria-label
  const ariaLabel = element.getAttribute('aria-label');
  if (ariaLabel) {
    return ariaLabel.trim();
  }

  // aria-labelledby
  const labelledBy = element.getAttribute('aria-labelledby');
  if (labelledBy) {
    const labelParts = labelledBy.split(/\s+/).map(id => {
      const labelEl = document.getElementById(id);
      return labelEl?.textContent?.trim() || '';
    });
    const combined = labelParts.filter(Boolean).join(' ');
    if (combined) {
      return combined;
    }
  }

  // title attribute
  const title = element.getAttribute('title');
  if (title) {
    return title.trim();
  }

  // alt for images
  if (element instanceof HTMLImageElement) {
    return element.alt;
  }

  // placeholder for inputs
  if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
    if (element.placeholder) {
      return element.placeholder;
    }
  }

  // label element for form controls
  if (element instanceof HTMLInputElement || element instanceof HTMLSelectElement || element instanceof HTMLTextAreaElement) {
    const id = element.id;
    if (id) {
      const label = document.querySelector(`label[for="${id}"]`);
      if (label) {
        return label.textContent?.trim() || '';
      }
    }
  }

  // Text content for buttons and links
  if (element.tagName === 'BUTTON' || element.tagName === 'A') {
    return getDirectTextContent(element);
  }

  // Heading text
  if (/^H[1-6]$/.test(element.tagName)) {
    return element.textContent?.trim() || '';
  }

  return '';
}

/**
 * Get direct text content (not from children).
 */
function getDirectTextContent(element: Element): string {
  let text = '';
  for (const node of element.childNodes) {
    if (node.nodeType === Node.TEXT_NODE) {
      text += node.textContent || '';
    }
  }
  return text.trim();
}

/**
 * Add state properties to a node.
 */
function addStateProps(element: Element, role: string, node: AriaNode): void {
  // Checked state
  if (CHECKABLE_ROLES.includes(role)) {
    const checked = element.getAttribute('aria-checked');
    if (checked === 'mixed') {
      node.checked = 'mixed';
    } else if (checked === 'true' || (element as HTMLInputElement).checked) {
      node.checked = true;
    }
  }

  // Disabled state
  if (DISABLEABLE_ROLES.includes(role)) {
    if (
      element.getAttribute('aria-disabled') === 'true' ||
      (element as HTMLInputElement).disabled
    ) {
      node.disabled = true;
    }
  }

  // Expanded state
  if (EXPANDABLE_ROLES.includes(role)) {
    const expanded = element.getAttribute('aria-expanded');
    if (expanded === 'true') {
      node.expanded = true;
    }
  }

  // Selected state
  if (SELECTABLE_ROLES.includes(role)) {
    const selected = element.getAttribute('aria-selected');
    if (selected === 'true') {
      node.selected = true;
    }
  }

  // Level for headings
  if (role === 'heading') {
    const ariaLevel = element.getAttribute('aria-level');
    if (ariaLevel) {
      node.level = parseInt(ariaLevel, 10);
    } else if (/^H([1-6])$/.test(element.tagName)) {
      node.level = parseInt(element.tagName[1], 10);
    }
  }
}

/**
 * Check if element should be skipped.
 */
function shouldSkipElement(element: Element): boolean {
  // Skip hidden elements
  if (element instanceof HTMLElement) {
    const style = window.getComputedStyle(element);
    if (style.display === 'none' || style.visibility === 'hidden') {
      return true;
    }
    if (element.hidden) {
      return true;
    }
  }

  // Skip aria-hidden
  if (element.getAttribute('aria-hidden') === 'true') {
    return true;
  }

  // Skip script and style
  if (element.tagName === 'SCRIPT' || element.tagName === 'STYLE' || element.tagName === 'NOSCRIPT') {
    return true;
  }

  return false;
}

/**
 * Check if element has interactive descendants.
 */
function hasInteractiveDescendants(element: Element): boolean {
  for (const tag of INTERACTIVE_TAGS) {
    if (element.querySelector(tag)) {
      return true;
    }
  }

  if (element.querySelector('[role]')) {
    return true;
  }

  if (element.querySelector('[tabindex]')) {
    return true;
  }

  return false;
}

/**
 * Truncate name to max length.
 */
function truncateName(name: string): string {
  if (name.length <= CONFIG.MAX_NAME_LENGTH) {
    return name;
  }
  return name.slice(0, CONFIG.MAX_NAME_LENGTH - 3) + '...';
}

/**
 * Format snapshot as YAML-like text for AI consumption.
 */
export function formatSnapshotAsText(snapshot: Snapshot): string {
  const lines: string[] = [];
  formatNode(snapshot.root, lines, 0, snapshot);
  return lines.join('\n');
}

/**
 * Extract element index from ref string (e.g., "s1e42" -> 42)
 */
function getElementIndexFromRef(ref: string): number | null {
  const match = ref.match(/^s\d+e(\d+)$/);
  return match ? parseInt(match[1], 10) : null;
}

/**
 * Build CSS selector for an element from the snapshot.
 * Returns null if element not found or selector fails.
 */
function buildCssSelector(ref: string, snapshot: Snapshot): string | null {
  const index = getElementIndexFromRef(ref);
  if (index === null) return null;

  const element = snapshot.elements.get(index);
  if (!element) return null;

  try {
    return buildSelector(element);
  } catch {
    return null;
  }
}

function formatNode(node: AriaNode | string, lines: string[], indent: number, snapshot: Snapshot): void {
  const prefix = '  '.repeat(indent);

  if (typeof node === 'string') {
    const trimmed = node.trim();
    if (trimmed) {
      lines.push(`${prefix}- text: "${escapeText(trimmed)}"`);
    }
    return;
  }

  // Skip generic with no name
  if (node.role === 'generic' && !node.name) {
    for (const child of node.children) {
      formatNode(child, lines, indent, snapshot);
    }
    return;
  }

  let line = `${prefix}- ${node.role}`;

  if (node.name) {
    line += ` "${escapeText(node.name)}"`;
  }

  // Add state flags
  if (node.checked === true) line += ' [checked]';
  if (node.checked === 'mixed') line += ' [checked=mixed]';
  if (node.disabled) line += ' [disabled]';
  if (node.expanded) line += ' [expanded]';
  if (node.selected) line += ' [selected]';
  if (node.level) line += ` [level=${node.level}]`;

  // Add ref with CSS selector
  const cssSelector = buildCssSelector(node.ref, snapshot);
  if (cssSelector) {
    line += ` [${node.ref}|${cssSelector}]`;
  } else {
    line += ` [${node.ref}]`;
  }

  // Handle children
  if (node.children.length === 0 && Object.keys(node.props).length === 0) {
    lines.push(line);
  } else if (node.children.length === 1 && typeof node.children[0] === 'string' && Object.keys(node.props).length === 0) {
    const text = (node.children[0] as string).trim();
    if (text && text !== node.name) {
      lines.push(`${line}: "${escapeText(text)}"`);
    } else {
      lines.push(line);
    }
  } else {
    lines.push(`${line}:`);

    // Add props
    for (const [key, value] of Object.entries(node.props)) {
      lines.push(`${prefix}  - /${key}: ${JSON.stringify(value)}`);
    }

    // Add children
    for (const child of node.children) {
      formatNode(child, lines, indent + 1, snapshot);
    }
  }
}

function escapeText(text: string): string {
  return text
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r');
}
</file>

<file path="src/content/index.ts">
/**
 * Content script entry point.
 * Runs in the context of web pages and handles DOM interactions.
 */

import {
  generateSnapshot,
  getCurrentSnapshot,
  getElementByRef,
  formatSnapshotAsText,
} from './aria-tree';
import {
  buildSelector,
  findElement,
  getElementCenter,
  scrollIntoView,
  isElementVisible,
  isElementClickable,
} from './selector';
import type { ContentScriptRequest, ContentScriptResponse, Coordinates } from '@/types/messages';
import { TIMEOUTS, getHighlightCSS } from '@/constants';
import { CONFIG } from '@/types/config';

// Visual highlight overlay
let highlightOverlay: HTMLDivElement | null = null;

/**
 * Handle messages from background script.
 */
chrome.runtime.onMessage.addListener(
  (
    request: ContentScriptRequest,
    _sender: chrome.runtime.MessageSender,
    sendResponse: (response: ContentScriptResponse) => void
  ) => {
    handleRequest(request)
      .then(result => sendResponse({ success: true, data: result }))
      .catch(error => sendResponse({ success: false, error: error.message }));

    // Return true to indicate async response
    return true;
  }
);

/**
 * Route request to appropriate handler.
 */
async function handleRequest(request: ContentScriptRequest): Promise<unknown> {
  const { action, payload } = request;

  switch (action) {
    case 'generateSnapshot':
      return handleGenerateSnapshot();

    case 'getSelector':
      return handleGetSelector(payload as { ref: string });

    case 'getElementCoordinates':
      return handleGetElementCoordinates(payload as { selector: string; clickable?: boolean });

    case 'scrollIntoView':
      return handleScrollIntoView(payload as { selector: string });

    case 'selectOption':
      return handleSelectOption(payload as { selector: string; values: string[] });

    case 'getText':
      return handleGetText(payload as { selector: string });

    case 'getAttribute':
      return handleGetAttribute(payload as { selector: string; attribute: string });

    case 'isVisible':
      return handleIsVisible(payload as { selector: string });

    case 'waitForElement':
      return handleWaitForElement(payload as { selector: string; timeout?: number });

    case 'highlight':
      return handleHighlight(payload as { selector: string });

    case 'waitForDomStable':
      return handleWaitForDomStable(payload as { timeout?: number });

    case 'getPageInfo':
      return handleGetPageInfo();

    case 'evaluate':
      return handleEvaluate(payload as { code: string });

    default:
      throw new Error(`Unknown action: ${action}`);
  }
}

/**
 * Evaluate JavaScript code in the page context.
 */
function handleEvaluate(payload: { code: string }): unknown {
  try {
    // Use indirect eval to run in global scope
    // eslint-disable-next-line no-eval
    const result = (0, eval)(payload.code);
    return result;
  } catch (error) {
    throw new Error(`Evaluation error: ${(error as Error).message}`);
  }
}

/**
 * Generate accessibility snapshot.
 */
function handleGenerateSnapshot(): string {
  const snapshot = generateSnapshot();
  return formatSnapshotAsText(snapshot);
}

/**
 * Get CSS selector for an element ref.
 */
function handleGetSelector(payload: { ref: string }): string {
  const element = getElementByRef(payload.ref);
  if (!element) {
    const snapshot = getCurrentSnapshot();
    if (!snapshot) {
      throw new Error('No snapshot available. Generate a snapshot first.');
    }

    const refMatch = payload.ref.match(/^s(\d+)e/);
    if (refMatch && parseInt(refMatch[1], 10) !== snapshot.generation) {
      throw new Error(
        `Stale element reference. Snapshot generation is ${snapshot.generation}, ` +
        `but ref is from generation ${refMatch[1]}. Regenerate snapshot.`
      );
    }

    throw new Error(`Element not found for ref: ${payload.ref}`);
  }

  return buildSelector(element);
}

/**
 * Get center coordinates of an element.
 */
async function handleGetElementCoordinates(
  payload: { selector: string; clickable?: boolean }
): Promise<Coordinates> {
  const element = await findElement(payload.selector, {
    visible: true,
    clickable: payload.clickable,
  });

  return getElementCenter(element);
}

/**
 * Scroll element into view.
 */
async function handleScrollIntoView(payload: { selector: string }): Promise<void> {
  const element = await findElement(payload.selector, { visible: false });
  await scrollIntoView(element);
}

/**
 * Select option(s) in a dropdown.
 */
async function handleSelectOption(
  payload: { selector: string; values: string[] }
): Promise<void> {
  const element = await findElement(payload.selector);

  if (!(element instanceof HTMLSelectElement)) {
    throw new Error('Element is not a <select>');
  }

  const select = element;
  const valuesToSelect = select.multiple ? payload.values : [payload.values[0]];

  // Clear previous selection if single-select
  if (!select.multiple) {
    select.value = '';
  }

  for (const value of valuesToSelect) {
    const option = Array.from(select.options).find(
      opt => opt.value === value || opt.textContent?.trim() === value
    );

    if (!option) {
      throw new Error(`Option not found: ${value}`);
    }

    option.selected = true;
  }

  // Dispatch events
  select.dispatchEvent(new Event('input', { bubbles: true }));
  select.dispatchEvent(new Event('change', { bubbles: true }));
}

/**
 * Get text content of an element.
 */
async function handleGetText(payload: { selector: string }): Promise<string> {
  const element = await findElement(payload.selector);
  return element.textContent?.trim() || '';
}

/**
 * Get attribute value of an element.
 */
async function handleGetAttribute(
  payload: { selector: string; attribute: string }
): Promise<string | null> {
  const element = await findElement(payload.selector);
  return element.getAttribute(payload.attribute);
}

/**
 * Check if element is visible.
 */
async function handleIsVisible(payload: { selector: string }): Promise<boolean> {
  try {
    const element = document.querySelector(payload.selector);
    if (!element) {
      return false;
    }
    return isElementVisible(element);
  } catch {
    return false;
  }
}

/**
 * Wait for element to appear.
 */
async function handleWaitForElement(
  payload: { selector: string; timeout?: number }
): Promise<boolean> {
  try {
    await findElement(payload.selector, {
      timeout: payload.timeout || CONFIG.ELEMENT_WAIT_TIMEOUT_MS,
      visible: true,
    });
    return true;
  } catch {
    return false;
  }
}

/**
 * Highlight an element visually (for debugging).
 */
async function handleHighlight(payload: { selector: string }): Promise<void> {
  // Remove previous highlight
  if (highlightOverlay) {
    highlightOverlay.remove();
    highlightOverlay = null;
  }

  const element = await findElement(payload.selector);
  const rect = element.getBoundingClientRect();

  highlightOverlay = document.createElement('div');
  highlightOverlay.style.cssText = getHighlightCSS(rect);

  document.body.appendChild(highlightOverlay);

  // Remove after highlight duration
  setTimeout(() => {
    if (highlightOverlay) {
      highlightOverlay.remove();
      highlightOverlay = null;
    }
  }, TIMEOUTS.HIGHLIGHT_DURATION);
}

/**
 * Wait for DOM to stabilize (no mutations for a period).
 */
function handleWaitForDomStable(payload: { timeout?: number }): Promise<void> {
  const timeout = payload.timeout || CONFIG.DOM_STABILITY_MS;

  return new Promise((resolve) => {
    let timer: ReturnType<typeof setTimeout>;

    const observer = new MutationObserver(() => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        observer.disconnect();
        resolve();
      }, timeout);
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      characterData: true,
    });

    // Start the timer immediately
    timer = setTimeout(() => {
      observer.disconnect();
      resolve();
    }, timeout);
  });
}

/**
 * Get page information.
 */
function handleGetPageInfo(): { url: string; title: string } {
  return {
    url: window.location.href,
    title: document.title,
  };
}

// Log that content script is loaded
console.log('[AgentJake] Content script loaded');
</file>

<file path="src/popup/popup.ts">
/**
 * Popup script for extension UI.
 * Manages authentication and tab connection UI.
 */

interface TabInfo {
  id: number;
  url: string;
  title: string;
  active: boolean;
  connected: boolean;
  favIconUrl?: string;
}

interface Status {
  connected: boolean;
  tabId: number | null;
  tabs: TabInfo[];
}

interface AuthState {
  isAuthenticated: boolean;
  user: AuthUser | null;
  isConnected: boolean;
  /** Detailed connection state */
  connectionState?: string;
  /** User-friendly status message */
  statusMessage?: string;
  /** Number of reconnect attempts */
  reconnectAttempt?: number;
  /** Last error if any */
  lastError?: string | null;
}

interface AuthUser {
  id: number;
  name: string;
  email: string;
}

interface LoginResponse {
  success: boolean;
  token?: string;
  user?: AuthUser;
  error?: string;
}

interface ActivityEntry {
  id: string;
  timestamp: number;
  type: 'connection' | 'tab' | 'tool' | 'error' | 'auth';
  action: string;
  description: string;
  details?: Record<string, unknown>;
  success: boolean;
  durationMs?: number;
}

interface ActivityLogResponse {
  activities: ActivityEntry[];
  total: number;
}

// Auth elements
const authSection = document.getElementById('authSection')!;
const authForm = document.getElementById('authForm')!;
const authSignedIn = document.getElementById('authSignedIn')!;
const emailInput = document.getElementById('email') as HTMLInputElement;
const passwordInput = document.getElementById('password') as HTMLInputElement;
const signinBtn = document.getElementById('signinBtn')!;
const signoutBtn = document.getElementById('signoutBtn')!;
const userNameEl = document.getElementById('userName')!;
const userEmailEl = document.getElementById('userEmail')!;
const userAvatarEl = document.getElementById('userAvatar')!;
const connectionStatusEl = document.getElementById('connectionStatus')!;
const authError = document.getElementById('authError')!;

// Tab control elements
const statusDot = document.getElementById('statusDot')!;
const statusText = document.getElementById('statusText')!;
const tabList = document.getElementById('tabList')!;
const connectSection = document.getElementById('connectSection')!;
const connectedSection = document.getElementById('connectedSection')!;
const focusBtn = document.getElementById('focusBtn')!;
const disconnectBtn = document.getElementById('disconnectBtn')!;
const showTabBtn = document.getElementById('showTabBtn') as HTMLButtonElement;
const disconnectInlineBtn = document.getElementById('disconnectInlineBtn') as HTMLButtonElement;

// Activity log elements
const activityLog = document.getElementById('activityLog')!;
const seeMoreBtn = document.getElementById('seeMoreBtn')!;
const activityTotal = document.getElementById('activityTotal')!;
const clearActivityBtn = document.getElementById('clearActivityBtn')!;
const refreshActivityBtn = document.getElementById('refreshActivityBtn')!;
const activityModal = document.getElementById('activityModal')!;
const modalClose = document.getElementById('modalClose')!;
const modalActivityLog = document.getElementById('modalActivityLog')!;
const filterBtns = document.querySelectorAll('.filter-btn');

// State
let allActivities: ActivityEntry[] = [];
let currentFilter = 'all';
let displayedActivityIds: Set<string> = new Set();
let currentAuthState: AuthState = {
  isAuthenticated: false,
  user: null,
  isConnected: false,
};

/**
 * Send message to background script.
 */
async function sendMessage<T>(action: string, payload?: unknown): Promise<T> {
  return new Promise((resolve, reject) => {
    chrome.runtime.sendMessage({ action, payload }, (response) => {
      if (chrome.runtime.lastError) {
        reject(new Error(chrome.runtime.lastError.message));
      } else if (response === undefined) {
        reject(new Error('No response from background script'));
      } else {
        resolve(response as T);
      }
    });
  });
}

// ==================== AUTH FUNCTIONS ====================

/**
 * Get current auth state from background.
 */
async function refreshAuthState(): Promise<void> {
  try {
    const state = await sendMessage<AuthState>('getAuthState');
    currentAuthState = state;
    updateAuthUI(state);
  } catch (error) {
    console.error('Failed to get auth state:', error);
  }
}

/**
 * Update auth UI based on state.
 */
function updateAuthUI(state: AuthState): void {
  if (state.isAuthenticated && state.user) {
    // Show signed-in state
    authForm.style.display = 'none';
    authSignedIn.style.display = 'block';

    // Update user info (with defensive checks)
    const userName = state.user.name || 'User';
    const userEmail = state.user.email || '';
    userNameEl.textContent = userName;
    userEmailEl.textContent = userEmail;

    // Generate avatar initials (with fallback)
    const initials = userName
      .split(' ')
      .map(n => n[0])
      .filter(Boolean)
      .join('')
      .toUpperCase()
      .slice(0, 2) || '?';
    userAvatarEl.textContent = initials;

    // Update connection status with detailed state
    updateConnectionStatus(state);

    // Enable tab controls
    connectSection.classList.add('authenticated');
  } else {
    // Show sign-in form
    authForm.style.display = 'block';
    authSignedIn.style.display = 'none';

    // Disable tab controls
    connectSection.classList.remove('authenticated');
  }

  // Hide any previous errors
  authError.style.display = 'none';
}

/**
 * Handle sign-in form submission.
 */
async function handleSignIn(e: Event): Promise<void> {
  e.preventDefault();

  const email = emailInput.value.trim();
  const password = passwordInput.value;

  if (!email || !password) {
    showAuthError('Please enter email and password');
    return;
  }

  // Show loading state
  signinBtn.classList.add('loading');
  signinBtn.setAttribute('disabled', 'true');
  authError.style.display = 'none';

  try {
    const response = await sendMessage<LoginResponse>('login', { email, password });

    if (response.success) {
      // Clear form
      emailInput.value = '';
      passwordInput.value = '';

      // Refresh auth state to update UI
      await refreshAuthState();
    } else {
      showAuthError(response.error || 'Login failed');
    }
  } catch (error) {
    showAuthError((error as Error).message || 'Connection error');
  } finally {
    signinBtn.classList.remove('loading');
    signinBtn.removeAttribute('disabled');
  }
}

/**
 * Handle sign-out button click.
 */
async function handleSignOut(): Promise<void> {
  try {
    await sendMessage('logout');
    await refreshAuthState();
  } catch (error) {
    console.error('Failed to sign out:', error);
  }
}

/**
 * Update connection status display with detailed state.
 */
function updateConnectionStatus(state: AuthState): void {
  // Use the detailed status message if available
  const statusMessage = state.statusMessage || (state.isConnected ? 'Connected to server' : 'Disconnected');
  connectionStatusEl.textContent = statusMessage;

  // Remove all state classes
  connectionStatusEl.classList.remove('online', 'offline', 'connecting', 'error');

  // Add appropriate class based on connection state
  const connState = state.connectionState || 'disconnected';
  switch (connState) {
    case 'connected':
      connectionStatusEl.classList.add('online');
      break;
    case 'connecting':
    case 'reconnecting':
      connectionStatusEl.classList.add('connecting');
      break;
    case 'failed':
      connectionStatusEl.classList.add('error');
      break;
    case 'offline':
    case 'disconnected':
    default:
      connectionStatusEl.classList.add('offline');
      break;
  }

  // Show reconnect attempt count if reconnecting
  if (state.reconnectAttempt && state.reconnectAttempt > 0 && connState === 'reconnecting') {
    connectionStatusEl.title = `Attempt ${state.reconnectAttempt}`;
  } else {
    connectionStatusEl.title = '';
  }
}

/**
 * Show authentication error.
 */
function showAuthError(message: string): void {
  authError.textContent = message;
  authError.style.display = 'block';
}

// ==================== TAB FUNCTIONS ====================

/**
 * Update tab UI based on status.
 */
function updateTabUI(status: Status): void {
  const connectedTab = status.tabs.find(t => t.connected);

  if (connectedTab) {
    statusDot.className = status.connected ? 'status-dot connected' : 'status-dot tab-connected';
    statusText.textContent = status.connected
      ? `Connected to "${truncate(connectedTab.title, 25)}"`
      : `Tab connected, waiting for server...`;

    connectSection.querySelector('.tab-selector')?.classList.add('hidden');
    connectedSection.style.display = 'block';

    // Enable inline buttons when connected
    if (showTabBtn) showTabBtn.disabled = false;
    if (disconnectInlineBtn) disconnectInlineBtn.disabled = false;
  } else {
    statusDot.className = 'status-dot';
    statusText.textContent = 'No tab connected';

    connectSection.querySelector('.tab-selector')?.classList.remove('hidden');
    connectedSection.style.display = 'none';

    // Disable inline buttons when not connected
    if (showTabBtn) showTabBtn.disabled = true;
    if (disconnectInlineBtn) disconnectInlineBtn.disabled = true;
  }

  renderTabList(status.tabs);
}

/**
 * Render the list of available tabs.
 */
function renderTabList(tabs: TabInfo[]): void {
  const validTabs = tabs.filter(tab => {
    if (!tab.url || tab.url === 'about:blank' || tab.url === 'chrome://newtab/') {
      return true;
    }
    return !tab.url.startsWith('chrome://') &&
           !tab.url.startsWith('chrome-extension://');
  });

  if (validTabs.length === 0) {
    tabList.innerHTML = '<div class="empty-state">No valid tabs available</div>';
    return;
  }

  const sortedTabs = [...validTabs].sort((a, b) => {
    if (a.connected && !b.connected) return -1;
    if (!a.connected && b.connected) return 1;
    if (a.active && !b.active) return -1;
    if (!a.active && b.active) return 1;
    return 0;
  });

  tabList.innerHTML = sortedTabs.map(tab => {
    let badge = '';
    if (tab.connected) {
      badge = '<span class="connected-badge">CONNECTED</span>';
    } else if (tab.active) {
      badge = '<span class="current-badge">CURRENT</span>';
    }

    return `
      <div class="tab-item ${tab.connected ? 'active' : ''}" data-tab-id="${tab.id}" data-tab-url="${tab.url || ''}">
        <img
          class="tab-favicon"
          src="${tab.favIconUrl || 'data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 16 16%22><rect fill=%22%23666%22 width=%2216%22 height=%2216%22 rx=%222%22/></svg>'}"
          onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 16 16%22><rect fill=%22%23666%22 width=%2216%22 height=%2216%22 rx=%222%22/></svg>'"
        >
        <span class="tab-title">${escapeHtml(tab.title || 'Untitled')}</span>
        ${badge}
      </div>
    `;
  }).join('');

  tabList.querySelectorAll('.tab-item').forEach(item => {
    item.addEventListener('click', async () => {
      if (!currentAuthState.isAuthenticated) {
        showAuthError('Please sign in first');
        return;
      }
      const tabId = parseInt(item.getAttribute('data-tab-id')!, 10);
      const tabUrl = item.getAttribute('data-tab-url') || '';
      await connectToTab(tabId, tabUrl);
    });
  });
}

/**
 * Connect to a tab.
 */
async function connectToTab(tabId: number, tabUrl?: string): Promise<void> {
  try {
    await sendMessage('connectTab', { tabId, tabUrl });
    await refreshStatus();
  } catch (error) {
    console.error('Failed to connect:', error);
    statusText.textContent = `Error: ${(error as Error).message}`;
  }
}

/**
 * Disconnect from current tab.
 */
async function disconnect(): Promise<void> {
  try {
    await sendMessage('disconnectTab');
    await refreshStatus();
  } catch (error) {
    console.error('Failed to disconnect:', error);
  }
}

/**
 * Focus the connected tab.
 */
async function focusConnectedTab(): Promise<void> {
  const status = await sendMessage<Status>('getStatus');
  if (status.tabId) {
    const tab = await chrome.tabs.get(status.tabId);
    await chrome.tabs.update(status.tabId, { active: true });
    if (tab.windowId) {
      await chrome.windows.update(tab.windowId, { focused: true });
    }
    window.close();
  }
}

/**
 * Refresh status from background.
 */
async function refreshStatus(): Promise<void> {
  try {
    const status = await sendMessage<Status>('getStatus');
    updateTabUI(status);
  } catch (error) {
    console.error('Failed to get status:', error);
    statusText.textContent = 'Error loading status';
  }
}

// ==================== ACTIVITY LOG FUNCTIONS ====================

function formatTime(timestamp: number): string {
  const date = new Date(timestamp);
  return date.toLocaleTimeString('en-US', {
    hour12: false,
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
}

function formatDuration(ms?: number): string {
  if (ms === undefined) return '-';
  if (ms < 1000) return `${ms}ms`;
  return `${(ms / 1000).toFixed(1)}s`;
}

function renderActivityEntry(
  entry: ActivityEntry,
  options: { expanded?: boolean; animate?: boolean } = {}
): string {
  const { expanded = false, animate = true } = options;
  const statusClass = entry.success ? 'success' : 'error';
  const statusIcon = entry.success ? 'â' : 'â';
  const details = entry.details ? JSON.stringify(entry.details, null, 2) : null;
  const animateClass = animate ? '' : 'no-animate';
  const durationText = entry.durationMs !== undefined ? formatDuration(entry.durationMs) : '';

  return `
    <div class="activity-entry ${statusClass} ${expanded ? 'expanded' : ''} ${animateClass}"
         data-type="${entry.type}"
         data-id="${entry.id}">
      <div class="activity-header">
        <span class="activity-time">${formatTime(entry.timestamp)}</span>
        <span class="activity-type">${entry.type}</span>
        <span class="activity-spacer"></span>
        <span class="activity-icon">${statusIcon}</span>
        ${durationText ? `<span class="activity-duration">${durationText}</span>` : ''}
      </div>
      <div class="activity-desc">${escapeHtml(entry.description)}</div>
      ${details ? `<div class="activity-details">${escapeHtml(details)}</div>` : ''}
    </div>
  `;
}

async function refreshActivityLog(): Promise<void> {
  try {
    const response = await sendMessage<ActivityLogResponse>('getActivity', { limit: 5 });
    const activities = response?.activities ?? [];
    const total = response?.total ?? 0;

    const newIds = new Set(activities.map(e => e.id));
    const hasChanges = activities.length !== displayedActivityIds.size ||
      activities.some(e => !displayedActivityIds.has(e.id));

    if (!hasChanges && activities.length === allActivities.length) {
      return;
    }

    allActivities = activities;

    activityLog.innerHTML = activities.length > 0
      ? activities.map(e => renderActivityEntry(e, {
          animate: !displayedActivityIds.has(e.id)
        })).join('')
      : '';

    displayedActivityIds = newIds;

    if (total > 5) {
      seeMoreBtn.style.display = 'block';
      activityTotal.textContent = String(total);
    } else {
      seeMoreBtn.style.display = 'none';
    }
  } catch (error) {
    console.error('Failed to fetch activity:', error);
    allActivities = [];
    activityLog.innerHTML = '';
    seeMoreBtn.style.display = 'none';
  }
}

async function fetchAllActivities(): Promise<void> {
  try {
    const response = await sendMessage<ActivityLogResponse>('getActivity');
    allActivities = response.activities;
    renderModalActivities();
  } catch (error) {
    console.error('Failed to fetch all activities:', error);
  }
}

function renderModalActivities(): void {
  const filtered = currentFilter === 'all'
    ? allActivities
    : allActivities.filter(e => e.type === currentFilter);

  modalActivityLog.innerHTML = filtered.map(e => renderActivityEntry(e, { animate: false })).join('');

  modalActivityLog.querySelectorAll('.activity-entry').forEach(entry => {
    entry.addEventListener('click', () => {
      entry.classList.toggle('expanded');
    });
  });
}

function openActivityModal(): void {
  activityModal.classList.add('open');
  fetchAllActivities();
}

function closeActivityModal(): void {
  activityModal.classList.remove('open');
}

async function clearActivity(): Promise<void> {
  try {
    await sendMessage('clearActivity');
    displayedActivityIds = new Set();
    await refreshActivityLog();
    if (activityModal.classList.contains('open')) {
      modalActivityLog.innerHTML = '';
      allActivities = [];
    }
  } catch (error) {
    console.error('Failed to clear activity:', error);
  }
}

function setFilter(filter: string): void {
  currentFilter = filter;
  filterBtns.forEach(btn => {
    btn.classList.toggle('active', btn.getAttribute('data-filter') === filter);
  });
  renderModalActivities();
}

// ==================== UTILITIES ====================

function truncate(str: string, len: number): string {
  return str.length > len ? str.slice(0, len - 3) + '...' : str;
}

function escapeHtml(str: string): string {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// ==================== EVENT LISTENERS ====================

// Auth events
authForm.querySelector('form')?.addEventListener('submit', handleSignIn);
signinBtn.addEventListener('click', handleSignIn);
signoutBtn.addEventListener('click', handleSignOut);

// Tab events
focusBtn.addEventListener('click', focusConnectedTab);
disconnectBtn.addEventListener('click', disconnect);

// Inline user action buttons
showTabBtn?.addEventListener('click', async () => {
  const status = await sendMessage<Status>('getStatus');
  const connectedTab = status?.tabs?.find(t => t.connected);
  if (connectedTab?.id) {
    const tab = await chrome.tabs.get(connectedTab.id);
    await chrome.tabs.update(connectedTab.id, { active: true });
    if (tab.windowId) {
      await chrome.windows.update(tab.windowId, { focused: true });
    }
    window.close();
  }
});

disconnectInlineBtn?.addEventListener('click', async () => {
  await sendMessage('disconnectTab');
  await refreshStatus();
});

// Activity events
clearActivityBtn.addEventListener('click', clearActivity);
refreshActivityBtn.addEventListener('click', refreshActivityLog);
seeMoreBtn.addEventListener('click', openActivityModal);
modalClose.addEventListener('click', closeActivityModal);

activityModal.addEventListener('click', (e) => {
  if (e.target === activityModal) {
    closeActivityModal();
  }
});

filterBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    const filter = btn.getAttribute('data-filter') || 'all';
    setFilter(filter);
  });
});

// Handle Enter key in password field
passwordInput?.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    handleSignIn(e);
  }
});

// ==================== INITIALIZATION ====================

async function init(): Promise<void> {
  // Load auth state first
  await refreshAuthState();

  // Then load tab status and activity
  await Promise.all([
    refreshStatus(),
    refreshActivityLog(),
  ]);
}

// Initialize
init();

// Refresh periodically
setInterval(refreshStatus, 2000);
setInterval(refreshActivityLog, 2000);
setInterval(refreshAuthState, 5000); // Check auth state less frequently
</file>

<file path="manifest.json">
{
  "manifest_version": 3,
  "name": "Agent Jake Browser MCP",
  "version": "2.0.4",
  "description": "Browser automation extension for AI agents via Model Context Protocol",
  "permissions": [
    "alarms",
    "debugger",
    "scripting",
    "storage",
    "tabs",
    "webNavigation",
    "activeTab"
  ],
  "host_permissions": [
    "<all_urls>"
  ],
  "background": {
    "service_worker": "src/background/index.ts",
    "type": "module"
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["src/content/index.ts"],
      "run_at": "document_idle"
    }
  ],
  "action": {
    "default_popup": "src/popup/index.html",
    "default_icon": {
      "16": "icons/icon16.png",
      "48": "icons/icon48.png",
      "128": "icons/icon128.png"
    },
    "default_title": "Agent Jake Browser MCP"
  },
  "icons": {
    "16": "icons/icon16.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  }
}
</file>

<file path="package.json">
{
  "name": "agent-jake-browser-mcp-extension",
  "version": "2.0.4",
  "description": "Browser automation extension for AI agents via Model Context Protocol",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "playwright test",
    "test:headed": "playwright test --headed",
    "test:unit": "vitest run",
    "test:unit:watch": "vitest",
    "typecheck": "tsc --noEmit"
  },
  "keywords": [
    "chrome-extension",
    "browser-automation",
    "mcp",
    "ai"
  ],
  "author": "Agent Jake",
  "license": "MIT",
  "devDependencies": {
    "@crxjs/vite-plugin": "^2.0.0-beta.33",
    "@playwright/test": "^1.57.0",
    "@types/chrome": "^0.1.33",
    "@types/node": "^25.0.9",
    "playwright": "^1.57.0",
    "typescript": "^5.9.3",
    "vite": "^7.3.1",
    "vitest": "^2.1.0"
  },
  "dependencies": {
    "laravel-echo": "^2.3.0",
    "pusher-js": "^8.4.0",
    "sharp": "^0.34.5",
    "zod": "^4.3.5"
  }
}
</file>

<file path="src/background/tab-manager.ts">
/**
 * Manages connected tab state and tab operations.
 * Tracks which tab is currently being automated.
 */

import { log } from '@/utils/logger';
import { logTab, logError } from './activity-log';
import type { TabInfo } from '@/types/messages';
import { DEBUGGER } from '@/constants';

export class TabManager {
  private connectedTabId: number | null = null;
  private debuggerAttached = false;
  private pendingNewTab: TabInfo | null = null;
  private newTabListener: ((tab: chrome.tabs.Tab) => void) | null = null;

  /**
   * Initialize tab manager, restoring state from storage.
   */
  async initialize(): Promise<void> {
    const stored = await chrome.storage.local.get(DEBUGGER.STORAGE_KEY);
    if (stored[DEBUGGER.STORAGE_KEY]) {
      const tabId = stored[DEBUGGER.STORAGE_KEY] as number;
      // Verify tab still exists
      if (await this.tabExists(tabId)) {
        this.connectedTabId = tabId;
        log.info(`Restored connected tab: ${tabId}`);
      } else {
        await chrome.storage.local.remove(DEBUGGER.STORAGE_KEY);
      }
    }
  }

  /**
   * Get the currently connected tab ID.
   */
  getConnectedTabId(): number | null {
    return this.connectedTabId;
  }

  /**
   * Connect to a specific tab for automation.
   * If tabUrl is chrome://newtab/, navigates to about:blank first.
   */
  async connectTab(tabId: number, tabUrl?: string): Promise<void> {
    // If tab is chrome://newtab/, navigate to about:blank first
    // (Chrome blocks extensions from accessing chrome:// URLs)
    if (tabUrl === 'chrome://newtab/') {
      await chrome.tabs.update(tabId, { url: 'about:blank' });
      await this.waitForTabLoad(tabId);
    }

    // Disconnect previous tab if any
    if (this.connectedTabId && this.connectedTabId !== tabId) {
      await this.disconnectTab();
    }

    // Verify tab exists
    if (!await this.tabExists(tabId)) {
      await logError('tab_connect', `Tab ${tabId} does not exist`, { tabId });
      throw new Error(`Tab ${tabId} does not exist`);
    }

    try {
      // Attach debugger
      await this.attachDebugger(tabId);

      this.connectedTabId = tabId;
      await chrome.storage.local.set({ [DEBUGGER.STORAGE_KEY]: tabId });

      // Get tab info for logging
      const tab = await chrome.tabs.get(tabId);
      const title = tab.title || tab.url || `Tab ${tabId}`;

      log.info(`Connected to tab: ${tabId}`);
      await logTab('tab_connect', `Connected to: ${title}`, true, { tabId, url: tab.url });
    } catch (error) {
      await logError('tab_connect', `Failed to connect: ${(error as Error).message}`, { tabId });
      throw error;
    }
  }

  /**
   * Disconnect from the current tab.
   */
  async disconnectTab(): Promise<void> {
    if (!this.connectedTabId) {
      return;
    }

    const tabId = this.connectedTabId;

    await this.detachDebugger();

    this.connectedTabId = null;
    await chrome.storage.local.remove(DEBUGGER.STORAGE_KEY);

    log.info(`Disconnected from tab: ${tabId}`);
    await logTab('tab_disconnect', `Disconnected from tab ${tabId}`, true, { tabId });
  }

  /**
   * Check if a tab exists.
   */
  private async tabExists(tabId: number): Promise<boolean> {
    try {
      await chrome.tabs.get(tabId);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Check if debugger is actually attached to a tab.
   * Uses chrome.debugger.getTargets() for accurate state.
   */
  private async isDebuggerAttached(tabId: number): Promise<boolean> {
    try {
      const targets = await chrome.debugger.getTargets();
      return targets.some(t => t.tabId === tabId && t.attached);
    } catch {
      return false;
    }
  }

  /**
   * Attach debugger to tab for input simulation.
   */
  private async attachDebugger(tabId: number): Promise<void> {
    // Always check actual state, not just our flag
    const actuallyAttached = await this.isDebuggerAttached(tabId);
    if (actuallyAttached) {
      log.debug(`Debugger already attached to tab ${tabId}, skipping attach`);
      this.debuggerAttached = true;
      // Still enable domains in case they were disabled
      await this.enableDebuggerDomains(tabId);
      return;
    }

    // Reset flag before attempting attach
    this.debuggerAttached = false;

    try {
      log.info(`Attaching debugger to tab ${tabId}...`);
      await chrome.debugger.attach({ tabId }, DEBUGGER.PROTOCOL_VERSION);
      this.debuggerAttached = true;
      log.info(`Debugger attached to tab ${tabId}`);
    } catch (error) {
      // May already be attached by another client
      if ((error as Error).message?.includes('Another debugger')) {
        log.warn('Debugger already attached by another client, will try to enable domains anyway');
        this.debuggerAttached = true;
      } else {
        log.error('Failed to attach debugger:', error);
        throw error;
      }
    }

    // Always enable domains after attaching or detecting existing attachment
    // These calls are idempotent (safe to call multiple times)
    await this.enableDebuggerDomains(tabId);
  }

  /**
   * Enable required debugger protocol domains.
   */
  private async enableDebuggerDomains(tabId: number): Promise<void> {
    // Enable Runtime domain for evaluate commands
    // This must be done before Runtime.evaluate will work
    try {
      await chrome.debugger.sendCommand({ tabId }, 'Runtime.enable');
      log.info('Runtime domain enabled');
    } catch (enableError) {
      log.error('Failed to enable Runtime domain:', enableError);
    }

    // Enable Page domain for navigation and screenshots
    try {
      await chrome.debugger.sendCommand({ tabId }, 'Page.enable');
      log.info('Page domain enabled');
    } catch (enableError) {
      log.error('Failed to enable Page domain:', enableError);
    }

    // Enable DOM domain for DOM operations
    try {
      await chrome.debugger.sendCommand({ tabId }, 'DOM.enable');
      log.info('DOM domain enabled');
    } catch (enableError) {
      log.error('Failed to enable DOM domain:', enableError);
    }
  }

  /**
   * Detach debugger from tab.
   */
  private async detachDebugger(): Promise<void> {
    if (!this.connectedTabId) {
      return;
    }

    // Always reset flag
    this.debuggerAttached = false;

    try {
      await chrome.debugger.detach({ tabId: this.connectedTabId });
      log.debug('Debugger detached');
    } catch (error) {
      // May already be detached
      log.warn('Failed to detach debugger:', error);
    }
  }

  /**
   * Reattach debugger to the connected tab.
   * Called when debugger is unexpectedly detached.
   */
  async reattachDebugger(): Promise<void> {
    if (!this.connectedTabId) {
      throw new Error('No tab connected');
    }

    // Mark as detached so attachDebugger will do full attach
    this.debuggerAttached = false;

    await this.attachDebugger(this.connectedTabId);
    log.info(`[TabManager] Debugger reattached to tab ${this.connectedTabId}`);
  }

  /**
   * Mark debugger as detached (called from onDetach listener).
   */
  markDebuggerDetached(): void {
    this.debuggerAttached = false;
  }

  /**
   * Send a debugger command to the connected tab.
   * Auto-reattaches debugger if it has been detached.
   */
  async sendDebuggerCommand<T>(
    method: string,
    params?: Record<string, unknown>,
    timeout: number = 25000 // 25 seconds default timeout (less than WS timeout of 30s)
  ): Promise<T> {
    if (!this.connectedTabId) {
      throw new Error('No tab connected');
    }

    // Check actual debugger state (not just our flag) and reattach if needed
    const attached = await this.isDebuggerAttached(this.connectedTabId);
    if (!attached) {
      log.warn(`[sendDebuggerCommand] Debugger detached, reattaching to tab ${this.connectedTabId}...`);
      await this.attachDebugger(this.connectedTabId);
    }

    log.debug(`[sendDebuggerCommand] Executing ${method}`, {
      tabId: this.connectedTabId,
      hasParams: params !== undefined,
    });

    // Wrap Chrome's debugger command in a timeout
    const commandPromise = chrome.debugger.sendCommand(
      { tabId: this.connectedTabId },
      method,
      params
    ) as Promise<T>;

    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Debugger command timed out after ${timeout}ms: ${method}`));
      }, timeout);
    });

    try {
      const result = await Promise.race([commandPromise, timeoutPromise]);
      log.debug(`[sendDebuggerCommand] ${method} completed successfully`);
      return result;
    } catch (error) {
      log.error(`[sendDebuggerCommand] ${method} failed:`, error);
      throw error;
    }
  }

  /**
   * List all open tabs.
   * Only marks a tab as "active" if it's the active tab in the last focused normal window.
   */
  async listTabs(): Promise<TabInfo[]> {
    // Get the active tab in the last focused window (most reliable method)
    const [currentTab] = await chrome.tabs.query({ active: true, lastFocusedWindow: true });
    const currentTabId = currentTab?.id;

    const tabs = await chrome.tabs.query({});

    return tabs.map(tab => ({
      id: tab.id!,
      url: tab.url || '',
      title: tab.title || '',
      // Only mark the specific current tab as active
      active: tab.id === currentTabId,
      connected: tab.id === this.connectedTabId,
    }));
  }

  /**
   * Create a new tab and optionally connect to it.
   */
  async createTab(url: string, connect = true): Promise<TabInfo> {
    const tab = await chrome.tabs.create({ url });

    if (connect && tab.id) {
      // Wait for tab to finish loading
      await this.waitForTabLoad(tab.id);
      await this.connectTab(tab.id);
    }

    return {
      id: tab.id!,
      url: tab.url || url,
      title: tab.title || '',
      active: tab.active,
      connected: connect && tab.id === this.connectedTabId,
    };
  }

  /**
   * Switch to a different tab.
   */
  async switchTab(tabId: number): Promise<void> {
    if (!await this.tabExists(tabId)) {
      throw new Error(`Tab ${tabId} does not exist`);
    }

    await this.connectTab(tabId);
    await chrome.tabs.update(tabId, { active: true });
  }

  /**
   * Close a tab.
   */
  async closeTab(tabId?: number): Promise<void> {
    const targetTabId = tabId || this.connectedTabId;

    if (!targetTabId) {
      throw new Error('No tab specified and no connected tab');
    }

    if (targetTabId === this.connectedTabId) {
      await this.disconnectTab();
    }

    await chrome.tabs.remove(targetTabId);
    log.info(`Closed tab: ${targetTabId}`);
  }

  /**
   * Start listening for new tabs opened during an operation.
   * Call this before actions that might open new tabs (like clicks).
   */
  startNewTabDetection(): void {
    // Clear any previous state
    this.pendingNewTab = null;

    // Remove existing listener if any
    if (this.newTabListener) {
      chrome.tabs.onCreated.removeListener(this.newTabListener);
    }

    this.newTabListener = (tab: chrome.tabs.Tab) => {
      // Only track if we have a connected tab (automation in progress)
      // and it's not the connected tab itself
      if (this.connectedTabId && tab.id && tab.id !== this.connectedTabId) {
        log.info(`[NewTabDetection] New tab opened: ${tab.id}, url: ${tab.url || tab.pendingUrl || 'unknown'}`);
        this.pendingNewTab = {
          id: tab.id,
          url: tab.url || tab.pendingUrl || '',
          title: tab.title || '',
          active: tab.active,
          connected: false,
        };
      }
    };

    chrome.tabs.onCreated.addListener(this.newTabListener);
    log.debug('[NewTabDetection] Started listening for new tabs');
  }

  /**
   * Stop listening for new tabs and return any detected tab.
   * Returns the new tab info if one was detected, null otherwise.
   */
  stopNewTabDetection(): TabInfo | null {
    if (this.newTabListener) {
      chrome.tabs.onCreated.removeListener(this.newTabListener);
      this.newTabListener = null;
      log.debug('[NewTabDetection] Stopped listening for new tabs');
    }

    const newTab = this.pendingNewTab;
    this.pendingNewTab = null;

    if (newTab) {
      log.info(`[NewTabDetection] Returning detected new tab: ${newTab.id}`);
    }

    return newTab;
  }

  /**
   * Wait for a tab to finish loading.
   */
  private waitForTabLoad(tabId: number): Promise<void> {
    return new Promise((resolve) => {
      const listener = (
        updatedTabId: number,
        changeInfo: { status?: string }
      ) => {
        if (updatedTabId === tabId && changeInfo.status === 'complete') {
          chrome.tabs.onUpdated.removeListener(listener);
          resolve();
        }
      };
      chrome.tabs.onUpdated.addListener(listener);
    });
  }
}
</file>

<file path="src/background/tool-handlers.ts">
/**
 * Tool handlers for browser automation commands.
 * Each handler implements one MCP tool.
 */

import { z } from 'zod';
import type { TabManager } from './tab-manager';
import type { IncomingMessage, OutgoingMessage, Coordinates, ToolName as MessageToolName } from '@/types/messages';
import { CONFIG } from '@/types/config';
import { log } from '@/utils/logger';
import { logTool, logError } from './activity-log';
import { getKeyDefinition } from '@/constants/keys';
import { schemas, type ToolName } from './tools/schemas';
import { isNavigationError as isNavError } from './tools/utils';

/**
 * Create tool handlers bound to a tab manager.
 */
export function createToolHandlers(tabManager: TabManager) {
  /**
   * Send message to content script in connected tab.
   */
  async function sendToContent<T>(
    action: string,
    payload: Record<string, unknown> = {}
  ): Promise<T> {
    const tabId = tabManager.getConnectedTabId();
    if (!tabId) {
      throw new Error('No tab connected. Use the popup to connect a tab first.');
    }

    const response = await chrome.tabs.sendMessage(tabId, { action, payload });

    if (!response.success) {
      throw new Error(response.error || 'Content script error');
    }

    return response.data as T;
  }

  /**
   * Get selector for element ref.
   */
  async function getSelector(ref: string): Promise<string> {
    return sendToContent<string>('getSelector', { ref });
  }

  /**
   * Wait for DOM to stabilize after action.
   */
  async function waitForStable(): Promise<void> {
    await sendToContent('waitForDomStable', { timeout: CONFIG.DOM_STABILITY_MS });
  }

  // isNavigationError imported from './tools/utils'
  const isNavigationError = isNavError;

  /**
   * Try to wait for DOM stability, handling navigation gracefully.
   * Returns true if navigated, false if stable on same page.
   */
  async function waitForStableOrNavigation(initialUrl: string): Promise<{ navigated: boolean; newUrl?: string }> {
    const tabId = tabManager.getConnectedTabId();
    if (!tabId) throw new Error('No tab connected');

    try {
      await waitForStable();
      return { navigated: false };
    } catch (error) {
      if (isNavigationError(error as Error)) {
        // Check if navigation actually occurred
        const currentTab = await chrome.tabs.get(tabId);
        if (currentTab.url !== initialUrl) {
          log.info('[waitForStableOrNavigation] Navigation detected - action succeeded');
          return { navigated: true, newUrl: currentTab.url };
        }
        // Same URL but port closed - might be page refresh or form submit
        log.warn('[waitForStableOrNavigation] Port closed but same URL - assuming success');
        return { navigated: false };
      }
      throw error;
    }
  }

  /**
   * Send mouse event via Chrome Debugger API.
   */
  async function dispatchMouseEvent(
    type: 'mousePressed' | 'mouseReleased' | 'mouseMoved',
    x: number,
    y: number,
    button: 'left' | 'right' | 'middle' = 'left',
    clickCount = 1
  ): Promise<void> {
    await tabManager.sendDebuggerCommand('Input.dispatchMouseEvent', {
      type,
      x,
      y,
      button,
      clickCount,
    });
  }

  /**
   * Send keyboard event via Chrome Debugger API.
   */
  async function dispatchKeyEvent(
    type: 'keyDown' | 'keyUp' | 'char',
    key: string,
    text?: string
  ): Promise<void> {
    const keyDef = getKeyDefinition(key);

    await tabManager.sendDebuggerCommand('Input.dispatchKeyEvent', {
      type,
      key: keyDef.key,
      code: keyDef.code,
      windowsVirtualKeyCode: keyDef.keyCode,
      text: type === 'char' ? text : undefined,
    });
  }

  // Tool implementation map
  const handlers: Record<string, (payload: unknown) => Promise<unknown>> = {
    browser_navigate: async (payload) => {
      const { url } = schemas.browser_navigate.parse(payload);
      const tabId = tabManager.getConnectedTabId();

      if (!tabId) {
        throw new Error('No tab connected');
      }

      await chrome.tabs.update(tabId, { url });

      // Wait for navigation to complete
      await new Promise<void>((resolve) => {
        const listener = (
          updatedTabId: number,
          changeInfo: { status?: string }
        ) => {
          if (updatedTabId === tabId && changeInfo.status === 'complete') {
            chrome.tabs.onUpdated.removeListener(listener);
            resolve();
          }
        };
        chrome.tabs.onUpdated.addListener(listener);
      });

      return { navigated: url };
    },

    browser_go_back: async () => {
      await tabManager.sendDebuggerCommand('Page.navigateToHistoryEntry', {
        entryId: -1, // This won't work directly
      });
      // Actually use history API
      const tabId = tabManager.getConnectedTabId();
      if (tabId) {
        await chrome.tabs.goBack(tabId);
      }
      return { success: true };
    },

    browser_go_forward: async () => {
      const tabId = tabManager.getConnectedTabId();
      if (tabId) {
        await chrome.tabs.goForward(tabId);
      }
      return { success: true };
    },

    browser_reload: async () => {
      const tabId = tabManager.getConnectedTabId();
      if (tabId) {
        await chrome.tabs.reload(tabId);
        // Wait for reload to complete
        await new Promise<void>((resolve) => {
          const listener = (
            updatedTabId: number,
            changeInfo: { status?: string }
          ) => {
            if (updatedTabId === tabId && changeInfo.status === 'complete') {
              chrome.tabs.onUpdated.removeListener(listener);
              resolve();
            }
          };
          chrome.tabs.onUpdated.addListener(listener);
        });
      }
      return { success: true };
    },

    browser_snapshot: async () => {
      const snapshot = await sendToContent<string>('generateSnapshot');
      const { url, title } = await sendToContent<{ url: string; title: string }>('getPageInfo');

      return {
        url,
        title,
        snapshot,
      };
    },

    browser_click: async (payload) => {
      const { ref } = schemas.browser_click.parse(payload);
      const tabId = tabManager.getConnectedTabId();
      if (!tabId) throw new Error('No tab connected');

      // Capture initial URL to detect navigation
      const initialTab = await chrome.tabs.get(tabId);
      const initialUrl = initialTab.url || '';

      // Start listening for new tabs (e.g., target="_blank" links)
      tabManager.startNewTabDetection();

      try {
        const selector = await getSelector(ref);
        await sendToContent('scrollIntoView', { selector });

        const coords = await sendToContent<Coordinates>('getElementCoordinates', {
          selector,
          clickable: true,
        });

        // Click sequence: move, down, up (uses CDP, doesn't need content script)
        await dispatchMouseEvent('mouseMoved', coords.x, coords.y);
        await dispatchMouseEvent('mousePressed', coords.x, coords.y, 'left', 1);
        await dispatchMouseEvent('mouseReleased', coords.x, coords.y, 'left', 1);

        // Wait for stability, handling navigation gracefully
        const result = await waitForStableOrNavigation(initialUrl);

        // Brief additional wait for potential new tab to register
        await new Promise(resolve => setTimeout(resolve, 100));

        // Check if a new tab was opened
        const newTab = tabManager.stopNewTabDetection();

        if (result.navigated) {
          return {
            clicked: ref,
            navigated: true,
            newUrl: result.newUrl,
            ...(newTab && { newTabOpened: newTab }),
          };
        }
        return {
          clicked: ref,
          ...(newTab && { newTabOpened: newTab }),
        };
      } catch (error) {
        // Clean up listener on error
        tabManager.stopNewTabDetection();
        throw error;
      }
    },

    browser_type: async (payload) => {
      const { ref, text, clear } = schemas.browser_type.parse(payload);
      const tabId = tabManager.getConnectedTabId();
      if (!tabId) throw new Error('No tab connected');

      // Capture initial URL (typing can trigger form submission/navigation)
      const initialTab = await chrome.tabs.get(tabId);
      const initialUrl = initialTab.url || '';

      const selector = await getSelector(ref);
      await sendToContent('scrollIntoView', { selector });

      const coords = await sendToContent<Coordinates>('getElementCoordinates', { selector });

      // Click to focus
      await dispatchMouseEvent('mouseMoved', coords.x, coords.y);
      await dispatchMouseEvent('mousePressed', coords.x, coords.y, 'left', 1);
      await dispatchMouseEvent('mouseReleased', coords.x, coords.y, 'left', 1);

      // Clear existing text if requested
      if (clear) {
        await dispatchKeyEvent('keyDown', 'Control');
        await dispatchKeyEvent('keyDown', 'a');
        await dispatchKeyEvent('keyUp', 'a');
        await dispatchKeyEvent('keyUp', 'Control');
        await dispatchKeyEvent('keyDown', 'Backspace');
        await dispatchKeyEvent('keyUp', 'Backspace');
      }

      // Type each character
      for (const char of text) {
        await dispatchKeyEvent('keyDown', char);
        await dispatchKeyEvent('char', char, char);
        await dispatchKeyEvent('keyUp', char);
      }

      // Wait for stability, handling navigation gracefully
      const result = await waitForStableOrNavigation(initialUrl);
      if (result.navigated) {
        return { typed: text, cleared: clear, navigated: true, newUrl: result.newUrl };
      }
      return { typed: text, cleared: clear };
    },

    browser_hover: async (payload) => {
      const parsed = schemas.browser_hover.parse(payload);
      const ref = parsed.ref;

      const selector = await getSelector(ref);
      await sendToContent('scrollIntoView', { selector });

      const coords = await sendToContent<Coordinates>('getElementCoordinates', { selector });
      await dispatchMouseEvent('mouseMoved', coords.x, coords.y);

      return { hovered: ref };
    },

    browser_press_key: async (payload) => {
      const { key } = schemas.browser_press_key.parse(payload);
      const tabId = tabManager.getConnectedTabId();
      if (!tabId) throw new Error('No tab connected');

      // Capture initial URL (Enter key can submit forms/navigate)
      const initialTab = await chrome.tabs.get(tabId);
      const initialUrl = initialTab.url || '';

      await dispatchKeyEvent('keyDown', key);
      await dispatchKeyEvent('keyUp', key);

      // Wait for stability, handling navigation gracefully
      const result = await waitForStableOrNavigation(initialUrl);
      if (result.navigated) {
        return { pressed: key, navigated: true, newUrl: result.newUrl };
      }
      return { pressed: key };
    },

    browser_wait: async (payload) => {
      const { time } = schemas.browser_wait.parse(payload);
      await new Promise(resolve => setTimeout(resolve, time * 1000));
      return { waited: time };
    },

    browser_screenshot: async () => {
      const result = await tabManager.sendDebuggerCommand<{ data: string }>(
        'Page.captureScreenshot',
        { format: 'png' }
      );

      return {
        image: `data:image/png;base64,${result.data}`,
      };
    },

    browser_get_console_logs: async () => {
      // Note: This would require setting up Console domain monitoring
      // For now, return empty array
      return { logs: [] };
    },

    // New features
    browser_new_tab: async (payload) => {
      const { url } = schemas.browser_new_tab.parse(payload);
      const tabInfo = await tabManager.createTab(url, true);
      return { tab: tabInfo };
    },

    browser_list_tabs: async () => {
      const tabs = await tabManager.listTabs();
      return { tabs };
    },

    browser_switch_tab: async (payload) => {
      const { tabId } = schemas.browser_switch_tab.parse(payload);
      await tabManager.switchTab(tabId);
      return { switched: tabId };
    },

    browser_close_tab: async () => {
      await tabManager.closeTab();
      return { closed: true };
    },

    browser_get_text: async (payload) => {
      const { ref } = schemas.browser_get_text.parse(payload);
      const selector = await getSelector(ref);
      const text = await sendToContent<string>('getText', { selector });
      return { text };
    },

    browser_get_attribute: async (payload) => {
      const { ref, attribute } = schemas.browser_get_attribute.parse(payload);
      const selector = await getSelector(ref);
      const value = await sendToContent<string | null>('getAttribute', { selector, attribute });
      return { value };
    },

    browser_is_visible: async (payload) => {
      const { ref } = schemas.browser_is_visible.parse(payload);
      const selector = await getSelector(ref);
      const visible = await sendToContent<boolean>('isVisible', { selector });
      return { visible };
    },

    browser_wait_for_element: async (payload) => {
      const { ref, timeout } = schemas.browser_wait_for_element.parse(payload);
      const selector = await getSelector(ref);
      const found = await sendToContent<boolean>('waitForElement', { selector, timeout });
      return { found };
    },

    browser_highlight: async (payload) => {
      const { ref } = schemas.browser_highlight.parse(payload);
      const selector = await getSelector(ref);
      await sendToContent('highlight', { selector });
      return { highlighted: ref };
    },

    /**
     * JavaScript evaluation using CDP Runtime.evaluate.
     * Uses Chrome DevTools Protocol which bypasses CSP restrictions.
     */
    browser_evaluate: async (payload) => {
      const { code } = schemas.browser_evaluate.parse(payload);
      log.info('[browser_evaluate] Evaluating via CDP:', code.substring(0, 50));

      try {
        const result = await tabManager.sendDebuggerCommand<{
          result: { type: string; value?: unknown; description?: string };
          exceptionDetails?: { text: string; exception?: { description: string } };
        }>('Runtime.evaluate', {
          expression: code,
          returnByValue: true,
          awaitPromise: true,
        });

        // Check for evaluation errors
        if (result.exceptionDetails) {
          const errMsg = result.exceptionDetails.exception?.description ||
                         result.exceptionDetails.text ||
                         'Unknown evaluation error';
          throw new Error(`Evaluation failed: ${errMsg}`);
        }

        log.info('[browser_evaluate] Result type:', result.result?.type);
        return result.result?.value ?? null;
      } catch (error) {
        log.error('[browser_evaluate] CDP evaluation failed:', error);
        throw error;
      }
    },

    /**
     * Get page HTML using CDP DOM.getOuterHTML (no JS eval, CSP-safe).
     * This works on sites that block unsafe-eval in their CSP.
     */
    browser_get_html: async () => {
      log.info('[browser_get_html] Getting HTML via CDP DOM.getOuterHTML');

      // Use CDP DOM.getDocument to get the document node
      const { root } = await tabManager.sendDebuggerCommand<{ root: { nodeId: number } }>(
        'DOM.getDocument',
        { depth: 0 }
      );

      // Get the outer HTML of the document element
      const { outerHTML } = await tabManager.sendDebuggerCommand<{ outerHTML: string }>(
        'DOM.getOuterHTML',
        { nodeId: root.nodeId }
      );

      log.info('[browser_get_html] Got HTML, length:', outerHTML.length);
      return { html: outerHTML };
    },

    browser_resize_viewport: async (payload) => {
      const { width, height } = schemas.browser_resize_viewport.parse(payload);

      // Use Emulation.setDeviceMetricsOverride to set viewport
      await tabManager.sendDebuggerCommand('Emulation.setDeviceMetricsOverride', {
        width,
        height,
        deviceScaleFactor: 1,
        mobile: false,
      });

      return { width, height };
    },

    browser_upload_file: async (payload) => {
      const { ref, selector, filePath } = schemas.browser_upload_file.parse(payload);

      // Get the selector for the file input
      let targetSelector = selector;
      if (!targetSelector && ref) {
        targetSelector = await getSelector(ref);
      }

      if (!targetSelector) {
        throw new Error('Either ref or selector must be provided');
      }

      // Get the document root
      const doc = await tabManager.sendDebuggerCommand<{ root: { nodeId: number } }>(
        'DOM.getDocument',
        {}
      );

      // Find the file input element
      const node = await tabManager.sendDebuggerCommand<{ nodeId: number }>(
        'DOM.querySelector',
        {
          nodeId: doc.root.nodeId,
          selector: targetSelector,
        }
      );

      if (!node.nodeId) {
        throw new Error(`Element not found: ${targetSelector}`);
      }

      // Set the file on the input
      await tabManager.sendDebuggerCommand('DOM.setFileInputFiles', {
        nodeId: node.nodeId,
        files: [filePath],
      });

      return { uploaded: true, filePath };
    },
  };

  /**
   * Handle incoming message from WebSocket.
   */
  return async function handleMessage(message: IncomingMessage): Promise<OutgoingMessage> {
    const { id, type, payload } = message;
    const startTime = performance.now();

    log.debug(`[Tool] Received: ${type} (id: ${id})`);

    try {
      const handler = handlers[type];
      if (!handler) {
        logError(type, `Unknown tool: ${type}`, { payload });
        return {
          id,
          success: false,
          error: {
            code: 'UNKNOWN_TOOL',
            message: `Unknown tool: ${type}`,
          },
        };
      }

      const result = await handler(payload);
      const durationMs = Math.round(performance.now() - startTime);

      // Create concise description based on tool type
      const description = getToolDescription(type, payload, result);
      logTool(type, description, true, durationMs, { payload, result });

      log.info(`[Tool] Completed: ${type} (id: ${id}) - success in ${durationMs}ms`);

      return {
        id,
        success: true,
        result,
      };
    } catch (error) {
      const durationMs = Math.round(performance.now() - startTime);
      log.error(`[Tool] Failed: ${type} (id: ${id}) - ${(error as Error).message} in ${durationMs}ms`);

      logTool(type, (error as Error).message, false, durationMs, { payload, error: (error as Error).message });

      return {
        id,
        success: false,
        error: {
          code: (error as Error).name || 'EXECUTION_ERROR',
          message: (error as Error).message,
        },
      };
    }
  };
}

/**
 * Get a concise description for the tool action.
 */
function getToolDescription(type: string, payload: unknown, result: unknown): string {
  const p = payload as Record<string, unknown>;
  const r = result as Record<string, unknown>;

  switch (type) {
    case 'browser_navigate':
      return `Navigate to ${p?.url || 'unknown'}`;
    case 'browser_click':
      return `Click on "${p?.ref || p?.selector}"`;
    case 'browser_type':
      return `Type "${String(p?.text || '').slice(0, 20)}${(String(p?.text || '').length > 20) ? '...' : ''}"`;
    case 'browser_hover':
      return `Hover on "${p?.ref || p?.selector}"`;
    case 'browser_press_key':
      return `Press key "${p?.key}"`;
    case 'browser_wait':
      return `Wait ${p?.time}s`;
    case 'browser_screenshot':
      return 'Take screenshot';
    case 'browser_snapshot':
      return `Snapshot: ${r?.title || 'page'}`;
    case 'browser_new_tab':
      return `New tab: ${p?.url || 'unknown'}`;
    case 'browser_switch_tab':
      return `Switch to tab ${p?.tabId}`;
    case 'browser_close_tab':
      return 'Close tab';
    case 'browser_evaluate':
      return `Evaluate JS via CDP (${String(p?.code || '').length} chars)`;
    case 'browser_get_html':
      return `Get page HTML (${(r?.html as string)?.length || 0} chars)`;
    case 'browser_resize_viewport':
      return `Resize to ${p?.width}x${p?.height}`;
    case 'browser_upload_file':
      return `Upload file: ${p?.filePath}`;
    default:
      return type.replace('browser_', '').replace(/_/g, ' ');
  }
}

// getKeyDefinition moved to @/constants/keys

/**
 * Execute a tool command from Reverb (remote Laravel server).
 * This is used when commands come via the WebSocket channel instead of local MCP.
 */
export async function executeToolFromReverb(
  tabManager: TabManager,
  type: string,
  payload: Record<string, unknown>
): Promise<{ success: boolean; result?: unknown; error?: string }> {
  const startTime = performance.now();

  log.debug(`[Reverb Tool] Received: ${type}`);

  // Create handlers for this execution
  const handleMessage = createToolHandlers(tabManager);

  try {
    // Create a fake message ID since Reverb doesn't use the same protocol
    const fakeId = `reverb_${Date.now()}`;

    const response = await handleMessage({
      id: fakeId,
      type: type as MessageToolName,
      payload,
    });

    const durationMs = Math.round(performance.now() - startTime);

    if (response.success) {
      log.info(`[Reverb Tool] Completed: ${type} - success in ${durationMs}ms`);
      return {
        success: true,
        result: response.result,
      };
    } else {
      log.error(`[Reverb Tool] Failed: ${type} - ${response.error?.message} in ${durationMs}ms`);
      return {
        success: false,
        error: response.error?.message || 'Unknown error',
      };
    }
  } catch (error) {
    const durationMs = Math.round(performance.now() - startTime);
    const errorMsg = (error as Error).message;
    log.error(`[Reverb Tool] Exception: ${type} - ${errorMsg} in ${durationMs}ms`);

    return {
      success: false,
      error: errorMsg,
    };
  }
}
</file>

</files>
